{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///autoNumeric.min.js","webpack:///webpack/bootstrap bdbf8a949af3a66cf46b","webpack:///./src/autoNumeric.js","webpack:///external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","_typeof","obj","constructor","autoFormat","autoUnFormat","getDefaultConfig","getLanguages","validate","areSettingsValid","allowedTagList","defaultSettings","digitGroupSeparator","noSeparatorOnFocus","digitalGroupSpacing","decimalCharacter","decimalCharacterAlternative","currencySymbol","currencySymbolPlacement","negativePositiveSignPlacement","showPositiveSign","suffixText","overrideMinMaxLimits","maximumValue","minimumValue","decimalPlacesOverride","decimalPlacesShownOnFocus","scaleDivisor","scaleDecimalPlaces","scaleSymbol","saveValueToSessionStorage","onInvalidPaste","roundingMethod","allowDecimalPadding","negativeBracketsTypeOnBlur","emptyInputBehavior","leadingZero","formatOnPageLoad","selectNumberOnly","defaultValueOverride","unformatOnSubmit","outputFormat","isCancellable","modifyValueOnWheel","wheelStep","showWarnings","failOnUnknownOption","keyCode","Backspace","Tab","Enter","Shift","Ctrl","Alt","PauseBreak","CapsLock","Esc","Space","PageUp","PageDown","End","Home","LeftArrow","UpArrow","RightArrow","DownArrow","Insert","Delete","num0","num1","num2","num3","num4","num5","num6","num7","num8","num9","a","b","d","e","f","g","h","j","k","l","n","o","q","r","s","t","u","v","w","x","y","z","Windows","RightClick","numpad0","numpad1","numpad2","numpad3","numpad4","numpad5","numpad6","numpad7","numpad8","numpad9","MultiplyNumpad","PlusNumpad","MinusNumpad","DotNumpad","SlashNumpad","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","NumLock","ScrollLock","MyComputer","MyCalculator","Semicolon","Equal","Comma","Hyphen","Dot","Slash","Backquote","LeftBracket","Backslash","RightBracket","Quote","Command","keyName","Unidentified","AltGr","Fn","FnLock","Hyper","Meta","Super","SymbolLock","Clear","Copy","CrSel","Cut","EraseEof","ExSel","Paste","Redo","Undo","Accept","Again","Attn","Cancel","ContextMenu","Execute","Find","Finish","Help","Pause","Play","Props","Select","ZoomIn","ZoomOut","BrightnessDown","BrightnessUp","Eject","LogOff","Power","PowerOff","PrintScreen","Hibernate","Standby","WakeUp","Compose","Dead","Print","Minus","Plus","defaultMinimumValue","defaultMaximumValue","defaultRoundingMethod","defaultLeadingZero","defaultSelectNumberOnly","languageOption","French","NorthAmerican","British","Swiss","Japanese","Spanish","Chinese","apply","$","isNull","isUndefined","isUndefinedOrNullOrEmpty","isString","str","String","isBoolean","isTrueOrFalseString","lowercaseValue","toLowerCase","isObject","reference","isEmptyObj","prop","hasOwnProperty","isNumber","isNaN","parseFloat","isFinite","isInt","parseInt","preparePastedText","text","holder","stripAllNonNumberCharacters","settingsClone","replace","contains","needle","indexOf","isInArray","array","toString","Error","decimalPlaces","_str$split","split","_str$split2","decimalPart","keyCodeNumber","event","which","character","fromCharCode","checkIfInRange","parsedMinValue","parsedMaxValue","parsedValue","parseStr","testMinMax","isNegative","numericString","checkEverywhere","arguments","isNegativeStrict","charAt","isZeroOrHasNoValue","test","setRawNegativeSign","replaceCharAt","string","index","newCharacter","substr","clampToRangeLimits","settings","Math","max","min","countNumberCharactersOnTheCaretLeftSide","formattedNumberString","caretPosition","numberDotOrNegativeSign","RegExp","numberDotAndNegativeSignCount","findCaretPositionInFormattedNumber","rawNumberString","caretPositionInRawValue","formattedNumberStringSize","rawNumberStringSize","formattedNumberStringIndex","rawNumberStringIndex","countCharInText","charCounter","convertCharacterCountToIndexPosition","characterCount","getElementSelection","that","position","selectionStart","focus","select","document","selection","createRange","moveStart","end","start","selectionEnd","setElementSelection","range","createTextRange","collapse","moveEnd","throwError","message","warning","showWarning","console","warn","isWheelUpEvent","DOMevent","deltaY","type","isWheelDownEvent","roundToNearest","stepPlace","round","modifyAndRoundToNearestAuto","isAddition","lengthValue","abs","pow","offset","result","addAndRoundToNearestAuto","subtractAndRoundToNearestAuto","runCallbacksFoundInTheSettingsObject","$this","each","val","autoNumeric","maximumVMinAndVMaxDecimalLength","leftOrAll","skipFirstAutoStrip","trailingNegative","skipLastAutoStrip","allowedAutoStrip","match","numRegAutoStrip","join","nSign","_s$split","_s$split2","integerPart","modifiedIntegerPart","negativeSignCharacter","mIntPos","slice","mIntNeg","hasFocus","stripReg","toggleNegativeBracket","_settings$negativeBra","_settings$negativeBra2","firstBracket","lastBracket","convertToNumericString","lastIndexOf","temp","arabicToLatinNumbers","toLocale","locale","Number","modifyNegativeSignAndDecimalCharacterForRawValue","modifyNegativeSignAndDecimalCharacterForFormattedValue","checkEmpty","inputValue","signOnEmpty","addGroupSeparators","strip","empty","isValueNegative","isZero","digitalGroup","_inputValue$split","_inputValue$split2","_inputValue$split3","_inputValue$split4","substring","positiveSignCharacter","rawValue","truncateZeros","roundedInputValue","temporaryDecimalPlacesOverride","regex","roundValue","ceil","floor","ivRounded","dPos","inputValueHasADot","vdPos","cDec","zeros","rLength","tRound","odd","ivArray","truncateDecimal","isPaste","_s$split3","_s$split4","modifiedDecimalPart","nL","search","xc","yc","xNeg","checkIfInRangeWithOverrideOption","minParse","maxParse","valParse","getCurrentElement","element","getAutoNumericHolder","update","data","AutoNumericHolder","get","keepAnOriginalSettingsCopy","oDec","oPad","oBracket","oSep","oSign","oSuffix","readCookie","name","nameEQ","ca","cookie","storageTest","mod","sessionStorage","setItem","removeItem","cleanLeadingTrailingZeros","trimPaddedZerosFromDecimalPlaces","_numericString$split","_numericString$split2","trimmedDecimalPart","saveValueToPersistentStorage","action","storedName","decodeURIComponent","date","expires","Date","setTime","getTime","toUTCString","getItem","_getStringOrArray","getArrayBehavior","formIndex","allFormElements","aiIndex","scIndex","rSubmitterTypes","rSubmittable","rCheckableType","rNonAutoNumericTypes","count","field","localName","disabled","checked","formFields","serializeArray","scElement","testInput","_ret2","serialize","formParts","_formParts$i$split","_formParts$i$split2","inputName","modifiedInputValue","onFocusInAndMouseEnter","is","valueOnFocus","lastVal","onEmpty","_select","onFocus","_saveCancellableValue","onKeydown","_updateAutoNumericHolderEventKeycode","initialValueOnKeydown","readOnly","processed","eventKeyCode","preventDefault","$that","savedCancellableValue","triggerEvent","_updateAutoNumericHolderProperties","_skipAlways","_processCharacterDeletion","_formatValue","throwInput","formatted","onKeypress","eventCharacter","isCharacterInsertionAllowed","_processCharacterInsertion","onKeyup","skip","valuePartsBeforePaste","onFocusOutAndMouseLeave","origValue","_checkIfInRangeWithOv3","_checkIfInRangeWithOv4","minTest","maxTest","trigger","groupedValue","change","onPaste","rawPastedText","clipboardData","getData","initialFormattedValue","selectionSize","isAllInputTextSelected","isPasteNegative","untranslatedPastedText","pastedText","caretPositionOnInitialTextAfterPasting","initialUnformattedNumber","isInitialValueNegative","isPasteNegativeAndInitialValueIsPositive","leftPartContainedADot","leftFormattedPart","rightFormattedPart","leftPart","rightPart","lastGoodKnownResult","pastedTextIndex","modifiedLeftPart","lastGoodKnownResultIndex","lastGoodKnownResultSize","leftFormattedPart2","rightFormattedPart2","indexWherePastedTextHasBeenInserted","indexSelectionEndInRawValue","selectedText","valueHasBeenSet","valueHasBeenClamped","error","clampedValue","caretPositionInFormattedNumber","onBlur","onWheel","shiftKey","currentUnformattedValue","step","_setSelection","onSubmit","closest","on","$settings","getInputIfSupportedTagAndType","$input","currentElementTag","formatDefaultValueOnPageLoad","setValue","currentValue","unLocalizedCurrentValue","toNumericValue","attr","Infinity","toStrip","tagList","correctNegativePositiveSignPlacementOption","calculateVMinAndVMaxIntegerSizes","_settings$maximumValu","_settings$maximumValu2","maximumValueIntegerPart","_ref3","_ref4","minimumValueIntegerPart","correctDecimalPlacesOverrideOption","setsAlternativeDecimalSeparatorCharacter","cachesUsualRegularExpressions","allNumbersReg","noAllNumbersReg","aNegReg","aNegRegAutoStrip","negativeSignRegPart","allowed","transformOptionsValuesToDefaultTypes","convertOldOptionsToNewOnes","options","oldOptionsConverter","aSep","nSep","dGroup","aDec","altDec","aSign","pSign","pNeg","aSuffix","oLimits","vMax","vMin","mDec","eDec","scaleDecimal","aStor","mRound","aPad","nBracket","wEmpty","lZero","aForm","sNumber","anDefault","unSetOnSubmit","outputType","debug","runOnce","caretFix","option","getInitialSettings","extend","tagData","NaN","arabicNumbers","returnANumber","parseDecimalCharacter","parseThousandSeparator","charCodeAt","resultAsNumber","eventName","detail","window","CustomEvent","bubbles","cancelable","createEvent","initCustomEvent","dispatchEvent","setReal","pos","left","right","_getLeftAndRightPartA","_getLeftAndRightPartAroundTheSelection","_getLeftAndRightPartA2","stripZeros","newValue","parts","_normalizeParts","_checkIfInRangeWithOv","_checkIfInRangeWithOv2","testValue","_setCaretPosition","currencySymbolLen","hasNeg","valueLen","signPosition","_getSignPosition","oldParts","_getLeftAndRightPartA3","_getLeftAndRightPartA4","_setValueParts","ctrlKey","metaKey","_checkPaste","_selectOnlyNumbers","_expandSelectionOnSign","_defaultSelectAll","negLen","suffixTextLen","_ref","_ref2","_getUnformattedLeftAn3","_getUnformattedLeftAndRightPartAroundTheSelection","_getUnformattedLeftAn4","_getUnformattedLeftAn","_getUnformattedLeftAn2","_processCharacterDele","_processCharacterDeletionIfTrailingNegativeSign","_processCharacterDele2","_getUnformattedLeftAn5","_getUnformattedLeftAn6","eventNumber","_this","leftLength","_getUnformattedLeftAn7","_getUnformattedLeftAn8","_leftLength$split","_leftLength$split2","subParts","leftAr","shift","signParts","escapeChr","escapedParts","miniParts","leftReg","newLeft","input","methods","init","addEventListener","destroy","removeData","off","wipe","set","_checkIfInRangeWithOv5","_checkIfInRangeWithOv6","attemptedValue","hasBeenRounded","tempDecimal","onOff","unSet","reSet","eq","getLocalized","getNumber","getFormatted","getString","getArray","getSettings","fn","method","_len","args","_key","defaults","lang","valueString","_checkIfInRangeWithOv7","_checkIfInRangeWithOv8","autoStrip","autoUnformat","userOptions","shouldExtendDefaultOptions","testPositiveInteger","testNumericalCharacters","testFloatOrIntegerAndPossibleNegativeSign","testPositiveFloatOrInteger","vMinAndVMaxMaximumDecimalPlaces","autoValidate","isValid","params","evt","Event","AutoNumeric","comma","dot","normalSpace","thinSpace","narrowNoBreakSpace","noBreakSpace","noSeparator","apostrophe","arabicThousandsSeparator","dotAbove","withSeparator","default","middleDot","arabicDecimalSeparator","decimalSeparatorKeySymbol","none","currencySign","austral","australCentavo","baht","cedi","cent","colon","cruzeiro","dollar","dong","drachma","lepton","dram","european","euro","florin","franc","guarani","hryvnia","kip","att","lira","liraOld","lari","mark","pfennig","mill","naira","peseta","peso","pound","riel","ruble","rupee","rupeeOld","shekel","shekelAlt","taka","tenge","togrog","won","yen","prefix","suffix","show","hide","ceiling","ignore","doNotOverride","save","doNotSave","clamp","truncate","halfUpSymmetric","halfUpAsymmetric","halfDownSymmetric","halfDownAsymmetric","halfEvenBankersRounding","upRoundAwayFromZero","downRoundTowardZero","toCeilingTowardPositiveInfinity","toFloorTowardNegativeInfinity","toNearest05","upToNext05","downToNext05","padding","noPadding","parentheses","brackets","chevrons","curlyBraces","press","always","zero","allow","deny","keep","format","doNotFormat","selectNumbersOnly","selectAll","unformat","keepCurrentValue","number","negativeDot","negativeComma","dotNegative","commaNegative","cancellable","notCancellable","modifyValue","doNothing","progressive","fail","unFormat"],"mappings":"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","file":"autoNumeric.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\n\tvar jQuery = __webpack_require__(1);\n\tvar $ = __webpack_require__(1);\n\t(function() {\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t *               autoNumeric.js\r\n\t *\r\n\t * @version      3.0.0-beta.2\r\n\t * @date         2017-02-03 UTC 03:00\r\n\t *\r\n\t * @author       Bob Knothe\r\n\t * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\r\n\t *               cf. AUTHORS.md.\r\n\t * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n\t * @since        2009-08-09\r\n\t *\r\n\t * @summary      autoNumeric is a library that provides live as-you-type\r\n\t *               formatting for international numbers and currencies.\r\n\t *\r\n\t *               Note : Some functions are borrowed from big.js\r\n\t * @link         https://github.com/MikeMcl/big.js/\r\n\t *\r\n\t * Please report any bugs to https://github.com/BobKnothe/autoNumeric\r\n\t *\r\n\t * @license      Released under the MIT License\r\n\t * @link         http://www.opensource.org/licenses/mit-license.php\r\n\t *\r\n\t * Permission is hereby granted, free of charge, to any person\r\n\t * obtaining a copy of this software and associated documentation\r\n\t * files (the \"Software\"), to deal in the Software without\r\n\t * restriction, including without limitation the rights to use,\r\n\t * copy, modify, merge, publish, distribute, sub license, and/or sell\r\n\t * copies of the Software, and to permit persons to whom the\r\n\t * Software is furnished to do so, subject to the following\r\n\t * conditions:\r\n\t *\r\n\t * The above copyright notice and this permission notice shall be\r\n\t * included in all copies or substantial portions of the Software.\r\n\t *\r\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n\t * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n\t * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n\t * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n\t * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n\t * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n\t * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n\t * OTHER DEALINGS IN THE SOFTWARE.\r\n\t */\n\t\n\t/* global module, require, define */\n\t\n\t// Functions names for ES6 exports\n\tvar autoFormat = void 0;\n\tvar autoUnFormat = void 0;\n\tvar getDefaultConfig = void 0;\n\tvar getLanguages = void 0;\n\tvar validate = void 0;\n\tvar areSettingsValid = void 0;\n\t\n\t// AutoNumeric default settings\n\t/**\r\n\t * List of allowed tag on which autoNumeric can be used.\r\n\t */\n\tvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\t\n\t/**\r\n\t * Defaults options are public - these can be overridden by the following method:\r\n\t * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" \">`)\r\n\t * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' ' });`)\r\n\t * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n\t */\n\tvar defaultSettings = {\n\t    /* Allowed thousand grouping separator characters :\r\n\t     * ','      // Comma\r\n\t     * '.'      // Dot\r\n\t     * ' '      // Normal space\r\n\t     * '\\u2009' // Thin-space\r\n\t     * '\\u202f' // Narrow no-break space\r\n\t     * '\\u00a0' // No-break space\r\n\t     * ''       // No separator\r\n\t     * \"'\"      // Apostrophe\r\n\t     * ''      // Arabic thousands separator\r\n\t     * ''      // Dot above\r\n\t     * Deprecated older option name : aSep\r\n\t     */\n\t    digitGroupSeparator: ',',\n\t\n\t    /* Remove the thousand separator on focus, currency symbol and suffix on focus\r\n\t     * example if the input value \"$ 1,999.88 suffix\"\r\n\t     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n\t     * Deprecated older option name : nSep\r\n\t     */\n\t    noSeparatorOnFocus: false,\n\t\n\t    /* Digital grouping for the thousand separator used in Format\r\n\t     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\r\n\t     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n\t     * digitalGroupSpacing: \"3\", results in 999,999,999 default\r\n\t     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n\t     * Deprecated older option name : dGroup\r\n\t     */\n\t    digitalGroupSpacing: '3',\n\t\n\t    /* Allowed decimal separator characters :\r\n\t     * ',' : Comma\r\n\t     * '.' : Dot\r\n\t     * '' : Middle-dot\r\n\t     * '' : Arabic decimal separator\r\n\t     * '' : Decimal separator key symbol\r\n\t     * Deprecated older option name : aDec\r\n\t     */\n\t    decimalCharacter: '.',\n\t\n\t    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\r\n\t     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\r\n\t     * a period 'full stop' as the decimal characters (France or Spain for instance).\r\n\t     * Deprecated older option name : altDec\r\n\t     */\n\t    decimalCharacterAlternative: null,\n\t\n\t    /* currencySymbol = allowed currency symbol\r\n\t     * Must be in quotes currencySymbol: \"$\"\r\n\t     * space to the right of the currency symbol currencySymbol: '$ '\r\n\t     * space to the left of the currency symbol currencySymbol: ' $'\r\n\t     * Deprecated older option name : aSign\r\n\t     */\n\t    currencySymbol: '',\n\t\n\t    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\r\n\t     * for prefix currencySymbolPlacement: \"p\" (default)\r\n\t     * for suffix currencySymbolPlacement: \"s\"\r\n\t     * Deprecated older option name : pSign\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n\t    currencySymbolPlacement: 'p',\n\t\n\t    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\r\n\t     * -1,234.56  => default no options required\r\n\t     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\r\n\t     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n\t     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n\t     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\r\n\t     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\r\n\t     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\r\n\t     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\r\n\t     * Deprecated older option name : pNeg\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n\t    negativePositiveSignPlacement: null,\n\t\n\t    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\r\n\t     * By default, this positive sign is not shown.\r\n\t     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\r\n\t     */\n\t    showPositiveSign: false,\n\t\n\t    /* Additional suffix\r\n\t     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\r\n\t     * Numeric characters and negative sign not allowed'\r\n\t     * Deprecated older option name : aSuffix\r\n\t     */\n\t    suffixText: '',\n\t\n\t    /* Override min max limits\r\n\t     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\r\n\t     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\r\n\t     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\r\n\t     * Deprecated older option name : oLimits\r\n\t     */\n\t    overrideMinMaxLimits: null,\n\t\n\t    /* Maximum possible value\r\n\t     * value must be enclosed in quotes and use the period for the decimal point\r\n\t     * value must be larger than minimumValue\r\n\t     * Deprecated older option name : vMax\r\n\t     */\n\t    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\t\n\t    /* Minimum possible value\r\n\t     * value must be enclosed in quotes and use the period for the decimal point\r\n\t     * value must be smaller than maximumValue\r\n\t     * Deprecated older option name : vMin\r\n\t     */\n\t    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\t\n\t    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\r\n\t     * Deprecated older option name : mDec\r\n\t     */\n\t    decimalPlacesOverride: null,\n\t\n\t    /* Expanded decimal places visible when input has focus - example:\r\n\t     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n\t     * the \"get\" method returns the extended decimal places\r\n\t     * Deprecated older option name : eDec\r\n\t     */\n\t    decimalPlacesShownOnFocus: null,\n\t\n\t    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\r\n\t     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\r\n\t     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n\t     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\r\n\t     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n\t     */\n\t\n\t    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n\t     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n\t     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n\t     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n\t     */\n\t    scaleDivisor: null,\n\t\n\t    /*\r\n\t     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n\t     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n\t     * Deprecated older option name : scaleDecimal\r\n\t     */\n\t    scaleDecimalPlaces: null,\n\t\n\t    /*\r\n\t     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n\t     * This is optional too.\r\n\t     */\n\t    scaleSymbol: null,\n\t\n\t    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\r\n\t     * if ie 6 or 7 the value will be saved as a session cookie\r\n\t     * Deprecated older option name : aStor\r\n\t     */\n\t    saveValueToSessionStorage: false,\n\t\n\t    /*\r\n\t     * Manage how autoNumeric react when the user tries to paste an invalid number.\r\n\t     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\r\n\t     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\r\n\t     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\r\n\t     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\r\n\t     *                The non-pasted numbers are dropped and therefore not used at all.\r\n\t     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\r\n\t     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\r\n\t     *\r\n\t     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\r\n\t     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\r\n\t     *          Only the first number will be used (here '123').\r\n\t     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\r\n\t     */\n\t    //TODO Shouldn't we use `truncate` as the default value?\n\t    onInvalidPaste: 'error',\n\t\n\t    /* method used for rounding\r\n\t     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\r\n\t     * roundingMethod: \"A\", Round-Half-Up Asymmetric\r\n\t     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\r\n\t     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n\t     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n\t     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\r\n\t     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n\t     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n\t     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n\t     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n\t     * roundingMethod: \"U05\" Rounds up to next .05\r\n\t     * roundingMethod: \"D05\" Rounds down to next .05\r\n\t     * Deprecated older option name : mRound\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\n\t    //TODO Add an `an.roundingMethod` object that enum those options clearly\n\t    roundingMethod: 'S',\n\t\n\t    /* Allow padding the decimal places with zeros\r\n\t     * allowDecimalPadding: true - always Pad decimals with zeros\r\n\t     * allowDecimalPadding: false - does not pad with zeros.\r\n\t     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\r\n\t     *\r\n\t     * thanks to Jonas Johansson for the suggestion\r\n\t     * Deprecated older option name : aPad\r\n\t     */\n\t    allowDecimalPadding: true,\n\t\n\t    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n\t     * Those brackets are visible only when the field does NOT have the focus.\r\n\t     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n\t     * This option can be of the following values :\r\n\t     * null, // This is the default value, which deactivate this feature\r\n\t     * '(,)',\r\n\t     * '[,]',\r\n\t     * '<,>' or\r\n\t     * '{,}'\r\n\t     * Deprecated older option name : nBracket\r\n\t     */\n\t    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\n\t    negativeBracketsTypeOnBlur: null,\n\t\n\t    /* Displayed on empty string \"\"\r\n\t     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\r\n\t     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\r\n\t     * emptyInputBehavior: \"always\" - always displays the currency sign only\r\n\t     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n\t     * Deprecated older option name : wEmpty\r\n\t     */\n\t    emptyInputBehavior: 'focus',\n\t\n\t    /* Controls leading zero behavior\r\n\t     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n\t     * leadingZero: \"deny\", - allows only one leading zero on values less than one\r\n\t     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n\t     * Deprecated older option name : lZero\r\n\t     */\n\t    leadingZero: 'deny',\n\t\n\t    /* Determine if the default value will be formatted on initialization.\r\n\t     * true = automatically formats the default value on initialization\r\n\t     * false = will not format the default value on initialization\r\n\t     * Deprecated older option name : aForm\r\n\t     */\n\t    formatOnPageLoad: true,\n\t\n\t    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\r\n\t     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\r\n\t     * Deprecated older option name : sNumber\r\n\t     */\n\t    selectNumberOnly: false,\n\t\n\t    /* Helper option for ASP.NET postback\r\n\t     * should be the value of the unformatted default value\r\n\t     * examples:\r\n\t     * no default value=\"\" {defaultValueOverride: \"\"}\r\n\t     * value=1234.56 {defaultValueOverride: '1234.56'}\r\n\t     * Deprecated older option name : anDefault\r\n\t     */\n\t    defaultValueOverride: null,\n\t\n\t    /* Removes formatting on submit event\r\n\t     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n\t     * review the 'unSet' method for other formats\r\n\t     * Deprecated older option name : unSetOnSubmit\r\n\t     */\n\t    unformatOnSubmit: false,\n\t\n\t    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n\t     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n\t     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n\t     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n\t     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n\t     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n\t     * Deprecated older option name : outputType\r\n\t     */\n\t    outputFormat: null,\n\t\n\t    /* Allow the user to 'cancel' and undo the changes he made to the given autonumeric-managed element, by pressing the 'Escape' key.\r\n\t     * Whenever the user 'validate' the input (either by hitting 'Enter', or blurring the element), the new value is saved for subsequent 'cancellation'.\r\n\t     *\r\n\t     * The process :\r\n\t     *   - save the input value on focus\r\n\t     *   - if the user change the input value, and hit `Escape`, then the initial value saved on focus is set back\r\n\t     *   - on the other hand if the user either have used `Enter` to validate (`Enter` throws a change event) his entries, or if the input value has been changed by another script in the mean time, then we save the new input value\r\n\t     *   - on a successful 'cancel', select the whole value (while respecting the `selectNumberOnly` option)\r\n\t     *   - bonus; if the value has not changed, hitting 'Esc' just select all the input value (while respecting the `selectNumberOnly` option)\r\n\t     */\n\t    isCancellable: true,\n\t\n\t    /* Allow the user to increment or decrement the element value with the mouse wheel.\r\n\t     * The wheel behavior can by modified by the `wheelStep` option.\r\n\t     * This `wheelStep` options can be used in two ways, either by setting :\r\n\t     * - a 'fixed' step value (`wheelStep : 1000`), or\r\n\t     * - the 'progressive' string (`wheelStep : 'progressive'`), which will then activate a special mode where the step is automatically calculated based on the element value size.\r\n\t     *\r\n\t     * Note :\r\n\t     * A special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\r\n\t     * You can use the 'Shift' modifier key while using the mouse wheel in order to temporarily disable the increment/decrement feature (useful on small screen where some badly configured inputs could use all the available space).\r\n\t     */\n\t    modifyValueOnWheel: true,\n\t\n\t    /* That option is linked to the `modifyValueOnWheel` one and will only be used if the latter is set to `true`.\r\n\t     * This option will modify the wheel behavior and can be used in two ways, either by setting :\r\n\t     * - a 'fixed' step value (a positive float or integer number `1000`), or\r\n\t     * - the `'progressive'` string.\r\n\t     *\r\n\t     * The 'fixed' mode always increment/decrement the element value by that amount, while respecting the `minimumValue` and `maximumValue` settings.\r\n\t     * The 'progressive' mode will increment/decrement the element value based on its current value. The bigger the number, the bigger the step, and vice versa.\r\n\t     */\n\t    wheelStep: 'progressive',\n\t\n\t    /* Defines if warnings should be shown\r\n\t     * Error handling function\r\n\t     * true => all warning are shown\r\n\t     * false => no warnings are shown, only the thrown errors\r\n\t     * Deprecated older option name : debug\r\n\t     */\n\t    showWarnings: true,\n\t\n\t    /*\r\n\t     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\r\n\t     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\r\n\t     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\r\n\t     */\n\t    failOnUnknownOption: false\n\t};\n\t\n\t/**\r\n\t * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n\t * //TODO Replace every call to this object with a call to `keyName`\r\n\t * @deprecated\r\n\t */\n\tvar keyCode = {\n\t    Backspace: 8,\n\t    Tab: 9,\n\t    Enter: 13,\n\t    Shift: 16,\n\t    Ctrl: 17,\n\t    Alt: 18,\n\t    PauseBreak: 19,\n\t    CapsLock: 20,\n\t    Esc: 27,\n\t    Space: 32,\n\t    PageUp: 33,\n\t    PageDown: 34,\n\t    End: 35,\n\t    Home: 36,\n\t    LeftArrow: 37,\n\t    UpArrow: 38,\n\t    RightArrow: 39,\n\t    DownArrow: 40,\n\t    Insert: 45,\n\t    Delete: 46,\n\t    num0: 48,\n\t    num1: 49,\n\t    num2: 50,\n\t    num3: 51,\n\t    num4: 52,\n\t    num5: 53,\n\t    num6: 54,\n\t    num7: 55,\n\t    num8: 56,\n\t    num9: 57,\n\t    a: 65,\n\t    b: 66,\n\t    c: 67,\n\t    d: 68,\n\t    e: 69,\n\t    f: 70,\n\t    g: 71,\n\t    h: 72,\n\t    i: 73,\n\t    j: 74,\n\t    k: 75,\n\t    l: 76,\n\t    m: 77,\n\t    n: 78,\n\t    o: 79,\n\t    p: 80,\n\t    q: 81,\n\t    r: 82,\n\t    s: 83,\n\t    t: 84,\n\t    u: 85,\n\t    v: 86,\n\t    w: 87,\n\t    x: 88,\n\t    y: 89,\n\t    z: 90,\n\t    Windows: 91,\n\t    RightClick: 93,\n\t    numpad0: 96,\n\t    numpad1: 97,\n\t    numpad2: 98,\n\t    numpad3: 99,\n\t    numpad4: 100,\n\t    numpad5: 101,\n\t    numpad6: 102,\n\t    numpad7: 103,\n\t    numpad8: 104,\n\t    numpad9: 105,\n\t    MultiplyNumpad: 106,\n\t    PlusNumpad: 107,\n\t    MinusNumpad: 109,\n\t    DotNumpad: 110,\n\t    SlashNumpad: 111,\n\t    F1: 112,\n\t    F2: 113,\n\t    F3: 114,\n\t    F4: 115,\n\t    F5: 116,\n\t    F6: 117,\n\t    F7: 118,\n\t    F8: 119,\n\t    F9: 120,\n\t    F10: 121,\n\t    F11: 122,\n\t    F12: 123,\n\t    NumLock: 144,\n\t    ScrollLock: 145,\n\t    MyComputer: 182,\n\t    MyCalculator: 183,\n\t    Semicolon: 186,\n\t    Equal: 187,\n\t    Comma: 188,\n\t    Hyphen: 189,\n\t    Dot: 190,\n\t    Slash: 191,\n\t    Backquote: 192,\n\t    LeftBracket: 219,\n\t    Backslash: 220,\n\t    RightBracket: 221,\n\t    Quote: 222,\n\t    Command: 224\n\t};\n\t\n\t/**\r\n\t * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\r\n\t * Those names are listed here :\r\n\t * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n\t */\n\tvar keyName = {\n\t    // Special values\n\t    Unidentified: 'Unidentified',\n\t\n\t    // Modifier keys\n\t    Alt: 'Alt',\n\t    AltGr: 'AltGraph',\n\t    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n\t    Ctrl: 'Control',\n\t    Fn: 'Fn',\n\t    FnLock: 'FnLock',\n\t    Hyper: 'Hyper', // 'OS' under Firefox\n\t    Meta: 'Meta', // The Windows, Command or  key // 'OS' under Firefox and IE9\n\t    Windows: 'Meta', // This is a non-official key name\n\t    Command: 'Meta', // This is a non-official key name\n\t    NumLock: 'NumLock',\n\t    ScrollLock: 'ScrollLock',\n\t    Shift: 'Shift',\n\t    Super: 'Super', // 'OS' under Firefox\n\t    Symbol: 'Symbol',\n\t    SymbolLock: 'SymbolLock',\n\t\n\t    // Whitespace keys\n\t    Enter: 'Enter',\n\t    Tab: 'Tab',\n\t    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\t\n\t    // Navigation keys\n\t    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n\t    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n\t    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n\t    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n\t    End: 'End',\n\t    Home: 'Home',\n\t    PageDown: 'PageDown',\n\t    PageUp: 'PageUp',\n\t\n\t    // Editing keys\n\t    Backspace: 'Backspace',\n\t    Clear: 'Clear',\n\t    Copy: 'Copy',\n\t    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n\t    Cut: 'Cut',\n\t    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n\t    EraseEof: 'EraseEof',\n\t    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n\t    Insert: 'Insert',\n\t    Paste: 'Paste',\n\t    Redo: 'Redo',\n\t    Undo: 'Undo',\n\t\n\t    // UI keys\n\t    Accept: 'Accept',\n\t    Again: 'Again',\n\t    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n\t    Cancel: 'Cancel',\n\t    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n\t    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n\t    Execute: 'Execute',\n\t    Find: 'Find',\n\t    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n\t    Help: 'Help',\n\t    Pause: 'Pause',\n\t    Play: 'Play',\n\t    Props: 'Props',\n\t    Select: 'Select',\n\t    ZoomIn: 'ZoomIn',\n\t    ZoomOut: 'ZoomOut',\n\t\n\t    // Device keys\n\t    BrightnessDown: 'BrightnessDown',\n\t    BrightnessUp: 'BrightnessUp',\n\t    Eject: 'Eject',\n\t    LogOff: 'LogOff',\n\t    Power: 'Power',\n\t    PowerOff: 'PowerOff',\n\t    PrintScreen: 'PrintScreen',\n\t    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n\t    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n\t    WakeUp: 'WakeUp',\n\t\n\t    // IME and composition keys\n\t    Compose: 'Compose',\n\t    Dead: 'Dead',\n\t\n\t    // Function keys\n\t    F1: 'F1',\n\t    F2: 'F2',\n\t    F3: 'F3',\n\t    F4: 'F4',\n\t    F5: 'F5',\n\t    F6: 'F6',\n\t    F7: 'F7',\n\t    F8: 'F8',\n\t    F9: 'F9',\n\t    F10: 'F10',\n\t    F11: 'F11',\n\t    F12: 'F12',\n\t\n\t    // Document keys\n\t    Print: 'Print',\n\t\n\t    // 'Normal' keys\n\t    num0: '0',\n\t    num1: '1',\n\t    num2: '2',\n\t    num3: '3',\n\t    num4: '4',\n\t    num5: '5',\n\t    num6: '6',\n\t    num7: '7',\n\t    num8: '8',\n\t    num9: '9',\n\t    numpad0: '0',\n\t    numpad1: '1',\n\t    numpad2: '2',\n\t    numpad3: '3',\n\t    numpad4: '4',\n\t    numpad5: '5',\n\t    numpad6: '6',\n\t    numpad7: '7',\n\t    numpad8: '8',\n\t    numpad9: '9',\n\t    a: 'a',\n\t    b: 'b',\n\t    c: 'c',\n\t    d: 'd',\n\t    e: 'e',\n\t    f: 'f',\n\t    g: 'g',\n\t    h: 'h',\n\t    i: 'i',\n\t    j: 'j',\n\t    k: 'k',\n\t    l: 'l',\n\t    m: 'm',\n\t    n: 'n',\n\t    o: 'o',\n\t    p: 'p',\n\t    q: 'q',\n\t    r: 'r',\n\t    s: 's',\n\t    t: 't',\n\t    u: 'u',\n\t    v: 'v',\n\t    w: 'w',\n\t    x: 'x',\n\t    y: 'y',\n\t    z: 'z',\n\t    MultiplyNumpad: '*',\n\t    PlusNumpad: '+',\n\t    MinusNumpad: '-',\n\t    DotNumpad: '.',\n\t    SlashNumpad: '/',\n\t    Semicolon: ';',\n\t    Equal: '=',\n\t    Comma: ',',\n\t    Hyphen: '-',\n\t    Minus: '-',\n\t    Plus: '+',\n\t    Dot: '.',\n\t    Slash: '/',\n\t    Backquote: '`',\n\t    LeftBracket: '[',\n\t    RightBracket: ']',\n\t    Backslash: '\\\\',\n\t    Quote: \"'\"\n\t};\n\t\n\tvar defaultMinimumValue = '-999999999999.99';\n\tvar defaultMaximumValue = '999999999999.99';\n\tvar defaultRoundingMethod = 'U';\n\tvar defaultLeadingZero = 'deny';\n\tvar defaultSelectNumberOnly = true;\n\t\n\t/**\r\n\t * Predefined options for the most common languages\r\n\t */\n\tvar languageOption = {\n\t    French: { // Franais\n\t        digitGroupSeparator: '.', // or '\\u202f'\n\t        decimalCharacter: ',',\n\t        decimalCharacterAlternative: '.',\n\t        currencySymbol: '\\u202F\\u20AC',\n\t        currencySymbolPlacement: 's',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    NorthAmerican: {\n\t        digitGroupSeparator: ',',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '$',\n\t        currencySymbolPlacement: 'p',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    British: {\n\t        digitGroupSeparator: ',',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '',\n\t        currencySymbolPlacement: 'p',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    Swiss: { // Suisse\n\t        digitGroupSeparator: '\\'',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '\\u202FCHF',\n\t        currencySymbolPlacement: 's',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    },\n\t    Japanese: { // \n\t        digitGroupSeparator: ',',\n\t        decimalCharacter: '.',\n\t        currencySymbol: '',\n\t        currencySymbolPlacement: 'p',\n\t        selectNumberOnly: defaultSelectNumberOnly,\n\t        roundingMethod: defaultRoundingMethod,\n\t        leadingZero: defaultLeadingZero,\n\t        minimumValue: defaultMinimumValue,\n\t        maximumValue: defaultMaximumValue\n\t    }\n\t};\n\tlanguageOption.Spanish = languageOption.French; // Espaol (idem French)\n\tlanguageOption.Chinese = languageOption.Japanese; //  (Chinese)\n\t\n\t/**\r\n\t * UMD structure\r\n\t */\n\t(function (factory) {\n\t    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n\t        // Node/CommonJS\n\t        module.exports = factory(require('jquery'));\n\t    } else {\n\t        // Browser globals\n\t        factory(window.jQuery);\n\t    }\n\t})(function ($) {\n\t    // Helper functions\n\t\n\t    /**\r\n\t     * Return TRUE if the `value` is null\r\n\t     *\r\n\t     * @static\r\n\t     * @param {*} value The value to test\r\n\t     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\r\n\t     */\n\t    function isNull(value) {\n\t        return value === null;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the `value` is undefined\r\n\t     *\r\n\t     * @static\r\n\t     * @param {*} value The value to test\r\n\t     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\r\n\t     */\n\t    function isUndefined(value) {\n\t        return value === void 0;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the `value` is undefined, null or empty\r\n\t     *\r\n\t     * @param {*} value\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isUndefinedOrNullOrEmpty(value) {\n\t        return value === null || value === void 0 || '' === value;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given parameter is a String\r\n\t     *\r\n\t     * @param {*} str\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isString(str) {\n\t        return typeof str === 'string' || str instanceof String;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a boolean\r\n\t     *\r\n\t     * @static\r\n\t     * @param {*} value\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isBoolean(value) {\n\t        return typeof value === 'boolean';\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a string 'true' or 'false'\r\n\t     *\r\n\t     * This function accepts any cases for those strings.\r\n\t     * @param {string} value\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isTrueOrFalseString(value) {\n\t        var lowercaseValue = String(value).toLowerCase();\n\t        return lowercaseValue === 'true' || lowercaseValue === 'false';\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is an object\r\n\t     *\r\n\t     * @param {*} reference\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isObject(reference) {\n\t        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given object is empty\r\n\t     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n\t     *\r\n\t     * @param {object} obj\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isEmptyObj(obj) {\n\t        for (var prop in obj) {\n\t            if (obj.hasOwnProperty(prop)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a number (or a number written as a string).\r\n\t     *\r\n\t     * @param {*} n\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isNumber(n) {\n\t        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is an integer (and not a float).\r\n\t     *\r\n\t     * @param {*} n\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isInt(n) {\n\t        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n\t    }\n\t\n\t    /**\r\n\t     * Return the pasted text that will be used.\r\n\t     *\r\n\t     * @param {string} text\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @returns {string|void|XML|*}\r\n\t     */\n\t    function preparePastedText(text, holder) {\n\t        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE is the string `str` contains the string `needle`\r\n\t     * Note: this function does not coerce the parameters types\r\n\t     *\r\n\t     * @param {string} str\r\n\t     * @param {string} needle\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function contains(str, needle) {\n\t        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n\t            return false;\n\t        }\n\t\n\t        return str.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the `needle` is in the array\r\n\t     *\r\n\t     * @param {*} needle\r\n\t     * @param {Array} array\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isInArray(needle, array) {\n\t        if (!isArray(array) || array === [] || isUndefined(needle)) {\n\t            return false;\n\t        }\n\t\n\t        return array.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is an Array\r\n\t     *\r\n\t     * @param {*} arr\r\n\t     * @throws Error\r\n\t     * @returns {*|boolean}\r\n\t     */\n\t    function isArray(arr) {\n\t        if (Object.prototype.toString.call([]) === '[object Array]') {\n\t            // Make sure an array has a class attribute of [object Array]\n\t            // Test passed, now check if is an Array\n\t            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n\t        } else {\n\t            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n\t     *\r\n\t     * @param {string} str\r\n\t     * @returns {boolean}\r\n\t     */\n\t    // function hasDecimals(str) {\n\t    //     const [, decimalPart] = str.split('.');\n\t    //     return !isUndefined(decimalPart);\n\t    // }\n\t\n\t    /**\r\n\t     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n\t     *\r\n\t     * @param {string} str\r\n\t     * @returns {int}\r\n\t     */\n\t    function decimalPlaces(str) {\n\t        var _str$split = str.split('.'),\n\t            _str$split2 = _slicedToArray(_str$split, 2),\n\t            decimalPart = _str$split2[1];\n\t\n\t        if (!isUndefined(decimalPart)) {\n\t            return decimalPart.length;\n\t        }\n\t\n\t        return 0;\n\t    }\n\t\n\t    /**\r\n\t     * Return the code for the key used to generate the given event.\r\n\t     *\r\n\t     * @param {Event} event\r\n\t     * @returns {string|Number}\r\n\t     */\n\t    function keyCodeNumber(event) {\n\t        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n\t        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n\t    }\n\t\n\t    /**\r\n\t     * Return the character from the event key code.\r\n\t     * @example character(50) => '2'\r\n\t     *\r\n\t     * @param {Event} event\r\n\t     * @returns {string}\r\n\t     */\n\t    function character(event) {\n\t        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\n\t            return String.fromCharCode(keyCodeNumber(event));\n\t        } else {\n\t            return event.key;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\r\n\t     *\r\n\t     * @param {string} value\r\n\t     * @param {object} parsedMinValue Parsed via the `parseStr()` function\r\n\t     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n\t        var parsedValue = parseStr(value);\n\t        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given string contains a negative sign :\r\n\t     * - everywhere in the string (by default), or\r\n\t     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\r\n\t     *\r\n\t     * @param {string} numericString A number represented by a string\r\n\t     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isNegative(numericString) {\n\t        var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        //TODO Use the `negativeSignCharacter` from the settings here\n\t        if (checkEverywhere) {\n\t            return contains(numericString, '-');\n\t        }\n\t\n\t        return isNegativeStrict(numericString);\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\r\n\t     *\r\n\t     * @example isNegativeStrict('1234.56')     => false\r\n\t     * @example isNegativeStrict('1234.56-')    => false\r\n\t     * @example isNegativeStrict('-1234.56')    => true\r\n\t     * @example isNegativeStrict('-1,234.56 ') => true\r\n\t     *\r\n\t     * @param {string} numericString\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isNegativeStrict(numericString) {\n\t        //TODO Using the `negativeSignCharacter` from the settings here\n\t        return numericString.charAt(0) === '-';\n\t    }\n\t\n\t    /**\r\n\t     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 '), or is empty (' ').\r\n\t     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\r\n\t     *\r\n\t     * @param {string} numericString\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isZeroOrHasNoValue(numericString) {\n\t        return !/[1-9]/g.test(numericString);\n\t    }\n\t\n\t    /**\r\n\t     * Return the negative version of the value (represented as a string) given as a parameter.\r\n\t     *\r\n\t     * @param {string} value\r\n\t     * @returns {*}\r\n\t     */\n\t    function setRawNegativeSign(value) {\n\t        if (!isNegativeStrict(value)) {\n\t            return '-' + value;\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    /**\r\n\t     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\r\n\t     *\r\n\t     * @param {string} string\r\n\t     * @param {int} index\r\n\t     * @param {string} newCharacter\r\n\t     * @returns {string}\r\n\t     */\n\t    function replaceCharAt(string, index, newCharacter) {\n\t        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n\t    }\n\t\n\t    /**\r\n\t     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\r\n\t     *\r\n\t     * @param {string|number} value\r\n\t     * @param {object} settings\r\n\t     * @returns {number}\r\n\t     */\n\t    function clampToRangeLimits(value, settings) {\n\t        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n\t        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n\t    }\n\t\n\t    /**\r\n\t     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\r\n\t     *\r\n\t     * @param {string} formattedNumberString\r\n\t     * @param {int} caretPosition This must be a positive integer\r\n\t     * @param {string} decimalCharacter\r\n\t     * @returns {number}\r\n\t     */\n\t    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n\t        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n\t        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\t\n\t        var numberDotAndNegativeSignCount = 0;\n\t        for (var i = 0; i < caretPosition; i++) {\n\t            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n\t            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n\t                numberDotAndNegativeSignCount++;\n\t            }\n\t        }\n\t\n\t        return numberDotAndNegativeSignCount;\n\t    }\n\t\n\t    /**\r\n\t     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\r\n\t     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\r\n\t     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\r\n\t     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\r\n\t     *\r\n\t     * @example\r\n\t     * 1234567|89.01   : position 7 (rawNumberString)\r\n\t     * 123.456.7|89,01 : position 9 (formattedNumberString)\r\n\t     *\r\n\t     * @param {string} rawNumberString\r\n\t     * @param {int} caretPositionInRawValue\r\n\t     * @param {string} formattedNumberString\r\n\t     * @param {string} decimalCharacter\r\n\t     * @returns {*}\r\n\t     */\n\t    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n\t        var formattedNumberStringSize = formattedNumberString.length;\n\t        var rawNumberStringSize = rawNumberString.length;\n\t\n\t        var formattedNumberStringIndex = void 0;\n\t        var rawNumberStringIndex = 0;\n\t        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n\t            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n\t                rawNumberStringIndex++;\n\t            }\n\t        }\n\t\n\t        return formattedNumberStringIndex;\n\t    }\n\t\n\t    /**\r\n\t     * Count the number of occurrence of the given character, in the given text.\r\n\t     *\r\n\t     * @param {string} character\r\n\t     * @param {string} text\r\n\t     * @returns {number}\r\n\t     */\n\t    function countCharInText(character, text) {\n\t        var charCounter = 0;\n\t        for (var i = 0; i < text.length; i++) {\n\t            if (text[i] === character) {\n\t                charCounter++;\n\t            }\n\t        }\n\t\n\t        return charCounter;\n\t    }\n\t\n\t    /**\r\n\t     * Return the index that can be used to set the caret position.\r\n\t     * This takes into account that the position is starting at '0', not 1.\r\n\t     *\r\n\t     * @param {int} characterCount\r\n\t     * @returns {number}\r\n\t     */\n\t    function convertCharacterCountToIndexPosition(characterCount) {\n\t        return Math.max(characterCount, characterCount - 1);\n\t    }\n\t\n\t    /**\r\n\t     * Cross browser routine for getting selected range/cursor position\r\n\t     *\r\n\t     * @param {HTMLElement|EventTarget} that\r\n\t     * @returns {{}}\r\n\t     */\n\t    function getElementSelection(that) {\n\t        var position = {};\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var select = document.selection.createRange();\n\t            position.length = select.text.length;\n\t            select.moveStart('character', -that.value.length);\n\t            position.end = select.text.length;\n\t            position.start = position.end - position.length;\n\t        } else {\n\t            position.start = that.selectionStart;\n\t            position.end = that.selectionEnd;\n\t            position.length = position.end - position.start;\n\t        }\n\t\n\t        return position;\n\t    }\n\t\n\t    /**\r\n\t     * Cross browser routine for setting selected range/cursor position\r\n\t     *\r\n\t     * @param {HTMLElement|EventTarget} that\r\n\t     * @param {int} start\r\n\t     * @param {int|null} end\r\n\t     */\n\t    function setElementSelection(that, start) {\n\t        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t        if (isUndefinedOrNullOrEmpty(end)) {\n\t            end = start;\n\t        }\n\t\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var range = that.createTextRange();\n\t            range.collapse(true);\n\t            range.moveEnd('character', end);\n\t            range.moveStart('character', start);\n\t            range.select();\n\t        } else {\n\t            that.selectionStart = start;\n\t            that.selectionEnd = end;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Function that throw error messages\r\n\t     *\r\n\t     * @param {string} message\r\n\t     */\n\t    function throwError(message) {\n\t        throw new Error(message);\n\t    }\n\t\n\t    /**\r\n\t     * Function that display a warning messages, according to the debug level.\r\n\t     *\r\n\t     * @param {string} message\r\n\t     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\r\n\t     */\n\t    function warning(message) {\n\t        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        if (showWarning) {\n\t            /* eslint no-console: 0 */\n\t            console.warn('Warning: ' + message);\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Return `true` if the given event is a wheelup event\r\n\t     *\r\n\t     * @param {Event} DOMevent\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isWheelUpEvent(DOMevent) {\n\t        if (!DOMevent.deltaY) {\n\t            throwError('The event passed as a parameter is not a wheel event, ' + DOMevent.type + ' given.');\n\t        }\n\t\n\t        return DOMevent.deltaY < 0;\n\t    }\n\t\n\t    /**\r\n\t     * Return `true` if the given event is a wheeldown event\r\n\t     *\r\n\t     * @param {Event} DOMevent\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function isWheelDownEvent(DOMevent) {\n\t        if (!DOMevent.deltaY) {\n\t            throwError('The event passed as a parameter is not a wheel event, ' + DOMevent.type + ' given.');\n\t        }\n\t\n\t        return DOMevent.deltaY > 0;\n\t    }\n\t\n\t    /**\r\n\t     * Return the 'nearest rounded' value, according to the given step size.\r\n\t     * @example roundToNearest(264789, 10000)) => 260000\r\n\t     *\r\n\t     * @param {number} value\r\n\t     * @param {number} stepPlace\r\n\t     * @returns {*}\r\n\t     */\n\t    function roundToNearest(value) {\n\t        var stepPlace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\t\n\t        if (value <= 10 && value >= -10) {\n\t            return value;\n\t        }\n\t\n\t        if (0 === value) {\n\t            return 0;\n\t        }\n\t\n\t        return Math.round(value / stepPlace) * stepPlace;\n\t    }\n\t\n\t    /**\r\n\t     * Return the 'nearest rounded' value automatically by adding or subtracting the calculated offset to the initial value.\r\n\t     * This is done without having to pass a step to this function.\r\n\t     * @example                    Calculated offset\r\n\t     *           1 ->           1 (10)\r\n\t     *          14 ->          10 (10)\r\n\t     *         143 ->         140 (10)\r\n\t     *       1.278 ->       1.300 (100)\r\n\t     *      28.456 ->      28.500 (100)\r\n\t     *     276.345 ->     276.000 (1000)\r\n\t     *   4.534.061 ->   4.530.000 (10000)\r\n\t     *  66.723.844 ->  66.700.000 (100000)\r\n\t     * 257.833.411 -> 258.000.000 (1000000)\r\n\t     *\r\n\t     * @param {number} value\r\n\t     * @param {boolean} isAddition\r\n\t     * @returns {*}\r\n\t     */\n\t    function modifyAndRoundToNearestAuto(value, isAddition) {\n\t        value = parseInt(value, 10);\n\t        var lengthValue = Math.abs(value).toString().length; // Math.abs is needed here to omit the negative sign '-' in case of a negative value\n\t\n\t        var pow = void 0;\n\t        switch (lengthValue) {\n\t            // Special cases for small numbers\n\t            case 1:\n\t                pow = 0;\n\t                break;\n\t            case 2:\n\t            case 3:\n\t                pow = 1;\n\t                break;\n\t            case 4:\n\t            case 5:\n\t                pow = 2;\n\t                break;\n\t            // Default behavior\n\t            default:\n\t                pow = lengthValue - 3;\n\t        }\n\t        var offset = Math.pow(10, pow);\n\t\n\t        var result = void 0;\n\t        if (isAddition) {\n\t            result = value + offset;\n\t        } else {\n\t            result = value - offset;\n\t        }\n\t\n\t        return roundToNearest(result, Math.pow(10, pow));\n\t    }\n\t\n\t    /**\r\n\t     * Return the 'nearest rounded' value automatically by adding the calculated offset to the initial value.\r\n\t     *\r\n\t     * @param {number} value\r\n\t     * @returns {*}\r\n\t     */\n\t    function addAndRoundToNearestAuto(value) {\n\t        return modifyAndRoundToNearestAuto(value, true);\n\t    }\n\t\n\t    /**\r\n\t     * Return the 'nearest rounded' value automatically by subtracting the calculated offset to the initial value.\r\n\t     *\r\n\t     * @param {number} value\r\n\t     * @returns {*}\r\n\t     */\n\t    function subtractAndRoundToNearestAuto(value) {\n\t        return modifyAndRoundToNearestAuto(value, false);\n\t    }\n\t\n\t    // autoNumeric-specific functions\n\t\n\t    /**\r\n\t     * Run any callbacks found in the settings object.\r\n\t     * Any parameter could be a callback:\r\n\t     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n\t     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {object} settings\r\n\t     */\n\t    function runCallbacksFoundInTheSettingsObject($this, settings) {\n\t        // Loops through the settings object (option array) to find the following\n\t        $.each(settings, function (k, val) {\n\t            if (typeof val === 'function') {\n\t                settings[k] = val($this, settings, k);\n\t            } else if (typeof $this.autoNumeric[val] === 'function') {\n\t                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n\t                settings[k] = $this.autoNumeric[val]($this, settings, k);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * Determine the maximum decimal length from the minimumValue and maximumValue settings\r\n\t     *\r\n\t     * @param {string} minimumValue\r\n\t     * @param {string} maximumValue\r\n\t     * @returns {number}\r\n\t     */\n\t    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n\t        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n\t    }\n\t\n\t    /**\r\n\t     * Strip all unwanted non-number characters.\r\n\t     * This keeps the numbers, the negative sign as well as the custom decimal character.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} leftOrAll\r\n\t     * @returns {string|*}\r\n\t     */\n\t    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n\t        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n\t        //TODO Refactor this with `convertToNumericString()` if possible?\n\t        if (settings.currencySymbol !== '') {\n\t            // Remove currency sign\n\t            s = s.replace(settings.currencySymbol, '');\n\t        }\n\t        if (settings.suffixText) {\n\t            // Remove suffix\n\t            while (contains(s, settings.suffixText)) {\n\t                s = s.replace(settings.suffixText, '');\n\t            }\n\t        }\n\t\n\t        // First replace anything before digits\n\t        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\t\n\t        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && isNegative(s) && s !== '') {\n\t            settings.trailingNegative = true;\n\t        }\n\t\n\t        // Then replace anything after digits\n\t        s = s.replace(settings.skipLastAutoStrip, '$1');\n\t\n\t        // Then remove any uninteresting characters\n\t        s = s.replace(settings.allowedAutoStrip, '');\n\t        if (settings.decimalCharacterAlternative) {\n\t            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n\t        }\n\t\n\t        // Get only number string\n\t        var m = s.match(settings.numRegAutoStrip);\n\t        s = m ? [m[1], m[2], m[3]].join('') : '';\n\t\n\t        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n\t            var nSign = '';\n\t\n\t            var _s$split = s.split(settings.decimalCharacter),\n\t                _s$split2 = _slicedToArray(_s$split, 2),\n\t                integerPart = _s$split2[0],\n\t                decimalPart = _s$split2[1];\n\t\n\t            var modifiedIntegerPart = integerPart;\n\t            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n\t                nSign = settings.negativeSignCharacter;\n\t                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n\t            }\n\t\n\t            // Strip leading zero on positive value if need\n\t            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t\n\t            // Strip leading zero on negative value if need\n\t            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t\n\t            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n\t        }\n\t\n\t        if (leftOrAll && settings.leadingZero === 'deny' || !settings.hasFocus && settings.leadingZero === 'allow') {\n\t            s = s.replace(settings.stripReg, '$1$2');\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Sets or removes brackets on negative values, depending on the focus state.\r\n\t     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\r\n\t     * //TODO Use another object to keep track of internal data that are not settings\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function toggleNegativeBracket(s, settings) {\n\t        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n\t            //TODO Split the first and last bracket only once during the settings initialization\n\t            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n\t                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n\t                firstBracket = _settings$negativeBra2[0],\n\t                lastBracket = _settings$negativeBra2[1];\n\t\n\t            if (!settings.hasFocus) {\n\t                // Add brackets\n\t                s = s.replace(settings.negativeSignCharacter, '');\n\t                s = firstBracket + s + lastBracket;\n\t            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\n\t                // Remove brackets\n\t                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\n\t                s = s.replace(firstBracket, settings.negativeSignCharacter);\n\t                s = s.replace(lastBracket, '');\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\r\n\t     *\r\n\t     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\r\n\t     * Lastly, it also put the negative sign back to its normal position if needed.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {string|void|XML|*}\r\n\t     */\n\t    function convertToNumericString(s, settings) {\n\t        // Remove the currency symbol\n\t        s = s.replace(settings.currencySymbol, '');\n\t\n\t        // Remove the grouping separators (thousands separators usually)\n\t        s = s.replace(settings.digitGroupSeparator, '');\n\t\n\t        // Replace the decimal character by a dot\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace(settings.decimalCharacter, '.');\n\t        }\n\t\n\t        // Move the trailing negative sign to the right position, if any\n\t        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n\t            s = s.replace('-', '');\n\t            s = '-' + s;\n\t        }\n\t\n\t        // Convert any arabic numbers to latin ones\n\t        var temp = arabicToLatinNumbers(s, true, false, false);\n\t        if (!isNaN(temp)) {\n\t            s = temp.toString();\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n\t     * See the \"outputFormat\" option definition for more details.\r\n\t     *\r\n\t     * @param {string|null} value\r\n\t     * @param {string} locale\r\n\t     * @returns {*}\r\n\t     */\n\t    function toLocale(value, locale) {\n\t        if (isNull(locale) || locale === 'string') {\n\t            return value;\n\t        }\n\t\n\t        var result = void 0;\n\t        switch (locale) {\n\t            case 'number':\n\t                result = Number(value);\n\t                break;\n\t            case '.-':\n\t                result = isNegative(value) ? value.replace('-', '') + '-' : value;\n\t                break;\n\t            case ',':\n\t            case '-,':\n\t                result = value.replace('.', ',');\n\t                break;\n\t            case ',-':\n\t                result = value.replace('.', ',');\n\t                result = isNegative(result) ? result.replace('-', '') + '-' : result;\n\t                break;\n\t            // The default case\n\t            case '.':\n\t            case '-.':\n\t                result = value;\n\t                break;\n\t            default:\n\t                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {string}\r\n\t     */\n\t    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace(settings.decimalCharacter, '.');\n\t        }\n\t        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n\t            s = s.replace(settings.negativeSignCharacter, '-');\n\t        }\n\t        if (!s.match(/\\d/)) {\n\t            // The default value returned by `get` is not formatted with decimals\n\t            s += '0';\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Modify the negative sign and the decimal character to use those defined in the settings.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {string}\r\n\t     */\n\t    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n\t        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n\t            s = s.replace('-', settings.negativeSignCharacter);\n\t        }\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace('.', settings.decimalCharacter);\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Private function to check for empty value\r\n\t     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\r\n\t     *\r\n\t     * @param {string} inputValue\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} signOnEmpty\r\n\t     * @returns {*}\r\n\t     */\n\t    function checkEmpty(inputValue, settings, signOnEmpty) {\n\t        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n\t            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n\t                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n\t            }\n\t\n\t            return inputValue;\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\r\n\t     * Modify the input value by adding the group separators, as defined in the settings.\r\n\t     *\r\n\t     * @param {string} inputValue\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function addGroupSeparators(inputValue, settings) {\n\t        if (settings.strip) {\n\t            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n\t        }\n\t\n\t        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\n\t        if (settings.trailingNegative && !isNegative(inputValue)) {\n\t            inputValue = '-' + inputValue;\n\t        }\n\t\n\t        var empty = checkEmpty(inputValue, settings, true);\n\t        var isValueNegative = isNegative(inputValue);\n\t        var isZero = isZeroOrHasNoValue(inputValue);\n\t        if (isValueNegative) {\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        if (!isNull(empty)) {\n\t            return empty;\n\t        }\n\t\n\t        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n\t        var digitalGroup = void 0;\n\t        switch (settings.digitalGroupSpacing) {\n\t            case '2':\n\t                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n\t                break;\n\t            case '2s':\n\t                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n\t                break;\n\t            case '4':\n\t                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n\t                break;\n\t            default:\n\t                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n\t        }\n\t\n\t        // Splits the string at the decimal string\n\t\n\t        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n\t            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n\t            integerPart = _inputValue$split2[0],\n\t            decimalPart = _inputValue$split2[1];\n\t\n\t        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n\t            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\t\n\t            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\t\n\t            integerPart = _inputValue$split4[0];\n\t            decimalPart = _inputValue$split4[1];\n\t        }\n\t\n\t        if (settings.digitGroupSeparator !== '') {\n\t            // Re-inserts the thousand separator via a regular expression\n\t            while (digitalGroup.test(integerPart)) {\n\t                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n\t            }\n\t        }\n\t\n\t        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n\t            if (decimalPart.length > settings.decimalPlacesOverride) {\n\t                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n\t            }\n\t\n\t            // Joins the whole number with the decimal value\n\t            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n\t        } else {\n\t            // Otherwise if it's an integer\n\t            inputValue = integerPart;\n\t        }\n\t\n\t        settings.trailingNegative = false;\n\t\n\t        if (settings.currencySymbolPlacement === 'p') {\n\t            if (isValueNegative) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'l':\n\t                        inputValue = '' + settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n\t                        break;\n\t                    case 'r':\n\t                        inputValue = '' + settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n\t                        break;\n\t                    case 's':\n\t                        inputValue = '' + settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n\t                        settings.trailingNegative = true;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (settings.showPositiveSign && !isZero) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'l':\n\t                        inputValue = '' + settings.positiveSignCharacter + settings.currencySymbol + inputValue;\n\t                        break;\n\t                    case 'r':\n\t                        inputValue = '' + settings.currencySymbol + settings.positiveSignCharacter + inputValue;\n\t                        break;\n\t                    case 's':\n\t                        inputValue = '' + settings.currencySymbol + inputValue + settings.positiveSignCharacter;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else {\n\t                inputValue = settings.currencySymbol + inputValue;\n\t            }\n\t        }\n\t\n\t        if (settings.currencySymbolPlacement === 's') {\n\t            if (isValueNegative) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'r':\n\t                        inputValue = '' + inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n\t                        settings.trailingNegative = true;\n\t                        break;\n\t                    case 'l':\n\t                        inputValue = '' + inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n\t                        settings.trailingNegative = true;\n\t                        break;\n\t                    case 'p':\n\t                        inputValue = '' + settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (settings.showPositiveSign && !isZero) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'r':\n\t                        inputValue = '' + inputValue + settings.currencySymbol + settings.positiveSignCharacter;\n\t                        break;\n\t                    case 'l':\n\t                        inputValue = '' + inputValue + settings.positiveSignCharacter + settings.currencySymbol;\n\t                        break;\n\t                    case 'p':\n\t                        inputValue = '' + settings.positiveSignCharacter + inputValue + settings.currencySymbol;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else {\n\t                inputValue = inputValue + settings.currencySymbol;\n\t            }\n\t        }\n\t\n\t        // Removes the negative sign and places brackets\n\t        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\n\t            inputValue = toggleNegativeBracket(inputValue, settings);\n\t        }\n\t\n\t        return inputValue + settings.suffixText;\n\t    }\n\t\n\t    /**\r\n\t     * Truncate not needed zeros\r\n\t     *\r\n\t     * @param {string} roundedInputValue\r\n\t     * @param {int} temporaryDecimalPlacesOverride\r\n\t     * @returns {void|XML|string|*}\r\n\t     */\n\t    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n\t        var regex = void 0;\n\t        switch (temporaryDecimalPlacesOverride) {\n\t            case 0:\n\t                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n\t                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            case 1:\n\t                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n\t                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            default:\n\t                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n\t                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n\t        }\n\t\n\t        // If there are no decimal places, we don't need a decimal point at the end\n\t        roundedInputValue = roundedInputValue.replace(regex, '$1');\n\t        if (temporaryDecimalPlacesOverride === 0) {\n\t            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n\t        }\n\t\n\t        return roundedInputValue;\n\t    }\n\t\n\t    /**\r\n\t     * Round the input value using the rounding method defined in the settings.\r\n\t     * This function accepts multiple rounding methods. See the documentation for more details about those.\r\n\t     *\r\n\t     * Note : This is handled as text since JavaScript math function can return inaccurate values.\r\n\t     *\r\n\t     * @param {string} inputValue\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function roundValue(inputValue, settings) {\n\t        inputValue = inputValue === '' ? '0' : inputValue.toString();\n\t        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n\t            switch (settings.roundingMethod) {\n\t                case 'N05':\n\t                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n\t                    break;\n\t                case 'U05':\n\t                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n\t                    break;\n\t                default:\n\t                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n\t            }\n\t\n\t            var result = void 0;\n\t            if (!contains(inputValue, '.')) {\n\t                result = inputValue + '.00';\n\t            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n\t                result = inputValue + '0';\n\t            } else {\n\t                result = inputValue;\n\t            }\n\t            return result;\n\t        }\n\t\n\t        var ivRounded = '';\n\t        var i = 0;\n\t        var nSign = '';\n\t        var temporaryDecimalPlacesOverride = void 0;\n\t\n\t        // sets the truncate zero method\n\t        if (settings.allowDecimalPadding) {\n\t            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n\t        } else {\n\t            temporaryDecimalPlacesOverride = 0;\n\t        }\n\t\n\t        // Checks if the inputValue (input Value) is a negative value\n\t        if (isNegativeStrict(inputValue)) {\n\t            nSign = '-';\n\t\n\t            // Removes the negative sign that will be added back later if required\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n\t        if (!inputValue.match(/^\\d/)) {\n\t            inputValue = '0' + inputValue;\n\t        }\n\t\n\t        // Determines if the value is equal to zero. If it is, remove the negative sign\n\t        if (Number(inputValue) === 0) {\n\t            nSign = '';\n\t        }\n\t\n\t        // Trims leading zero's as needed\n\t        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n\t            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n\t        }\n\t\n\t        var dPos = inputValue.lastIndexOf('.');\n\t        var inputValueHasADot = dPos === -1;\n\t\n\t        // Virtual decimal position\n\t        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\t\n\t        // Checks decimal places to determine if rounding is required :\n\t        // Check if no rounding is required\n\t        var cDec = inputValue.length - 1 - vdPos;\n\t\n\t        if (cDec <= settings.decimalPlacesOverride) {\n\t            // Check if we need to pad with zeros\n\t            ivRounded = inputValue;\n\t            if (cDec < temporaryDecimalPlacesOverride) {\n\t                if (inputValueHasADot) {\n\t                    ivRounded += settings.decimalCharacter;\n\t                }\n\t\n\t                var zeros = '000000';\n\t                while (cDec < temporaryDecimalPlacesOverride) {\n\t                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n\t                    ivRounded += zeros;\n\t                    cDec += zeros.length;\n\t                }\n\t            } else if (cDec > temporaryDecimalPlacesOverride) {\n\t                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n\t            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n\t                ivRounded = ivRounded.replace(/\\.$/, '');\n\t            }\n\t\n\t            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t        }\n\t\n\t        // Rounded length of the string after rounding\n\t        var rLength = void 0;\n\t        if (inputValueHasADot) {\n\t            rLength = settings.decimalPlacesOverride - 1;\n\t        } else {\n\t            rLength = settings.decimalPlacesOverride + dPos;\n\t        }\n\t\n\t        var tRound = Number(inputValue.charAt(rLength + 1));\n\t        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n\t        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\t\n\t        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n\t        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n\t        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n\t        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n\t        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n\t        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n\t        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n\t        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n\t        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n\t        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n\t        tRound > 0 && settings.roundingMethod === 'U') {\n\t            // Round up away from zero\n\t            // Round up the last digit if required, and continue until no more 9's are found\n\t            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n\t                if (ivArray[i] !== '.') {\n\t                    ivArray[i] = +ivArray[i] + 1;\n\t                    if (ivArray[i] < 10) {\n\t                        break;\n\t                    }\n\t\n\t                    if (i > 0) {\n\t                        ivArray[i] = '0';\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Reconstruct the string, converting any 10's to 0's\n\t        ivArray = ivArray.slice(0, rLength + 1);\n\t\n\t        // Return the rounded value\n\t        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\t\n\t        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t    }\n\t\n\t    /**\r\n\t     * Truncates the decimal part of a number.\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} isPaste\r\n\t     * @returns {*}\r\n\t     */\n\t    function truncateDecimal(s, settings, isPaste) {\n\t        s = isPaste ? roundValue(s, settings) : s;\n\t\n\t        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n\t            var _s$split3 = s.split(settings.decimalCharacter),\n\t                _s$split4 = _slicedToArray(_s$split3, 2),\n\t                integerPart = _s$split4[0],\n\t                decimalPart = _s$split4[1];\n\t\n\t            // truncate decimal part to satisfying length since we would round it anyway\n\t\n\t\n\t            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n\t                if (settings.decimalPlacesOverride > 0) {\n\t                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n\t                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n\t                } else {\n\t                    s = integerPart;\n\t                }\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\r\n\t     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\r\n\t     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\r\n\t     *\r\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n\t     *\r\n\t     * @param {number|string} n A numeric value.\r\n\t     * @returns {{}}\r\n\t     */\n\t    function parseStr(n) {\n\t        var x = {}; // A Big number instance.\n\t        var e = void 0;\n\t        var i = void 0;\n\t        var nL = void 0;\n\t        var j = void 0;\n\t\n\t        // Minus zero?\n\t        if (n === 0 && 1 / n < 0) {\n\t            n = '-0';\n\t        }\n\t\n\t        // Determine sign. 1 positive, -1 negative\n\t        n = n.toString();\n\t        if (isNegativeStrict(n)) {\n\t            n = n.slice(1);\n\t            x.s = -1;\n\t        } else {\n\t            x.s = 1;\n\t        }\n\t\n\t        // Decimal point?\n\t        e = n.indexOf('.');\n\t        if (e > -1) {\n\t            n = n.replace('.', '');\n\t        }\n\t\n\t        // length of string if no decimal character\n\t        if (e < 0) {\n\t            // Integer\n\t            e = n.length;\n\t        }\n\t\n\t        // Determine leading zeros\n\t        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n\t        nL = n.length;\n\t        if (i === nL) {\n\t            // Zero\n\t            x.e = 0;\n\t            x.c = [0];\n\t        } else {\n\t            // Determine trailing zeros\n\t            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n\t                nL -= 1;\n\t            }\n\t            nL -= 1;\n\t\n\t            // Decimal location\n\t            x.e = e - i - 1;\n\t            x.c = [];\n\t\n\t            // Convert string to array of digits without leading/trailing zeros\n\t            for (e = 0; i <= nL; i += 1) {\n\t                x.c[e] = +n.charAt(i);\n\t                e += 1;\n\t            }\n\t        }\n\t\n\t        return x;\n\t    }\n\t\n\t    /**\r\n\t     * Function to test if the input value falls with the Min / Max settings.\r\n\t     * This uses the parsed strings for the above parseStr function.\r\n\t     *\r\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n\t     *\r\n\t     * @param {object} y Big number instance\r\n\t     * @param {object} x Big number instance\r\n\t     * @returns {*}\r\n\t     */\n\t    function testMinMax(y, x) {\n\t        var xc = x.c;\n\t        var yc = y.c;\n\t        var i = x.s;\n\t        var j = y.s;\n\t        var k = x.e;\n\t        var l = y.e;\n\t\n\t        // Either zero?\n\t        if (!xc[0] || !yc[0]) {\n\t            var _result = void 0;\n\t            if (!xc[0]) {\n\t                _result = !yc[0] ? 0 : -j;\n\t            } else {\n\t                _result = i;\n\t            }\n\t            return _result;\n\t        }\n\t\n\t        // Signs differ?\n\t        if (i !== j) {\n\t            return i;\n\t        }\n\t        var xNeg = i < 0;\n\t\n\t        // Compare exponents\n\t        if (k !== l) {\n\t            return k > l ^ xNeg ? 1 : -1;\n\t        }\n\t        i = -1;\n\t        k = xc.length;\n\t        l = yc.length;\n\t        j = k < l ? k : l;\n\t\n\t        // Compare digit by digit\n\t        for (i += 1; i < j; i += 1) {\n\t            if (xc[i] !== yc[i]) {\n\t                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n\t            }\n\t        }\n\t\n\t        // Compare lengths\n\t        var result = void 0;\n\t        if (k === l) {\n\t            result = 0;\n\t        } else {\n\t            result = k > l ^ xNeg ? 1 : -1;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Check that the number satisfy the format conditions\r\n\t     * and lays between settings.minimumValue and settings.maximumValue\r\n\t     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\r\n\t     *\r\n\t     * @param {string} s\r\n\t     * @param {object} settings\r\n\t     * @returns {*}\r\n\t     */\n\t    function checkIfInRangeWithOverrideOption(s, settings) {\n\t        s = s.toString();\n\t        s = s.replace(',', '.');\n\t        var minParse = parseStr(settings.minimumValue);\n\t        var maxParse = parseStr(settings.maximumValue);\n\t        var valParse = parseStr(s);\n\t\n\t        var result = void 0;\n\t        switch (settings.overrideMinMaxLimits) {\n\t            case 'floor':\n\t                result = [testMinMax(minParse, valParse) > -1, true];\n\t                break;\n\t            case 'ceiling':\n\t                result = [true, testMinMax(maxParse, valParse) < 1];\n\t                break;\n\t            case 'ignore':\n\t                result = [true, true];\n\t                break;\n\t            default:\n\t                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Thanks to Anthony & Evan C\r\n\t     *\r\n\t     * @param {Element|string} element\r\n\t     * @returns {*|jQuery|HTMLElement}\r\n\t     */\n\t    function getCurrentElement(element) {\n\t        /*\r\n\t         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\r\n\t         * for jQuery to be able to parse the selector correctly.\r\n\t         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\r\n\t         */\n\t        if (isString(element)) {\n\t            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n\t            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n\t        }\n\t\n\t        return $(element);\n\t    }\n\t\n\t    /**\r\n\t     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {object} settings\r\n\t     * @param {boolean} update\r\n\t     * @returns {*}\r\n\t     */\n\t    function getAutoNumericHolder($this, settings) {\n\t        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t        var data = $this.data('autoNumeric');\n\t        if (!data) {\n\t            data = {};\n\t            $this.data('autoNumeric', data);\n\t        }\n\t\n\t        var holder = data.holder;\n\t        if (update || isUndefined(holder) && settings) {\n\t            holder = new AutoNumericHolder($this.get(0), settings);\n\t            data.holder = holder;\n\t        }\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\r\n\t     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\r\n\t     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function keepAnOriginalSettingsCopy(settings) {\n\t        //TODO Rename the old option names to the new ones\n\t        settings.oDec = settings.decimalPlacesOverride;\n\t        settings.oPad = settings.allowDecimalPadding;\n\t        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n\t        settings.oSep = settings.digitGroupSeparator;\n\t        settings.oSign = settings.currencySymbol;\n\t        settings.oSuffix = settings.suffixText;\n\t    }\n\t\n\t    /**\r\n\t     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\r\n\t     * This is taken from Quirksmode.\r\n\t     *\r\n\t     * @param {string} name\r\n\t     * @returns {*}\r\n\t     */\n\t    function readCookie(name) {\n\t        var nameEQ = name + '=';\n\t        var ca = document.cookie.split(';');\n\t        var c = '';\n\t        for (var i = 0; i < ca.length; i += 1) {\n\t            c = ca[i];\n\t            while (c.charAt(0) === ' ') {\n\t                c = c.substring(1, c.length);\n\t            }\n\t            if (c.indexOf(nameEQ) === 0) {\n\t                return c.substring(nameEQ.length, c.length);\n\t            }\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\r\n\t     * Test if sessionStorage is supported.\r\n\t     * This is taken from Modernizr.\r\n\t     *\r\n\t     * @returns {boolean}\r\n\t     */\n\t    function storageTest() {\n\t        var mod = 'modernizr';\n\t        try {\n\t            sessionStorage.setItem(mod, mod);\n\t            sessionStorage.removeItem(mod);\n\t            return true;\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * properly formats the string to a numeric when leadingZero does not 'keep'.\r\n\t     *\r\n\t     * @param {string} value\r\n\t     * @param {object} settings\r\n\t     * @returns {string}\r\n\t     */\n\t    function cleanLeadingTrailingZeros(value, settings) {\n\t        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n\t        if (value === '') {\n\t            return '';\n\t        }\n\t\n\t        // Return '0' if the value is zero\n\t        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n\t            return '0';\n\t        }\n\t\n\t        if (settings.leadingZero !== 'keep') {\n\t            // Trim leading zero's - leaves one zero to the left of the decimal point\n\t            value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n\t\n\t            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\n\t            if (contains(value, '.')) {\n\t                // Trims trailing zeros after the decimal point\n\t                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n\t            }\n\t        }\n\t        // Strips trailing decimal point\n\t        value = value.replace(/\\.$/, '');\n\t\n\t        return value;\n\t    }\n\t\n\t    /**\r\n\t     * Remove the trailing zeros in the decimal part of a number.\r\n\t     *\r\n\t     * @param {string} numericString\r\n\t     * @returns {*}\r\n\t     */\n\t    function trimPaddedZerosFromDecimalPlaces(numericString) {\n\t        var _numericString$split = numericString.split('.'),\n\t            _numericString$split2 = _slicedToArray(_numericString$split, 2),\n\t            integerPart = _numericString$split2[0],\n\t            decimalPart = _numericString$split2[1];\n\t\n\t        if (isUndefinedOrNullOrEmpty(decimalPart)) {\n\t            return integerPart;\n\t        }\n\t\n\t        var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\t\n\t        var result = void 0;\n\t        if (trimmedDecimalPart === '') {\n\t            result = integerPart;\n\t        } else {\n\t            result = integerPart + '.' + trimmedDecimalPart;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\r\n\t     *\r\n\t     * @param {Element|EventTarget} element\r\n\t     * @param {object} settings\r\n\t     * @param {string} action\r\n\t     * @returns {*}\r\n\t     */\n\t    function saveValueToPersistentStorage(element, settings, action) {\n\t        if (settings.saveValueToSessionStorage) {\n\t            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n\t            var date = void 0;\n\t            var expires = void 0;\n\t\n\t            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n\t            if (storageTest() === false) {\n\t                switch (action) {\n\t                    case 'set':\n\t                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n\t                        break;\n\t                    case 'wipe':\n\t                        date = new Date();\n\t                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n\t                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n\t                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n\t                        break;\n\t                    case 'get':\n\t                        return readCookie(storedName);\n\t                }\n\t            } else {\n\t                switch (action) {\n\t                    case 'set':\n\t                        sessionStorage.setItem(storedName, settings.rawValue);\n\t                        break;\n\t                    case 'wipe':\n\t                        sessionStorage.removeItem(storedName);\n\t                        break;\n\t                    case 'get':\n\t                        return sessionStorage.getItem(storedName);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Holder object for field properties\r\n\t     */\n\t\n\t    var AutoNumericHolder = function () {\n\t        /**\r\n\t         * Class constructor\r\n\t         *\r\n\t         * @param {HTMLElement} that - A reference to the current DOM element\r\n\t         * @param {object} settings\r\n\t         */\n\t        function AutoNumericHolder(that, settings) {\n\t            _classCallCheck(this, AutoNumericHolder);\n\t\n\t            this.settings = settings;\n\t            this.that = that;\n\t            this.$that = $(that);\n\t            this.formatted = false;\n\t            this.settingsClone = settings;\n\t            this.value = that.value;\n\t            // Note: This variable is needed and not a duplicate of `initialValueOnKeydown` nor `valueOnFocus` since it serves a different purpose and has a different lifecycle\n\t            this.savedCancellableValue = null;\n\t        }\n\t\n\t        /**\r\n\t         * Update the value and the selection values inside the AutoNumericHolder object.\r\n\t         * This keeps tracks of the input value, as well as the current selection.\r\n\t         * This also resets the 'processed' and 'formatted' state.\r\n\t         *\r\n\t         * Note : Those two can change between the keydown, keypress and keyup events, that's why\r\n\t         *        this function is called on each event handler.\r\n\t         *\r\n\t         * @private\r\n\t         */\n\t\n\t\n\t        _createClass(AutoNumericHolder, [{\n\t            key: '_updateAutoNumericHolderProperties',\n\t            value: function _updateAutoNumericHolderProperties() {\n\t                this.value = this.that.value;\n\t                this.selection = getElementSelection(this.that);\n\t                this.processed = false;\n\t                this.formatted = false;\n\t            }\n\t\n\t            /**\r\n\t             * Update the keycode of the key that triggered the given event.\r\n\t             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\r\n\t             *\r\n\t             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\r\n\t             * e.key describe the key name used to trigger the event.\r\n\t             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\r\n\t             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n\t             * The key list is described here\r\n\t             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n\t             *\r\n\t             * @param {Event} e\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_updateAutoNumericHolderEventKeycode',\n\t            value: function _updateAutoNumericHolderEventKeycode(e) {\n\t                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n\t                this.eventKeyCode = keyCodeNumber(e);\n\t            }\n\t\n\t            /**\r\n\t             * Save the unformatted element value.\r\n\t             * This is used in the 'cancellable' feature where the element value is saved on focus and input validation, to be used if the user wants to cancel his modifications by hitting the 'Escape' key.\r\n\t             *\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_saveCancellableValue',\n\t            value: function _saveCancellableValue() {\n\t                this.savedCancellableValue = this.settings.rawValue;\n\t            }\n\t\n\t            /**\r\n\t             * Set the text selection inside the input with the given start and end position.\r\n\t             *\r\n\t             * @param {int} start\r\n\t             * @param {int} end\r\n\t             * @param {undefined|boolean} setReal\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_setSelection',\n\t            value: function _setSelection(start, end, setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean)\n\t                start = Math.max(start, 0);\n\t                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n\t                this.selection = {\n\t                    start: start,\n\t                    end: end,\n\t                    length: end - start\n\t                };\n\t\n\t                if (isUndefined(setReal) || setReal) {\n\t                    setElementSelection(this.that, start, end);\n\t                }\n\t            }\n\t\n\t            /**\r\n\t             * Set the caret position inside the input at the given position.\r\n\t             *\r\n\t             * @param {int} pos\r\n\t             * @param {undefined|boolean} setReal\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_setCaretPosition',\n\t            value: function _setCaretPosition(pos, setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean)\n\t                this._setSelection(pos, pos, setReal);\n\t            }\n\t\n\t            /**\r\n\t             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n\t             * Those parts are left 'untouched', ie. formatted by autoNumeric.\r\n\t             *\r\n\t             * @returns {[string, string]} The parts on the left and right of the caret or selection\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_getLeftAndRightPartAroundTheSelection',\n\t            value: function _getLeftAndRightPartAroundTheSelection() {\n\t                var value = this.value;\n\t                var left = value.substring(0, this.selection.start);\n\t                var right = value.substring(this.selection.end, value.length);\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n\t             * Those parts are unformatted (stripped) of any non-numbers characters.\r\n\t             *\r\n\t             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n\t            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n\t                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n\t                    left = _getLeftAndRightPartA2[0],\n\t                    right = _getLeftAndRightPartA2[1];\n\t\n\t                if (left === '' && right === '') {\n\t                    settingsClone.trailingNegative = false;\n\t                }\n\t                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\t                var stripZeros = true;\n\t                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n\t                    stripZeros = false;\n\t                }\n\t                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n\t                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\t\n\t                if (settingsClone.trailingNegative && !isNegative(left)) {\n\t                    left = '-' + left;\n\t                    right = right === '-' ? '' : right;\n\t                    settingsClone.trailingNegative = false;\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Strip parts from excess characters and leading zeros.\r\n\t             *\r\n\t             * @param {string} left\r\n\t             * @param {string} right\r\n\t             * @returns {[*,*]}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_normalizeParts',\n\t            value: function _normalizeParts(left, right) {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\t                var stripZeros = true;\n\t                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n\t                    stripZeros = false;\n\t                }\n\t                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\t\n\t                // If right is not empty and first character is not decimalCharacter\n\t                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\t\n\t                // Prevents multiple leading zeros from being entered\n\t                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n\t                    left = left.substring(0, left.length - 1);\n\t                }\n\t\n\t                if (settingsClone.trailingNegative && !isNegative(left)) {\n\t                    left = '-' + left;\n\t                    settingsClone.trailingNegative = false;\n\t                }\n\t\n\t                // Insert zero if has leading dot\n\t                this.newValue = left + right;\n\t                if (settingsClone.decimalCharacter) {\n\t                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n\t                    if (m) {\n\t                        left = left.replace(m[1], m[1] + '0');\n\t                        this.newValue = left + right;\n\t                    }\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\r\n\t             *\r\n\t             * @param {string} left\r\n\t             * @param {string} right\r\n\t             * @param {boolean} isPaste\r\n\t             * @returns {boolean}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_setValueParts',\n\t            value: function _setValueParts(left, right) {\n\t                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t                var settingsClone = this.settingsClone;\n\t                var parts = this._normalizeParts(left, right);\n\t\n\t                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n\t                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n\t                    minTest = _checkIfInRangeWithOv2[0],\n\t                    maxTest = _checkIfInRangeWithOv2[1];\n\t\n\t                var position = parts[0].length;\n\t                this.newValue = parts.join('');\n\t\n\t                if (minTest && maxTest) {\n\t                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n\t                    //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n\t                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n\t                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n\t                        settingsClone.rawValue = settingsClone.emptyInputBehavior === 'zero' ? '0' : '';\n\t                    } else {\n\t                        settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\n\t                    }\n\t\n\t                    if (position > this.newValue.length) {\n\t                        position = this.newValue.length;\n\t                    }\n\t\n\t                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n\t                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n\t                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n\t                        if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\n\t                            position = 1;\n\t                        } else {\n\t                            position = 0;\n\t                        }\n\t                    }\n\t\n\t                    this.value = this.newValue;\n\t                    this._setCaretPosition(position, false);\n\t\n\t                    return true;\n\t                }\n\t\n\t                if (!minTest) {\n\t                    this.$that.trigger('autoNumeric:minExceeded');\n\t                } else if (!maxTest) {\n\t                    this.$that.trigger('autoNumeric:maxExceeded');\n\t                }\n\t\n\t                return false;\n\t            }\n\t\n\t            /**\r\n\t             * Helper function for `_expandSelectionOnSign()`.\r\n\t             *\r\n\t             * @returns {*} Sign position of a formatted value\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_getSignPosition',\n\t            value: function _getSignPosition() {\n\t                var settingsClone = this.settingsClone;\n\t                var currencySymbol = settingsClone.currencySymbol;\n\t                var that = this.that;\n\t\n\t                if (currencySymbol) {\n\t                    var currencySymbolLen = currencySymbol.length;\n\t                    if (settingsClone.currencySymbolPlacement === 'p') {\n\t                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n\t                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n\t                    }\n\t                    var valueLen = that.value.length;\n\t                    return [valueLen - currencySymbolLen, valueLen];\n\t                }\n\t\n\t                return [1000, -1];\n\t            }\n\t\n\t            /**\r\n\t             * Expands selection to cover whole sign\r\n\t             * Prevents partial deletion/copying/overwriting of a sign\r\n\t             *\r\n\t             * @param {undefined|boolean} setReal\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_expandSelectionOnSign',\n\t            value: function _expandSelectionOnSign(setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean only)\n\t                //TODO Use array destructuring here to set signPosition to more explicit variables\n\t                var signPosition = this._getSignPosition();\n\t                var selection = this.selection;\n\t\n\t                // If selection catches something except sign and catches only space from sign\n\t                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n\t                    // Then select without empty space\n\t                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n\t                        if (selection.start < signPosition[0]) {\n\t                            this._setSelection(selection.start, signPosition[0], setReal);\n\t                        } else {\n\t                            this._setSelection(signPosition[1], selection.end, setReal);\n\t                        }\n\t                    } else {\n\t                        // Else select with whole sign\n\t                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n\t                    }\n\t                }\n\t            }\n\t\n\t            /**\r\n\t             * Try to strip pasted value to digits\r\n\t             */\n\t\n\t        }, {\n\t            key: '_checkPaste',\n\t            value: function _checkPaste() {\n\t                if (!isUndefined(this.valuePartsBeforePaste)) {\n\t                    var oldParts = this.valuePartsBeforePaste;\n\t\n\t                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n\t                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n\t                        left = _getLeftAndRightPartA4[0],\n\t                        right = _getLeftAndRightPartA4[1];\n\t\n\t                    // Try to strip the pasted value first\n\t\n\t\n\t                    delete this.valuePartsBeforePaste;\n\t\n\t                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n\t                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n\t                        this.value = oldParts.join('');\n\t                        this._setCaretPosition(oldParts[0].length, false);\n\t                    }\n\t                }\n\t            }\n\t\n\t            /**\r\n\t             * Process pasting, cursor moving and skipping of not interesting keys.\r\n\t             * If this function returns TRUE, then further processing is not performed.\r\n\t             *\r\n\t             * @param {Event} e\r\n\t             * @returns {boolean}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_skipAlways',\n\t            value: function _skipAlways(e) {\n\t                // Catch the ctrl up on ctrl-v\n\t                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n\t                    //TODO Move this test inside the `onKeyup` handler\n\t                    this._checkPaste();\n\t                    return false;\n\t                }\n\t\n\t                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n\t                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n\t                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n\t                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n\t                    return true;\n\t                }\n\t\n\t                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n\t                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n\t                    if (this.settings.selectNumberOnly) {\n\t                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n\t                        e.preventDefault();\n\t                        this._selectOnlyNumbers();\n\t                    }\n\t\n\t                    return true;\n\t                }\n\t\n\t                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n\t                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n\t                    if (e.type === 'keydown') {\n\t                        this._expandSelectionOnSign();\n\t                    }\n\t\n\t                    // Try to prevent wrong paste\n\t                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n\t                        if (e.type === 'keydown' || e.type === 'keypress') {\n\t                            if (isUndefined(this.valuePartsBeforePaste)) {\n\t                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n\t                            }\n\t                        } else {\n\t                            this._checkPaste();\n\t                        }\n\t                    }\n\t\n\t                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n\t                }\n\t\n\t                if (e.ctrlKey || e.metaKey) {\n\t                    return true;\n\t                }\n\t\n\t                // Jump over thousand separator\n\t                //TODO Move this test inside the `onKeydown` handler\n\t                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n\t                    if (e.type === 'keydown' && !e.shiftKey) {\n\t                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n\t                            this._setCaretPosition(this.selection.start - 1);\n\t                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n\t                            this._setCaretPosition(this.selection.start + 1);\n\t                        }\n\t                    }\n\t                    return true;\n\t                }\n\t\n\t                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n\t            }\n\t\n\t            /**\r\n\t             * Select the whole element content, based on the `selectNumberOnly` option.\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_select',\n\t            value: function _select() {\n\t                if (this.settings.selectNumberOnly) {\n\t                    this._selectOnlyNumbers();\n\t                } else {\n\t                    this._defaultSelectAll();\n\t                }\n\t            }\n\t\n\t            /**\r\n\t             * Select the whole element content (including the currency symbol).\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_defaultSelectAll',\n\t            value: function _defaultSelectAll() {\n\t                setElementSelection(this.that, 0, this.that.value.length);\n\t            }\n\t\n\t            /**\r\n\t             * Select only the numbers in the formatted input, leaving out the currency symbol.\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_selectOnlyNumbers',\n\t            value: function _selectOnlyNumbers() {\n\t                var valueLen = this.that.value.length;\n\t                var currencySymbolLen = this.settings.currencySymbol.length;\n\t                var negLen = !isNegative(this.that.value) ? 0 : 1;\n\t                var suffixTextLen = this.settings.suffixText.length;\n\t                var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n\t                var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\t\n\t                var start = void 0;\n\t                if (currencySymbolPlacement === 's') {\n\t                    start = 0;\n\t                } else {\n\t                    start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n\t                }\n\t\n\t                var end = void 0;\n\t                if (currencySymbolPlacement === 'p') {\n\t                    end = valueLen - suffixTextLen;\n\t                } else {\n\t                    switch (negativePositiveSignPlacement) {\n\t                        case 'l':\n\t                            end = valueLen - (suffixTextLen + currencySymbolLen);\n\t                            break;\n\t                        case 'r':\n\t                            end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n\t                            break;\n\t                        default:\n\t                            end = valueLen - (currencySymbolLen + suffixTextLen);\n\t                    }\n\t                }\n\t\n\t                setElementSelection(this.that, start, end);\n\t            }\n\t\n\t            /**\r\n\t             * Process deletion of characters when the minus sign is to the right of the numeric characters.\r\n\t             *\r\n\t             * @param {string} left The part on the left of the caret or selection\r\n\t             * @param {string} right The part on the right of the caret or selection\r\n\t             * @returns {[string, string]}\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterDeletionIfTrailingNegativeSign',\n\t            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n\t                var _ref2 = _slicedToArray(_ref, 2),\n\t                    left = _ref2[0],\n\t                    right = _ref2[1];\n\t\n\t                var settingsClone = this.settingsClone;\n\t                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n\t                        if (this.value.charAt(this.selection.start - 1) === '-') {\n\t                            left = left.substring(1);\n\t                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n\t                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t                        if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\n\t                            left = left.substring(1);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n\t                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        if (left[0] === '-') {\n\t                            right = right.substring(1);\n\t                        }\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n\t                            left = left.substring(1);\n\t                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        }\n\t                        right = right.substring(1);\n\t                    }\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\r\n\t             * Process the deletion of characters.\r\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterDeletion',\n\t            value: function _processCharacterDeletion() {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var left = void 0;\n\t                var right = void 0;\n\t\n\t                if (!this.selection.length) {\n\t                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\t\n\t                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\t\n\t                    left = _getUnformattedLeftAn2[0];\n\t                    right = _getUnformattedLeftAn2[1];\n\t\n\t                    if (left === '' && right === '') {\n\t                        settingsClone.throwInput = false;\n\t                    }\n\t\n\t                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && isNegative(this.value)) {\n\t                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\t\n\t\n\t                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\t\n\t                        left = _processCharacterDele2[0];\n\t                        right = _processCharacterDele2[1];\n\t                    } else {\n\t                        if (this.eventKeyCode === keyCode.Backspace) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        } else {\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t                    }\n\t                } else {\n\t                    this._expandSelectionOnSign(false);\n\t\n\t                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\t\n\t                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\t\n\t                    left = _getUnformattedLeftAn4[0];\n\t                    right = _getUnformattedLeftAn4[1];\n\t                }\n\t\n\t                this._setValueParts(left, right);\n\t            }\n\t\n\t            /**\r\n\t             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\r\n\t             * Returns TRUE if the keycode is allowed.\r\n\t             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\r\n\t             *\r\n\t             * @param {Event} e\r\n\t             * @returns {boolean}\r\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterInsertion',\n\t            value: function _processCharacterInsertion(e) {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n\t                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n\t                    left = _getUnformattedLeftAn6[0],\n\t                    right = _getUnformattedLeftAn6[1];\n\t\n\t                settingsClone.throwInput = true;\n\t\n\t                // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n\t                var eventCharacter = character(e);\n\t\n\t                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n\t                // Do not allow decimal character if no decimal part allowed\n\t                if (eventCharacter === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative || (eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n\t                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Do not allow decimal character before negativeSignCharacter character\n\t                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Do not allow decimal character if other decimal character present\n\t                    if (contains(left, settingsClone.decimalCharacter)) {\n\t                        return true;\n\t                    }\n\t\n\t                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n\t                        return true;\n\t                    }\n\t\n\t                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n\t                        right = right.substr(1);\n\t                    }\n\t\n\t                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // Prevent minus if not allowed\n\t                if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\n\t                    if (!settingsClone) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Caret is always after minus\n\t                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n\t                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                            left = settingsClone.negativeSignCharacter;\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t\n\t                        // Change number sign, remove part if should\n\t                        if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1, left.length);\n\t                        } else {\n\t                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n\t                        }\n\t                    } else {\n\t                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                            left = settingsClone.negativeSignCharacter;\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t\n\t                        // Change number sign, remove part if should\n\t                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n\t                            left = left.substring(1, left.length);\n\t                        } else {\n\t                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n\t                        }\n\t                    }\n\t\n\t                    this._setValueParts(left, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // If the user tries to insert digit before minus sign\n\t                var eventNumber = Number(eventCharacter);\n\t                if (eventNumber >= 0 && eventNumber <= 9) {\n\t                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                        left = settingsClone.negativeSignCharacter;\n\t                        right = right.substring(1, right.length);\n\t                    }\n\t\n\t                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\n\t                        left = settingsClone.negativeSignCharacter + left;\n\t                    }\n\t\n\t                    this._setValueParts(left + eventCharacter, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // Prevent any other character\n\t                settingsClone.throwInput = false;\n\t\n\t                return false;\n\t            }\n\t\n\t            /**\r\n\t             * Formatting of just processed value while keeping the cursor position\r\n\t             *\r\n\t             * @param {Event} e\r\n\t             * @private\r\n\t             */\n\t\n\t        }, {\n\t            key: '_formatValue',\n\t            value: function _formatValue(e) {\n\t                var _this = this;\n\t\n\t                var settingsClone = this.settingsClone;\n\t                var leftLength = this.value;\n\t\n\t                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n\t                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n\t                    left = _getUnformattedLeftAn8[0];\n\t\n\t                // No grouping separator and no currency sign\n\t\n\t\n\t                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n\t                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n\t                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n\t                        subParts = _leftLength$split2[0];\n\t\n\t                    var nSign = '';\n\t                    if (isNegative(subParts)) {\n\t                        nSign = '-';\n\t                        subParts = subParts.replace('-', '');\n\t                        left = left.replace('-', '');\n\t                    }\n\t\n\t                    // Strip leading zero on positive value if needed\n\t                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n\t                        left = left.slice(1);\n\t                    }\n\t\n\t                    // Strip leading zero on negative value if needed\n\t                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n\t                        left = left.slice(1);\n\t                    }\n\t\n\t                    left = nSign + left;\n\t                }\n\t\n\t                var value = addGroupSeparators(this.value, this.settingsClone);\n\t                var position = value.length;\n\t                if (value) {\n\t                    // Prepare regexp which searches for cursor position from unformatted left part\n\t                    var leftAr = left.split('');\n\t\n\t                    // Fixes caret position with trailing minus sign\n\t                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n\t                        leftAr.shift();\n\t\n\t                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n\t                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n\t                                leftAr.push('-');\n\t                                settingsClone.caretFix = e.type === 'keydown';\n\t                            }\n\t\n\t                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n\t                                leftAr.push('-');\n\t                                settingsClone.caretFix = e.type === 'keydown';\n\t                            }\n\t\n\t                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n\t                                (function () {\n\t                                    var signParts = settingsClone.currencySymbol.split('');\n\t                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n\t                                    var escapedParts = [];\n\t                                    $.each(signParts, function (i, miniParts) {\n\t                                        miniParts = signParts[i];\n\t                                        if (isInArray(miniParts, escapeChr)) {\n\t                                            escapedParts.push('\\\\' + miniParts);\n\t                                        } else {\n\t                                            escapedParts.push(miniParts);\n\t                                        }\n\t                                    });\n\t\n\t                                    if (_this.eventKeyCode === keyCode.Backspace) {\n\t                                        escapedParts.push('-');\n\t                                    }\n\t\n\t                                    // Pushing the escaped sign\n\t                                    leftAr.push(escapedParts.join(''));\n\t                                    settingsClone.caretFix = e.type === 'keydown';\n\t                                })();\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    for (var i = 0; i < leftAr.length; i++) {\n\t                        if (!leftAr[i].match('\\\\d')) {\n\t                            leftAr[i] = '\\\\' + leftAr[i];\n\t                        }\n\t                    }\n\t\n\t                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\t\n\t                    // Search cursor position in formatted value\n\t                    var newLeft = value.match(leftReg);\n\t                    if (newLeft) {\n\t                        position = newLeft[0].length;\n\t\n\t                        // If the positive sign is shown, calculate the caret position accordingly\n\t                        if (settingsClone.showPositiveSign) {\n\t                            if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\n\t                                position = newLeft.input.indexOf(settingsClone.currencySymbol) === 1 ? settingsClone.currencySymbol.length + 1 : 1;\n\t                            }\n\t\n\t                            if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\n\t                                position = settingsClone.currencySymbol.length + 1;\n\t                            }\n\t                        }\n\t\n\t                        // If we are just before the sign which is in prefix position\n\t                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n\t                            // Place caret after prefix sign\n\t                            //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n\t                            position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\n\t                        }\n\t                    } else {\n\t                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n\t                            // If we could not find a place for cursor and have a sign as a suffix\n\t                            // Place caret before suffix currency sign\n\t                            position -= settingsClone.currencySymbol.length;\n\t                        }\n\t\n\t                        if (settingsClone.suffixText) {\n\t                            // If we could not find a place for cursor and have a suffix\n\t                            // Place caret before suffix\n\t                            position -= settingsClone.suffixText.length;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                // Only update the value if it has changed. This prevents modifying the selection, if any.\n\t                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n\t                    this.that.value = value;\n\t                    this._setCaretPosition(position);\n\t                }\n\t\n\t                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n\t            }\n\t        }]);\n\t\n\t        return AutoNumericHolder;\n\t    }();\n\t\n\t    /**\r\n\t     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n\t     *\r\n\t     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n\t     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n\t     *\r\n\t     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n\t     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n\t     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\r\n\t     *\r\n\t     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n\t     * @param {HTMLElement} that - A reference to the current DOM element\r\n\t     * @returns {*}\r\n\t     * @private\r\n\t     */\n\t\n\t\n\t    function _getStringOrArray() {\n\t        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\t        var that = arguments[1];\n\t\n\t        var $this = getCurrentElement(that);\n\t        var formIndex = $('form').index($this);\n\t        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n\t        var aiIndex = [];\n\t\n\t        // all input index\n\t        var scIndex = [];\n\t\n\t        // successful control index\n\t        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\t\n\t        // from jQuery serialize method\n\t        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\t        // from jQuery serialize method\n\t        var rCheckableType = /^(?:checkbox|radio)$/i;\n\t        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\t\n\t        var count = 0;\n\t\n\t        // index of successful elements\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n\t                scIndex.push(count);\n\t                count++;\n\t            } else {\n\t                scIndex.push(-1);\n\t            }\n\t        });\n\t\n\t        // index of all inputs tags except checkbox\n\t        count = 0;\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n\t                aiIndex.push(count);\n\t                count++;\n\t            } else {\n\t                aiIndex.push(-1);\n\t                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n\t                    count++;\n\t                }\n\t            }\n\t        });\n\t\n\t        if (getArrayBehavior) {\n\t            var formFields = $this.serializeArray();\n\t\n\t            $.each(formFields, function (i, field) {\n\t                var scElement = scIndex.indexOf(i);\n\t\n\t                if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                    var settings = testInput.data('autoNumeric');\n\t\n\t                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                        field.value = testInput.autoNumeric('getLocalized').toString();\n\t                    }\n\t                }\n\t            });\n\t\n\t            return formFields;\n\t        } else {\n\t            var _ret2 = function () {\n\t                // getString() behavior\n\t                var formFields = $this.serialize();\n\t                var formParts = formFields.split('&');\n\t\n\t                $.each(formParts, function (i) {\n\t                    var _formParts$i$split = formParts[i].split('='),\n\t                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n\t                        inputName = _formParts$i$split2[0],\n\t                        inputValue = _formParts$i$split2[1];\n\t\n\t                    var scElement = scIndex.indexOf(i);\n\t\n\t                    // If the current element is a valid element\n\t                    if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                        var settings = testInput.data('autoNumeric');\n\t\n\t                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                            if (inputValue !== null) {\n\t                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n\t                                formParts[i] = inputName + '=' + modifiedInputValue;\n\t                            }\n\t                        }\n\t                    }\n\t                });\n\t\n\t                return {\n\t                    v: formParts.join('&')\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'focusin' and 'mouseenter' events\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onFocusInAndMouseEnter($this, holder, e) {\n\t        var settings = holder.settingsClone;\n\t\n\t        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n\t            settings.hasFocus = true;\n\t\n\t            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n\t                $this.val(toggleNegativeBracket(e.target.value, settings));\n\t            }\n\t\n\t            // clean the value to compare to rawValue\n\t            var result = stripAllNonNumberCharacters(e.target.value, settings, true);\n\t            result = convertToNumericString(result, settings);\n\t            result = cleanLeadingTrailingZeros(result, settings);\n\t            if (settings.trailingNegative) {\n\t                result = '-' + result;\n\t            }\n\t\n\t            if (settings.decimalPlacesShownOnFocus) {\n\t                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n\t                $this.autoNumeric('set', settings.rawValue);\n\t            } else if (settings.scaleDivisor) {\n\t                settings.decimalPlacesOverride = settings.oDec;\n\t                $this.autoNumeric('set', settings.rawValue);\n\t            } else if (settings.noSeparatorOnFocus) {\n\t                settings.digitGroupSeparator = '';\n\t                settings.currencySymbol = '';\n\t                settings.suffixText = '';\n\t                $this.autoNumeric('set', settings.rawValue);\n\t            } else if (result !== settings.rawValue) {\n\t                $this.autoNumeric('set', result);\n\t            }\n\t\n\t            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n\t            holder.valueOnFocus = e.target.value;\n\t            holder.lastVal = holder.valueOnFocus;\n\t            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n\t            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n\t                $this.val(onEmpty);\n\t\n\t                // If there is a currency symbol and its on the right hand side, then we place the caret accordingly on the far left side\n\t                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n\t                    setElementSelection(e.target, 0);\n\t                }\n\t            } else {\n\t                // Otherwise by default the whole input content is selected on focus (following the `selectNumberOnly` option)\n\t                //XXX Firefox <47 does not respect this selection...Oh well.\n\t                holder._select();\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for the 'focus' event\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     */\n\t    function onFocus(holder) {\n\t        if (holder.settings.isCancellable) {\n\t            // Save the current unformatted value for later use by the 'cancellable' feature\n\t            holder._saveCancellableValue();\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'keydown' events.\r\n\t     * The user just started pushing any key, hence one event is sent.\r\n\t     *\r\n\t     * Note :\r\n\t     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\r\n\t     * - keydown\r\n\t     * - keypress\r\n\t     * - input\r\n\t     * - keyup\r\n\t     *\r\n\t     * ...when inputting a modifier key (ie. 'ctrl') :\r\n\t     * - keydown\r\n\t     * - keyup\r\n\t     *\r\n\t     * If 'delete' or 'backspace' is entered, the following events are sent :\r\n\t     * - keydown\r\n\t     * - input\r\n\t     * - keyup\r\n\t     *\r\n\t     * If 'enter' is entered and the value has not changed, the following events are sent :\r\n\t     * - keydown\r\n\t     * - keypress\r\n\t     * - keyup\r\n\t     *\r\n\t     * If 'enter' is entered and the value has been changed, the following events are sent :\r\n\t     * - keydown\r\n\t     * - keypress\r\n\t     * - change\r\n\t     * - keyup\r\n\t     *\r\n\t     * When a paste is done, the following events are sent :\r\n\t     * - input (if paste is done with the mouse)\r\n\t     *\r\n\t     * - keydown (if paste is done with ctrl+v)\r\n\t     * - keydown\r\n\t     * - input\r\n\t     * - keyup\r\n\t     * - keyup\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onKeydown(holder, e) {\n\t        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n\t        holder._updateAutoNumericHolderEventKeycode(e);\n\t        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\t\n\t        if (holder.that.readOnly) {\n\t            holder.processed = true;\n\t\n\t            return;\n\t        }\n\t\n\t        if (holder.eventKeyCode === keyCode.Esc) {\n\t            //XXX The default 'Escape' key behavior differs between Firefox and Chrome, Firefox already having a built-in 'cancellable-like' feature. This is why we call `e.preventDefault()` here instead of just when `isCancellable` is set to `true`. This allow us to keep the same behavior across browsers.\n\t            e.preventDefault();\n\t\n\t            if (holder.settings.isCancellable) {\n\t                // If the user wants to cancel its modifications :\n\t                // We set back the saved value\n\t                holder.$that.autoNumeric('set', holder.savedCancellableValue);\n\t                // And we need to send an 'input' event when setting back the initial value in order to make other scripts aware of the value change...\n\t                triggerEvent('input', e.target);\n\t            }\n\t\n\t            // ..and lastly we update the caret selection, even if the option `isCancellable` is false\n\t            holder._select();\n\t        }\n\t\n\t        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n\t        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n\t            triggerEvent('change', e.target);\n\t            holder.valueOnFocus = e.target.value;\n\t\n\t            if (holder.settings.isCancellable) {\n\t                // If the user activated the 'cancellable' feature, we save the validated value when 'Enter' is hit\n\t                holder._saveCancellableValue();\n\t            }\n\t        }\n\t\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        if (holder._skipAlways(e)) {\n\t            holder.processed = true;\n\t\n\t            return;\n\t        }\n\t\n\t        // Check if the key is a delete/backspace key\n\t        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n\t            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n\t            holder.processed = true;\n\t            holder._formatValue(e);\n\t\n\t            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n\t            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                // Throw an input event when a character deletion is detected\n\t                triggerEvent('input', e.target);\n\t                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n\t            }\n\t\n\t            holder.lastVal = e.target.value;\n\t            holder.settingsClone.throwInput = true;\n\t\n\t            return;\n\t        }\n\t\n\t        holder.formatted = false; //TODO Is this line needed?\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'keypress' events.\r\n\t     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\r\n\t     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onKeypress(holder, e) {\n\t        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n\t        var eventCharacter = character(e);\n\t\n\t        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n\t        if (eventCharacter === keyName.Insert) {\n\t            return;\n\t        }\n\t\n\t        var processed = holder.processed;\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        if (holder._skipAlways(e)) {\n\t            return;\n\t        }\n\t\n\t        if (processed) {\n\t            e.preventDefault();\n\t\n\t            return;\n\t        }\n\t\n\t        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n\t        if (isCharacterInsertionAllowed) {\n\t            holder._formatValue(e);\n\t            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                // Throws input event on adding a character\n\t                triggerEvent('input', e.target);\n\t                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n\t            } else {\n\t                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) && getElementSelection(e.target).start === getElementSelection(e.target).end && getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\n\t                    var position = getElementSelection(e.target).start + 1;\n\t                    setElementSelection(e.target, position);\n\t                }\n\t                e.preventDefault();\n\t            }\n\t\n\t            holder.lastVal = e.target.value;\n\t            holder.settingsClone.throwInput = true;\n\t\n\t            return;\n\t        }\n\t\n\t        e.preventDefault();\n\t\n\t        holder.formatted = false;\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'keyup' events.\r\n\t     * The user just released any key, hence one event is sent.\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {object} settings\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onKeyup(holder, settings, e) {\n\t        if (holder.settings.isCancellable && holder.eventKeyCode === keyCode.Esc) {\n\t            // If the user wants to cancel its modifications, we drop the 'keyup' event for the Esc key\n\t            e.preventDefault();\n\t            return;\n\t        }\n\t\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        var skip = holder._skipAlways(e);\n\t        delete holder.valuePartsBeforePaste;\n\t        if (skip || e.target.value === '') {\n\t            return;\n\t        }\n\t\n\t        // Added to properly place the caret when only the currency sign is present\n\t        if (e.target.value === holder.settingsClone.currencySymbol) {\n\t            if (holder.settingsClone.currencySymbolPlacement === 's') {\n\t                setElementSelection(e.target, 0);\n\t            } else {\n\t                setElementSelection(e.target, holder.settingsClone.currencySymbol.length);\n\t            }\n\t        } else if (holder.eventKeyCode === keyCode.Tab) {\n\t            setElementSelection(e.target, 0, e.target.value.length);\n\t        }\n\t\n\t        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n\t            setElementSelection(e.target, 0);\n\t        }\n\t\n\t        // Saves the extended decimal to preserve the data when navigating away from the page\n\t        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n\t            saveValueToPersistentStorage(e.target, settings, 'set');\n\t        }\n\t\n\t        if (!holder.formatted) {\n\t            holder._formatValue(e);\n\t        }\n\t\n\t        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n\t        if (e.target.value !== holder.initialValueOnKeydown) {\n\t            triggerEvent('autoNumeric:formatted', e.target);\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'focusout' events\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onFocusOutAndMouseLeave($this, holder, e) {\n\t        if (!$this.is(':focus')) {\n\t            var value = e.target.value;\n\t            var origValue = value;\n\t            var settings = holder.settingsClone;\n\t            settings.hasFocus = false;\n\t\n\t            if (settings.saveValueToSessionStorage) {\n\t                saveValueToPersistentStorage(e.target, settings, 'set');\n\t            }\n\t\n\t            if (settings.noSeparatorOnFocus === true) {\n\t                settings.digitGroupSeparator = settings.oSep;\n\t                settings.currencySymbol = settings.oSign;\n\t                settings.suffixText = settings.oSuffix;\n\t            }\n\t\n\t            if (settings.decimalPlacesShownOnFocus !== null) {\n\t                settings.decimalPlacesOverride = settings.oDec;\n\t                settings.allowDecimalPadding = settings.oPad;\n\t                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n\t            }\n\t\n\t            value = stripAllNonNumberCharacters(value, settings, true);\n\t\n\t            if (value !== '') {\n\t                if (settings.trailingNegative && !isNegative(value)) {\n\t                    value = '-' + value;\n\t                    settings.trailingNegative = false;\n\t                }\n\t\n\t                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n\t                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n\t                    minTest = _checkIfInRangeWithOv4[0],\n\t                    maxTest = _checkIfInRangeWithOv4[1];\n\t\n\t                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n\t                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n\t                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\n\t\n\t                    if (settings.scaleDivisor) {\n\t                        value = value / settings.scaleDivisor;\n\t                        value = value.toString();\n\t                    }\n\t\n\t                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n\t                    value = roundValue(value, settings);\n\t                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n\t                } else {\n\t                    if (!minTest) {\n\t                        $this.trigger('autoNumeric:minExceeded');\n\t                    }\n\t                    if (!maxTest) {\n\t                        $this.trigger('autoNumeric:maxExceeded');\n\t                    }\n\t\n\t                    value = settings.rawValue;\n\t                }\n\t            } else {\n\t                if (settings.emptyInputBehavior === 'zero') {\n\t                    settings.rawValue = '0';\n\t                    value = roundValue('0', settings);\n\t                } else {\n\t                    settings.rawValue = '';\n\t                }\n\t            }\n\t\n\t            var groupedValue = checkEmpty(value, settings, false);\n\t            if (groupedValue === null) {\n\t                groupedValue = addGroupSeparators(value, settings);\n\t            }\n\t\n\t            if (groupedValue !== origValue) {\n\t                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n\t                $this.val(groupedValue);\n\t            }\n\t\n\t            if (groupedValue !== holder.valueOnFocus) {\n\t                $this.change();\n\t                delete holder.valueOnFocus;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'paste' event\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onPaste($this, holder, e) {\n\t        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n\t        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n\t        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n\t        e.preventDefault();\n\t\n\t        var rawPastedText = e.clipboardData.getData('text/plain');\n\t\n\t        // 0. Special case if the user has selected all the input text before pasting\n\t        var initialFormattedValue = e.target.value;\n\t        var selectionStart = e.target.selectionStart || 0;\n\t        var selectionEnd = e.target.selectionEnd || 0;\n\t        var selectionSize = selectionEnd - selectionStart;\n\t        var isAllInputTextSelected = false;\n\t\n\t        if (selectionSize === initialFormattedValue.length) {\n\t            isAllInputTextSelected = true;\n\t        }\n\t\n\t        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n\t        var isPasteNegative = isNegativeStrict(rawPastedText);\n\t        if (isPasteNegative) {\n\t            // 1a. Remove the negative sign from the pasted text\n\t            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n\t        }\n\t\n\t        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n\t        var untranslatedPastedText = preparePastedText(rawPastedText, holder);\n\t\n\t        var pastedText = void 0;\n\t        if (untranslatedPastedText === '.') {\n\t            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n\t            pastedText = '.';\n\t        } else {\n\t            // Normal case\n\t            // Allow pasting arabic numbers\n\t            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n\t        }\n\t\n\t        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n\t        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\n\t            if (holder.settings.onInvalidPaste === 'error') {\n\t                //TODO Should we send a warning instead of throwing an error?\n\t                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n\t            }\n\t\n\t            return;\n\t        }\n\t\n\t        // 4. Calculate the paste result\n\t        var caretPositionOnInitialTextAfterPasting = void 0;\n\t        var initialUnformattedNumber = void 0;\n\t        if (e.target.value === '') {\n\t            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n\t            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\n\t            initialUnformattedNumber = '';\n\t        } else {\n\t            initialUnformattedNumber = $this.autoNumeric('get');\n\t        }\n\t        var isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\n\t        var isPasteNegativeAndInitialValueIsPositive = void 0;\n\t        var result = void 0;\n\t\n\t        // If the pasted content is negative, then the result will be negative too\n\t        if (isPasteNegative && !isInitialValueNegative) {\n\t            initialUnformattedNumber = '-' + initialUnformattedNumber;\n\t            isInitialValueNegative = true;\n\t            isPasteNegativeAndInitialValueIsPositive = true;\n\t        } else {\n\t            isPasteNegativeAndInitialValueIsPositive = false;\n\t        }\n\t\n\t        var leftPartContainedADot = false;\n\t        switch (holder.settings.onInvalidPaste) {\n\t            /* 4a. Truncate paste behavior:\r\n\t             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\r\n\t             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\r\n\t             * Otherwise paste all the numbers in the clipboard.\r\n\t             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\r\n\t             *\r\n\t             * 4b. Replace paste behavior:\r\n\t             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\r\n\t             */\n\t            /* eslint no-case-declarations: 0 */\n\t            case 'truncate':\n\t            case 'replace':\n\t                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n\t                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\t\n\t                if (selectionStart !== selectionEnd) {\n\t                    // a. If there is a selection, remove the selected part, and return the left and right part\n\t                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n\t                } else {\n\t                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n\t                    result = preparePastedText(initialFormattedValue, holder);\n\t                }\n\t\n\t                // Add back the negative sign if needed\n\t                if (isInitialValueNegative) {\n\t                    result = setRawNegativeSign(result);\n\t                }\n\t\n\t                // Build the unformatted result string\n\t                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                if (isPasteNegativeAndInitialValueIsPositive) {\n\t                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n\t                    caretPositionOnInitialTextAfterPasting++;\n\t                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n\t                }\n\t\n\t                var leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n\t                var rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n\t                if (pastedText === '.') {\n\t                    if (contains(leftPart, '.')) {\n\t                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n\t                        // To do so, we keep that info in order to modify the caret position later\n\t                        leftPartContainedADot = true;\n\t                        leftPart = leftPart.replace('.', '');\n\t                    }\n\t                    rightPart = rightPart.replace('.', '');\n\t                }\n\t                // -- Here, we are good to go to continue on the same basis\n\t\n\t                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n\t                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n\t                var minParse = parseStr(holder.settings.minimumValue);\n\t                var maxParse = parseStr(holder.settings.maximumValue);\n\t                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n\t                var pastedTextIndex = 0;\n\t                var modifiedLeftPart = leftPart;\n\t\n\t                while (pastedTextIndex < pastedText.length) {\n\t                    // Modify the result with another pasted character\n\t                    modifiedLeftPart += pastedText[pastedTextIndex];\n\t                    result = modifiedLeftPart + rightPart;\n\t\n\t                    // Check the range limits\n\t                    if (!checkIfInRange(result, minParse, maxParse)) {\n\t                        // The result is out of the range limits, stop the loop here\n\t                        break;\n\t                    }\n\t\n\t                    // Save the last good known result\n\t                    lastGoodKnownResult = result;\n\t\n\t                    // Update the local variables for the next loop\n\t                    pastedTextIndex++;\n\t                }\n\t\n\t                // Update the last caret position where to insert a new number\n\t                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\t\n\t                //XXX Here we have the result for the `truncate` option\n\t                if (holder.settings.onInvalidPaste === 'truncate') {\n\t                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n\t                    result = lastGoodKnownResult;\n\t\n\t                    if (leftPartContainedADot) {\n\t                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n\t                        caretPositionOnInitialTextAfterPasting--;\n\t                    }\n\t                    break;\n\t                }\n\t                //XXX ...else we need to continue modifying the result for the 'replace' option\n\t\n\t                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n\t                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n\t                //    If you do get to the range limits, use the previous known good value within those limits.\n\t                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n\t                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n\t                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n\t                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\t\n\t                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n\t                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n\t                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n\t                        lastGoodKnownResultIndex++;\n\t                        continue;\n\t                    }\n\t\n\t                    // This replace one character at a time\n\t                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\t\n\t                    // Check the range limits\n\t                    if (!checkIfInRange(result, minParse, maxParse)) {\n\t                        // The result is out of the range limits, stop the loop here\n\t                        break;\n\t                    }\n\t\n\t                    // Save the last good known result\n\t                    lastGoodKnownResult = result;\n\t\n\t                    // Update the local variables for the next loop\n\t                    pastedTextIndex++;\n\t                    lastGoodKnownResultIndex++;\n\t                }\n\t\n\t                // Update the last caret position where to insert a new number\n\t                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\t\n\t                if (leftPartContainedADot) {\n\t                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n\t                    caretPositionOnInitialTextAfterPasting--;\n\t                }\n\t\n\t                result = lastGoodKnownResult;\n\t\n\t                break;\n\t            /* 4c. Normal paste behavior:\r\n\t             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\r\n\t             */\n\t            case 'error':\n\t            case 'ignore':\n\t            case 'clamp':\n\t            default:\n\t                // 1. Generate the unformatted result\n\t                var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n\t                var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\t\n\t                if (selectionStart !== selectionEnd) {\n\t                    // a. If there is a selection, remove the selected part, and return the left and right part\n\t                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\n\t                } else {\n\t                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n\t                    result = preparePastedText(initialFormattedValue, holder);\n\t                }\n\t\n\t                // Add back the negative sign if needed\n\t                if (isInitialValueNegative) {\n\t                    result = setRawNegativeSign(result);\n\t                }\n\t\n\t                // Build the unformatted result string\n\t                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                if (isPasteNegativeAndInitialValueIsPositive) {\n\t                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n\t                    caretPositionOnInitialTextAfterPasting++;\n\t                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n\t                }\n\t\n\t                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n\t                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n\t                if (pastedText === '.') {\n\t                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n\t                    if (contains(leftPart, '.')) {\n\t                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n\t                        // To do so, we keep that info in order to modify the caret position later\n\t                        leftPartContainedADot = true;\n\t                        leftPart = leftPart.replace('.', '');\n\t                    }\n\t                    rightPart = rightPart.replace('.', '');\n\t                }\n\t                // -- Here, we are good to go to continue on the same basis\n\t\n\t                // Generate the unformatted result\n\t                result = '' + leftPart + pastedText + rightPart;\n\t\n\t                // 2. Calculate the caret position in the unformatted value, for later use\n\t                if (selectionStart === selectionEnd) {\n\t                    // There is no selection, then the caret position is set after the pasted text\n\t                    var indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n\t                } else {\n\t                    if (isAllInputTextSelected) {\n\t                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n\t                        caretPositionOnInitialTextAfterPasting = result.length;\n\t                    } else if (rightPart === '') {\n\t                        // If the user selected from the caret position to the end of the input (on the far right)\n\t                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\n\t                    } else {\n\t                        // Normal case\n\t                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\t\n\t                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n\t                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n\t                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\n\t                    }\n\t                }\n\t\n\t                // Modify the caret position for special cases, only if the whole input has not been selected\n\t                if (!isAllInputTextSelected) {\n\t                    if (isPasteNegativeAndInitialValueIsPositive) {\n\t                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n\t                        caretPositionOnInitialTextAfterPasting++;\n\t                    }\n\t\n\t                    if (leftPartContainedADot) {\n\t                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n\t                        caretPositionOnInitialTextAfterPasting--;\n\t                    }\n\t                }\n\t        }\n\t\n\t        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n\t        if (!isNumber(result) || result === '') {\n\t            if (holder.settings.onInvalidPaste === 'error') {\n\t                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n\t                //TODO This is not DRY ; refactor with above\n\t            }\n\t            return;\n\t        }\n\t\n\t        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n\t        /*\r\n\t         * If 'error' (this is the default) :\r\n\t         *      - Normal paste behavior.\r\n\t         *      - Try to set the new value, if it fails, then throw an error in the console.\r\n\t         *      - Do not change the input value, do not change the current selection.\r\n\t         * If 'ignore' :\r\n\t         *      - Normal paste behavior.\r\n\t         *      - Try to set the new value, if it fails, do nothing more.\r\n\t         *      - Do not change the input value, do not change the current selection.\r\n\t         * If 'clamp' :\r\n\t         *      - Normal paste behavior.\r\n\t         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\r\n\t         *        paste result.\r\n\t         *      - Change the caret position to be positioned on the left hand side of the decimal character.\r\n\t         * If 'truncate' :\r\n\t         *      - Truncate paste behavior.\r\n\t         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n\t         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\r\n\t         *      - Change the caret position to be positioned after the last pasted character.\r\n\t         * If 'replace' :\r\n\t         *      - Replace paste behavior.\r\n\t         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n\t         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\r\n\t         *      - Change the caret position to be positioned after the last pasted character.\r\n\t         */\n\t        var valueHasBeenSet = false;\n\t        var valueHasBeenClamped = false;\n\t        try {\n\t            $this.autoNumeric('set', result);\n\t            valueHasBeenSet = true;\n\t        } catch (error) {\n\t            var clampedValue = void 0;\n\t            switch (holder.settings.onInvalidPaste) {\n\t                case 'clamp':\n\t                    clampedValue = clampToRangeLimits(result, holder.settings);\n\t                    try {\n\t                        $this.autoNumeric('set', clampedValue);\n\t                    } catch (error) {\n\t                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n\t                    }\n\t\n\t                    valueHasBeenClamped = true;\n\t                    valueHasBeenSet = true;\n\t                    result = clampedValue; // This is used only for setting the caret position later\n\t                    break;\n\t                case 'error':\n\t                case 'truncate':\n\t                case 'replace':\n\t                    // Throw an error message\n\t                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n\t                // falls through\n\t                case 'ignore':\n\t                // Do nothing\n\t                // falls through\n\t                default:\n\t                    return; // ...and nothing else should be changed\n\t            }\n\t        }\n\t\n\t        // 7. Then lastly, set the caret position at the right logical place\n\t        var caretPositionInFormattedNumber = void 0;\n\t        if (valueHasBeenSet) {\n\t            switch (holder.settings.onInvalidPaste) {\n\t                case 'clamp':\n\t                    if (valueHasBeenClamped) {\n\t                        if (holder.settings.currencySymbolPlacement === 's') {\n\t                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n\t                        } else {\n\t                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n\t                        }\n\t\n\t                        break;\n\t                    } // else if the value has not been clamped, the default behavior is used...\n\t                // falls through\n\t                case 'error':\n\t                case 'ignore':\n\t                case 'truncate':\n\t                case 'replace':\n\t                default:\n\t                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n\t                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n\t                    setElementSelection(e.target, caretPositionInFormattedNumber);\n\t            }\n\t        }\n\t\n\t        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n\t        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n\t            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n\t            triggerEvent('input', e.target);\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onBlur(holder, e) {\n\t        if (e.target.value !== holder.valueOnFocus) {\n\t            triggerEvent('change', e.target);\n\t            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'wheel' event\r\n\t     *\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     * @param {Event} e\r\n\t     */\n\t    function onWheel(holder, e) {\n\t        // If the user is using the 'Shift' key modifier, then we ignore the wheel event\n\t        // This special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\n\t        // If that's the case, then he can use the 'Shift' modifier key while using the mouse wheel in order to bypass the increment/decrement feature\n\t        // This is useful on small screen where some badly configured inputs could use all the available space.\n\t        if (!e.shiftKey && holder.settings.modifyValueOnWheel) {\n\t            // 0) First, save the caret position so we can set it back once the value has been changed\n\t            var selectionStart = e.target.selectionStart || 0;\n\t            var selectionEnd = e.target.selectionEnd || 0;\n\t\n\t            // 1) Get the unformatted value\n\t            var currentUnformattedValue = holder.settings.rawValue;\n\t            var result = void 0;\n\t            if (isUndefinedOrNullOrEmpty(currentUnformattedValue)) {\n\t                // If by default the input is empty, start at '0'\n\t                if (holder.settings.minimumValue > 0 || holder.settings.maximumValue < 0) {\n\t                    // or if '0' is not between min and max value, 'minimumValue' if the user does a wheelup, 'maximumValue' if the user does a wheeldown\n\t                    if (isWheelUpEvent(e)) {\n\t                        result = holder.settings.minimumValue;\n\t                    } else if (isWheelDownEvent(e)) {\n\t                        result = holder.settings.maximumValue;\n\t                    } else {\n\t                        throwError('The event is not a \\'wheel\\' event.');\n\t                    }\n\t                } else {\n\t                    result = 0;\n\t                }\n\t            } else {\n\t                result = currentUnformattedValue;\n\t            }\n\t\n\t            result = +result; // Typecast to a number needed for the following addition/subtraction\n\t\n\t            // 2) Increment/Decrement the value\n\t            // But first, choose the increment/decrement method ; fixed or progressive\n\t            if (isNumber(holder.settings.wheelStep)) {\n\t                var step = +holder.settings.wheelStep; // Typecast to a number needed for the following addition/subtraction\n\t                // Fixed method\n\t                // This is the simplest method, where a fixed offset in added/subtracted from the current value\n\t                if (isWheelUpEvent(e)) {\n\t                    // Increment\n\t                    result = result + step;\n\t                } else if (isWheelDownEvent(e)) {\n\t                    // Decrement\n\t                    result = result - step;\n\t                }\n\t            } else {\n\t                // Progressive method\n\t                // For this method, we calculate an offset that is in relation to the size of the current number (using only the integer part size).\n\t                // The bigger the number, the bigger the offset (usually the number count in the integer part minus 3, except for small numbers where a different behavior is better for the user experience).\n\t                if (isWheelUpEvent(e)) {\n\t                    // Increment\n\t                    result = addAndRoundToNearestAuto(result);\n\t                } else if (isWheelDownEvent(e)) {\n\t                    // Decrement\n\t                    result = subtractAndRoundToNearestAuto(result);\n\t                }\n\t            }\n\t\n\t            // 3) Set the new value so it gets formatted\n\t            // First clamp the result if needed\n\t            result = clampToRangeLimits(result, holder.settings);\n\t            if (result !== +currentUnformattedValue) {\n\t                // Only 'set' the value if it has changed. For instance 'set' should not happen if the user hits a limit and continue to try to go past it since we clamp the value.\n\t                holder.$that.autoNumeric('set', result);\n\t            }\n\t\n\t            //XXX Do not prevent if the value is not modified? From a UX point of view, preventing the wheel event when the user use it on top of an autoNumeric element should always be done, even if the value does not change. Perhaps that could affect other scripts relying on this event to be sent though.\n\t            e.preventDefault(); // We prevent the page to scroll while we increment/decrement the value\n\t\n\t            // 4) Finally, we set back the caret position/selection\n\t            // There is no need to take into account the fact that the number count could be different at the end of the wheel event ; it would be too complex and most of the time unreliable\n\t            holder._setSelection(selectionStart, selectionEnd);\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Handler for 'submit' events\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {AutoNumericHolder} holder\r\n\t     */\n\t    function onSubmit($this, holder) {\n\t        $this.closest('form').on('submit.autoNumeric', function () {\n\t            if (holder) {\n\t                var $settings = holder.settingsClone;\n\t\n\t                if ($settings.unformatOnSubmit) {\n\t                    $this.val($settings.rawValue);\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n\t     *\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @returns {boolean|*}\r\n\t     */\n\t    function getInputIfSupportedTagAndType($this) {\n\t        // Supported input type\n\t        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t\n\t        // Checks for non-supported input types\n\t        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n\t            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n\t        }\n\t\n\t        // Checks for non-supported tags\n\t        var currentElementTag = $this.prop('tagName').toLowerCase();\n\t        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n\t            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n\t        }\n\t\n\t        return $input;\n\t    }\n\t\n\t    /**\r\n\t     * Formats the default value on page load.\r\n\t     * This is called only if the `formatOnPageLoad` option is set to `true`.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     * @param {object} $input jQuery-selected <input> element\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     */\n\t    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n\t        var setValue = true;\n\t\n\t        if ($input) {\n\t            var currentValue = $this.val();\n\t            /*\r\n\t             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n\t             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n\t             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\r\n\t             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n\t             *\r\n\t             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\r\n\t             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n\t             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n\t             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n\t             * we should ignore `defaultValueOverride` altogether.\r\n\t             */\n\t            var unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup\n\t            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n\t                // Check if the `value` is valid or not\n\t                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\n\t                    $this.autoNumeric('set', unLocalizedCurrentValue);\n\t                    setValue = false;\n\t                } else {\n\t                    // If not, inform the developer that nothing usable has been provided\n\t                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n\t                }\n\t            } else {\n\t                /* Checks for :\r\n\t                 * - page reload from back button, and\r\n\t                 * - ASP.net form post back\r\n\t                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n\t                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n\t                 */\n\t                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue)) {\n\t                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n\t                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n\t                    }\n\t\n\t                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n\t                    if (!settings.saveValueToSessionStorage) {\n\t                        var toStrip = void 0;\n\t\n\t                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n\t                            settings.hasFocus = true;\n\t                            toStrip = toggleNegativeBracket(currentValue, settings);\n\t                        } else {\n\t                            toStrip = currentValue;\n\t                        }\n\t\n\t                        if ((settings.negativePositiveSignPlacement === 's' || settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's') && settings.negativeSignCharacter !== '' && isNegative(currentValue)) {\n\t                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\n\t                        } else {\n\t                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\n\t                        }\n\t                    }\n\t\n\t                    setValue = false;\n\t                }\n\t            }\n\t\n\t            if (currentValue === '') {\n\t                switch (settings.emptyInputBehavior) {\n\t                    case 'focus':\n\t                        setValue = false;\n\t                        break;\n\t                    case 'always':\n\t                        $this.val(settings.currencySymbol);\n\t                        setValue = false;\n\t                        break;\n\t                    case 'zero':\n\t                        $this.autoNumeric('set', '0');\n\t                        setValue = false;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (setValue && currentValue === $this.attr('value')) {\n\t                $this.autoNumeric('set', currentValue);\n\t            }\n\t        }\n\t\n\t        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n\t            if (settings.defaultValueOverride !== null) {\n\t                if (settings.defaultValueOverride === $this.text()) {\n\t                    $this.autoNumeric('set', $this.text());\n\t                }\n\t            } else {\n\t                $this.autoNumeric('set', $this.text());\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\r\n\t     *\r\n\t     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\r\n\t     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\r\n\t     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\r\n\t     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function correctNegativePositiveSignPlacementOption(settings) {\n\t        // If negativePositiveSignPlacement is already set, we do not overwrite it\n\t        if (!isNull(settings.negativePositiveSignPlacement)) {\n\t            return;\n\t        }\n\t\n\t        if (!isUndefined(settings) && isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n\t            switch (settings.currencySymbolPlacement) {\n\t                case 's':\n\t                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 \n\t                    break;\n\t                case 'p':\n\t                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\n\t                    break;\n\t                default:\n\t                //\n\t            }\n\t        } else {\n\t            // Sets the default value if `negativePositiveSignPlacement` is `null`\n\t            settings.negativePositiveSignPlacement = 'l';\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Analyze and save the minimumValue and maximumValue integer size for later uses\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function calculateVMinAndVMaxIntegerSizes(settings) {\n\t        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n\t            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n\t            maximumValueIntegerPart = _settings$maximumValu2[0];\n\t\n\t        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n\t            _ref4 = _slicedToArray(_ref3, 1),\n\t            minimumValueIntegerPart = _ref4[0];\n\t\n\t        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n\t        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\t\n\t        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n\t        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n\t    }\n\t\n\t    /**\r\n\t     * Modify `decimalPlacesOverride` as needed\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function correctDecimalPlacesOverrideOption(settings) {\n\t        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\n\t            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n\t            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n\t        } else if (isNull(settings.decimalPlacesOverride)) {\n\t            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n\t        }\n\t        settings.oDec = String(settings.decimalPlacesOverride);\n\t\n\t        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n\t        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n\t    }\n\t\n\t    /**\r\n\t     * Sets the alternative decimal separator key.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function setsAlternativeDecimalSeparatorCharacter(settings) {\n\t        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n\t            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n\t                settings.decimalCharacterAlternative = ',';\n\t            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n\t                settings.decimalCharacterAlternative = '.';\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Caches regular expressions for stripAllNonNumberCharacters\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function cachesUsualRegularExpressions(settings) {\n\t        var allNumbersReg = '[0-9]';\n\t        var noAllNumbersReg = '[^0-9]';\n\t\n\t        // Test if there is a negative character in the string\n\t        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n\t        settings.aNegRegAutoStrip = aNegReg;\n\t\n\t        var negativeSignRegPart = void 0;\n\t        if (settings.negativeSignCharacter) {\n\t            negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n\t        } else {\n\t            negativeSignRegPart = '';\n\t        }\n\t        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n\t        settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\t\n\t        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n\t        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n\t        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\t\n\t        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n\t        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n\t    }\n\t\n\t    /**\r\n\t     * Modify the user settings to make them 'exploitable' later.\r\n\t     *\r\n\t     * @param {object} settings\r\n\t     */\n\t    function transformOptionsValuesToDefaultTypes(settings) {\n\t        $.each(settings, function (key, value) {\n\t            // Convert the string 'true' and 'false' to real Boolean\n\t            if (value === 'true' || value === 'false') {\n\t                settings[key] = value === 'true';\n\t            }\n\t\n\t            // Convert numbers in options to strings\n\t            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n\t            if (typeof value === 'number' && key !== 'aScale') {\n\t                settings[key] = value.toString();\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * Convert the old settings options name to new ones.\r\n\t     *\r\n\t     * @param {object} options\r\n\t     */\n\t    function convertOldOptionsToNewOnes(options) {\n\t        //TODO Delete this function once the old options are not used anymore\n\t        var oldOptionsConverter = {\n\t            // Old option name, with their corresponding new option\n\t            aSep: 'digitGroupSeparator',\n\t            nSep: 'noSeparatorOnFocus',\n\t            dGroup: 'digitalGroupSpacing',\n\t            aDec: 'decimalCharacter',\n\t            altDec: 'decimalCharacterAlternative',\n\t            aSign: 'currencySymbol',\n\t            pSign: 'currencySymbolPlacement',\n\t            pNeg: 'negativePositiveSignPlacement',\n\t            aSuffix: 'suffixText',\n\t            oLimits: 'overrideMinMaxLimits',\n\t            vMax: 'maximumValue',\n\t            vMin: 'minimumValue',\n\t            mDec: 'decimalPlacesOverride',\n\t            eDec: 'decimalPlacesShownOnFocus',\n\t            scaleDecimal: 'scaleDecimalPlaces',\n\t            aStor: 'saveValueToSessionStorage',\n\t            mRound: 'roundingMethod',\n\t            aPad: 'allowDecimalPadding',\n\t            nBracket: 'negativeBracketsTypeOnBlur',\n\t            wEmpty: 'emptyInputBehavior',\n\t            lZero: 'leadingZero',\n\t            aForm: 'formatOnPageLoad',\n\t            sNumber: 'selectNumberOnly',\n\t            anDefault: 'defaultValueOverride',\n\t            unSetOnSubmit: 'unformatOnSubmit',\n\t            outputType: 'outputFormat',\n\t            debug: 'showWarnings',\n\t            // Current options :\n\t            digitGroupSeparator: true,\n\t            noSeparatorOnFocus: true,\n\t            digitalGroupSpacing: true,\n\t            decimalCharacter: true,\n\t            decimalCharacterAlternative: true,\n\t            currencySymbol: true,\n\t            currencySymbolPlacement: true,\n\t            negativePositiveSignPlacement: true,\n\t            showPositiveSign: true,\n\t            suffixText: true,\n\t            overrideMinMaxLimits: true,\n\t            maximumValue: true,\n\t            minimumValue: true,\n\t            decimalPlacesOverride: true,\n\t            decimalPlacesShownOnFocus: true,\n\t            scaleDivisor: true,\n\t            scaleDecimalPlaces: true,\n\t            scaleSymbol: true,\n\t            saveValueToSessionStorage: true,\n\t            onInvalidPaste: true,\n\t            roundingMethod: true,\n\t            allowDecimalPadding: true,\n\t            negativeBracketsTypeOnBlur: true,\n\t            emptyInputBehavior: true,\n\t            leadingZero: true,\n\t            formatOnPageLoad: true,\n\t            selectNumberOnly: true,\n\t            defaultValueOverride: true,\n\t            unformatOnSubmit: true,\n\t            outputFormat: true,\n\t            isCancellable: true,\n\t            modifyValueOnWheel: true,\n\t            wheelStep: true,\n\t            showWarnings: true,\n\t            failOnUnknownOption: true,\n\t            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n\t            hasFocus: true,\n\t            runOnce: true,\n\t            rawValue: true,\n\t            trailingNegative: true,\n\t            caretFix: true,\n\t            throwInput: true,\n\t            strip: true,\n\t            tagList: true,\n\t            negativeSignCharacter: true,\n\t            positiveSignCharacter: true,\n\t            mIntPos: true,\n\t            mIntNeg: true,\n\t            oDec: true,\n\t            oPad: true,\n\t            oBracket: true,\n\t            oSep: true,\n\t            oSign: true,\n\t            oSuffix: true,\n\t            aNegRegAutoStrip: true,\n\t            skipFirstAutoStrip: true,\n\t            skipLastAutoStrip: true,\n\t            allowedAutoStrip: true,\n\t            numRegAutoStrip: true,\n\t            stripReg: true,\n\t            holder: true\n\t        };\n\t\n\t        for (var option in options) {\n\t            if (options.hasOwnProperty(option)) {\n\t                if (oldOptionsConverter[option] === true) {\n\t                    // If the option is a 'new' option, we continue looping\n\t                    continue;\n\t                }\n\t\n\t                if (oldOptionsConverter.hasOwnProperty(option)) {\n\t                    // Else we have an 'old' option name\n\t                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\t\n\t                    // Then we modify the initial option object to use the new options instead of the old ones\n\t                    options[oldOptionsConverter[option]] = options[option];\n\t                    delete options[option];\n\t                } else if (options.failOnUnknownOption) {\n\t                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n\t                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n\t     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n\t     *\r\n\t     * @param {object} options\r\n\t     * @param {object} $this jQuery-selected DOM element\r\n\t     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\r\n\t     * @returns {object|null}\r\n\t     */\n\t    function getInitialSettings(options, $this) {\n\t        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n\t        var settings = $this.data('autoNumeric');\n\t\n\t        // If the user used old options, we convert them to new ones\n\t        if (update || !isNull(options)) {\n\t            convertOldOptionsToNewOnes(options);\n\t        }\n\t\n\t        if (update || isUndefined(settings)) {\n\t            if (update) {\n\t                // The settings are updated\n\t                settings = $.extend(settings, options);\n\t            } else {\n\t                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n\t                // The settings are generated for the first time\n\t                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\n\t                var tagData = $this.data();\n\t                settings = $.extend({}, defaultSettings, tagData, options, {\n\t                    hasFocus: false,\n\t                    runOnce: false,\n\t                    rawValue: '',\n\t                    trailingNegative: false,\n\t                    caretFix: false,\n\t                    throwInput: true, // Throw input event\n\t                    strip: true,\n\t                    tagList: allowedTagList\n\t                });\n\t            }\n\t\n\t            // Modify the user settings to make them 'exploitable'\n\t            transformOptionsValuesToDefaultTypes(settings);\n\t\n\t            // Improve the `negativePositiveSignPlacement` option if needed\n\t            correctNegativePositiveSignPlacementOption(settings);\n\t\n\t            // Set the negative and positive signs, as needed\n\t            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n\t            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\n\t\n\t            // Additional changes to the settings object (from the original autoCode() function)\n\t            runCallbacksFoundInTheSettingsObject($this, settings);\n\t            calculateVMinAndVMaxIntegerSizes(settings);\n\t            correctDecimalPlacesOverrideOption(settings);\n\t            setsAlternativeDecimalSeparatorCharacter(settings);\n\t            cachesUsualRegularExpressions(settings);\n\t\n\t            // Validate the settings\n\t            validate(settings, false); // Throws if necessary\n\t\n\t            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n\t            keepAnOriginalSettingsCopy(settings);\n\t\n\t            // Save our new settings\n\t            $this.data('autoNumeric', settings);\n\t\n\t            return settings;\n\t        } else {\n\t            return null;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * Convert the `value` parameter that can either be :\r\n\t     * - a real number,\r\n\t     * - a string representing a real number, or\r\n\t     * - a string representing a localized number (with specific group separators and decimal character),\r\n\t     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\r\n\t     *\r\n\t     * This function returns `NaN` if such conversion fails.\r\n\t     *\r\n\t     * @param {int|float|string} value\r\n\t     * @param {object} settings\r\n\t     * @returns {string|NaN}\r\n\t     */\n\t    function toNumericValue(value, settings) {\n\t        var result = void 0;\n\t        if (isNumber(Number(value))) {\n\t            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n\t            result = value;\n\t        } else {\n\t            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n\t            // Convert the value to a numeric string, stripping unnecessary characters in the process\n\t            result = convertToNumericString(value.toString(), settings);\n\t\n\t            // If the result is still not a numeric string, then we throw a warning\n\t            if (!isNumber(Number(result))) {\n\t                warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n\t                result = NaN;\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Methods supported by autoNumeric\r\n\t     */\n\t    var methods = {\n\t        /**\r\n\t         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\r\n\t         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\r\n\t         *\r\n\t         * @example\r\n\t         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\r\n\t         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\r\n\t         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\r\n\t         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\r\n\t         *\r\n\t         * @param {object} options\r\n\t         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\r\n\t         */\n\t        init: function init(options) {\n\t            return this.each(function () {\n\t                var $this = $(this);\n\t                var $input = getInputIfSupportedTagAndType($this);\n\t\n\t                var settings = getInitialSettings(options, $this, false);\n\t                if (isNull(settings)) {\n\t                    return this;\n\t                }\n\t\n\t                // Create the AutoNumericHolder object that store the field properties\n\t                var holder = getAutoNumericHolder($this, settings, false);\n\t\n\t                if (!settings.runOnce && settings.formatOnPageLoad) {\n\t                    formatDefaultValueOnPageLoad(settings, $input, $this);\n\t                }\n\t\n\t                settings.runOnce = true;\n\t\n\t                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n\t                if ($input) {\n\t                    this.addEventListener('focusin', function (e) {\n\t                        onFocusInAndMouseEnter($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('focus', function () {\n\t                        onFocus(holder);\n\t                    }, false);\n\t                    this.addEventListener('mouseenter', function (e) {\n\t                        onFocusInAndMouseEnter($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('blur', function (e) {\n\t                        onFocusOutAndMouseLeave($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('mouseleave', function (e) {\n\t                        onFocusOutAndMouseLeave($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('keydown', function (e) {\n\t                        onKeydown(holder, e);\n\t                    }, false);\n\t                    this.addEventListener('keypress', function (e) {\n\t                        onKeypress(holder, e);\n\t                    }, false);\n\t                    this.addEventListener('keyup', function (e) {\n\t                        onKeyup(holder, settings, e);\n\t                    }, false);\n\t                    this.addEventListener('blur', function (e) {\n\t                        onBlur(holder, e);\n\t                    }, false);\n\t                    this.addEventListener('paste', function (e) {\n\t                        onPaste($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('wheel', function (e) {\n\t                        onWheel(holder, e);\n\t                    }, false);\n\t                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to stop and remove autoNumeric for the current element.\r\n\t         * Note: this does not remove the formatting.\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\r\n\t         *\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        destroy: function destroy() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.val('');\n\t                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                    $this.removeData('autoNumeric');\n\t                    $this.off('.autoNumeric');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\r\n\t         *\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        wipe: function wipe() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.val('');\n\t                    settings.rawValue = '';\n\t                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method that updates the autoNumeric settings.\r\n\t         * It can be called multiple times if needed.\r\n\t         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\r\n\t         *\r\n\t         * @param {object} options\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        update: function update(options) {\n\t            return $(this).each(function () {\n\t                // Retrieve the current unformatted input value\n\t                var $this = getCurrentElement(this);\n\t                var strip = $this.autoNumeric('get');\n\t\n\t                // Update the settings\n\t                var settings = getInitialSettings(options, $this, true);\n\t\n\t                // Update the AutoNumericHolder object that store the field properties\n\t                getAutoNumericHolder($this, settings, true);\n\t\n\t                // Reformat the input value with the new settings\n\t                if ($this.val() !== '' || $this.text() !== '') {\n\t                    return $this.autoNumeric('set', strip);\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to format the value passed as a parameter.\r\n\t         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n\t         * and must contain only numbers and one decimal (period) character\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\r\n\t         *\r\n\t         * @param {*} newValue\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        set: function set(newValue) {\n\t            return $(this).each(function () {\n\t                if (newValue === null || isUndefined(newValue)) {\n\t                    return;\n\t                }\n\t\n\t                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method.');\n\t                }\n\t                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\n\t                settings.trailingNegative = false;\n\t\n\t                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t\n\t                var value = toNumericValue(newValue, settings);\n\t                if (isNaN(value)) {\n\t                    return $this.val('');\n\t                }\n\t\n\t                if (value !== '') {\n\t                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n\t                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n\t                        minTest = _checkIfInRangeWithOv6[0],\n\t                        maxTest = _checkIfInRangeWithOv6[1];\n\t                    // This test is needed by the showPositiveSign option\n\t\n\t\n\t                    var isZero = isZeroOrHasNoValue(value);\n\t                    if (isZero) {\n\t                        value = '0';\n\t                    }\n\t\n\t                    if (minTest && maxTest) {\n\t                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                            // to ensure rounding does not happen twice\n\t                            var hasBeenRounded = false;\n\t\n\t                            // rounds the the extended decimal places\n\t                            if (settings.decimalPlacesShownOnFocus) {\n\t                                var tempDecimal = settings.decimalPlacesOverride;\n\t                                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n\t                                value = roundValue(value, settings);\n\t                                hasBeenRounded = true;\n\t                                settings.decimalPlacesOverride = tempDecimal;\n\t                            }\n\t\n\t                            if (settings.scaleDivisor && !settings.onOff) {\n\t                                value = toNumericValue(value, settings);\n\t                                value = value / settings.scaleDivisor;\n\t                                value = value.toString();\n\t                                if (settings.scaleDecimalPlaces) {\n\t                                    var _tempDecimal = settings.decimalPlacesOverride;\n\t                                    settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n\t                                    value = roundValue(value, settings);\n\t                                    hasBeenRounded = true;\n\t                                    settings.decimalPlacesOverride = _tempDecimal;\n\t                                }\n\t                            }\n\t\n\t                            // Rounds if this has not been done already\n\t                            if (!hasBeenRounded) {\n\t                                value = roundValue(value, settings);\n\t                            }\n\t\n\t                            // Stores rawValue including the decimalPlacesShownOnFocus\n\t                            settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\t\n\t                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n\t                            value = addGroupSeparators(value, settings);\n\t                        }\n\t\n\t                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n\t                            saveValueToPersistentStorage($this[0], settings, 'set');\n\t                        }\n\t                    } else {\n\t                        settings.rawValue = '';\n\t                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                        var attemptedValue = value;\n\t                        value = '';\n\t                        if (!minTest) {\n\t                            $this.trigger('autoNumeric:minExceeded');\n\t                        }\n\t\n\t                        if (!maxTest) {\n\t                            $this.trigger('autoNumeric:maxExceeded');\n\t                        }\n\t\n\t                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\t\n\t                        return $this.val('');\n\t                    }\n\t                } else {\n\t                    return $this.val('');\n\t                }\n\t\n\t                if (!settings.hasFocus && settings.scaleSymbol) {\n\t                    value = value + settings.scaleSymbol;\n\t                }\n\t\n\t                if ($input) {\n\t                    return $this.val(value);\n\t                }\n\t\n\t                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                    return $this.text(value);\n\t                }\n\t\n\t                return false;\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to un-format inputs.\r\n\t         * This is handy to use right before form submission.\r\n\t         *\r\n\t         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\r\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\r\n\t         * Please see option \"outputFormat\" for more details\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric('unSet');\r\n\t         *\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        unSet: function unSet() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    settings.hasFocus = true;\n\t                    $this.val($this.autoNumeric('getLocalized'));\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Method to re-format inputs.\r\n\t         * This is handy to use right after form submission.\r\n\t         *\r\n\t         * This is called after the 'unSet' method to reformat the input\r\n\t         *\r\n\t         * @example $(someSelector).autoNumeric('reSet');\r\n\t         *\r\n\t         * @returns {*|jQuery}\r\n\t         */\n\t        reSet: function reSet() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.autoNumeric('set', $this.val());\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Return the unformatted value as a string.\r\n\t         *\r\n\t         * @usage $(someSelector).autoNumeric('get');\r\n\t         *\r\n\t         * @returns {string}\r\n\t         */\n\t        get: function get() {\n\t            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n\t            var $this = getCurrentElement(this);\n\t            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t            var settings = $this.data('autoNumeric');\n\t            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n\t            }\n\t\n\t            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n\t            var value = '';\n\t            if ($input) {\n\t                value = $this.eq(0).val();\n\t            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                value = $this.eq(0).text();\n\t            } else {\n\t                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n\t            }\n\t\n\t            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n\t                value = settings.rawValue;\n\t            } else {\n\t                // Test if the value is negative\n\t                var isValueNegative = isNegative(value);\n\t\n\t                if (!/\\d/.test(value) && settings.emptyInputBehavior === 'focus') {\n\t                    return '';\n\t                }\n\t\n\t                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n\t                    settings.hasFocus = true;\n\t                    value = toggleNegativeBracket(value, settings);\n\t                }\n\t\n\t                if (settings.runOnce || settings.formatOnPageLoad === false) {\n\t                    // Strips trailing negative symbol\n\t                    value = stripAllNonNumberCharacters(value, settings, true);\n\t                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\n\t                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\t\n\t                    // Places the negative symbol in front of the trailing negative\n\t                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\n\t                        value = '-' + value;\n\t                    }\n\t                }\n\t\n\t                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\n\t                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n\t                }\n\t            }\n\t\n\t            // Always return a numeric string\n\t            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\n\t            return trimPaddedZerosFromDecimalPlaces(value);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\r\n\t         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n\t         * - a plain number (if the setting 'number' is used).\r\n\t         *\r\n\t         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n\t         * Check the \"outputFormat\" option definition for more details.\r\n\t         *\r\n\t         * @usage $(someSelector).autoNumeric('getLocalized');\r\n\t         *\r\n\t         * @returns {*}\r\n\t         */\n\t        getLocalized: function getLocalized() {\n\t            var $this = getCurrentElement(this);\n\t            var value = $this.autoNumeric('get');\n\t            var settings = $this.data('autoNumeric');\n\t\n\t            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n\t                value = '0';\n\t            }\n\t\n\t            return toLocale(value, settings.outputFormat);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Return the input unformatted value as a real Javascript number.\r\n\t         *\r\n\t         * @usage $(someSelector).autoNumeric('getNumber');\r\n\t         *\r\n\t         * @returns {number}\r\n\t         */\n\t        getNumber: function getNumber() {\n\t            var $this = getCurrentElement(this);\n\t            var value = $this.autoNumeric('get');\n\t\n\t            return toLocale(value, 'number');\n\t        },\n\t\n\t\n\t        /**\r\n\t         * Return the current formatted value of the autoNumeric element.\r\n\t         * @usage aNInput.autoNumeric('getFormatted'))\r\n\t         *\r\n\t         * @returns {string}\r\n\t         */\n\t        getFormatted: function getFormatted() {\n\t            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n\t            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n\t                throwError('Unable to get the formatted string from the element.');\n\t            }\n\t\n\t            return this[0].value;\n\t        },\n\t\n\t\n\t        /**\r\n\t         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n\t         *\r\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n\t         *\r\n\t         * @returns {string}\r\n\t         */\n\t        getString: function getString() {\n\t            return _getStringOrArray(false, this);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n\t         *\r\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n\t         *\r\n\t         * @returns {{}|[]}\r\n\t         */\n\t        getArray: function getArray() {\n\t            return _getStringOrArray(true, this);\n\t        },\n\t\n\t\n\t        /**\r\n\t         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\r\n\t         *\r\n\t         * @example\r\n\t         * $(someSelector).autoNumeric('getSettings');\r\n\t         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\r\n\t         *\r\n\t         * @returns {object}\r\n\t         */\n\t        getSettings: function getSettings() {\n\t            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n\t            return this.data('autoNumeric');\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n\t     * It initialize autoNumeric on the given element.\r\n\t     *\r\n\t     * @param {string} method The method name (ie. 'set', 'get', etc.)\r\n\t     * @param {*} args\r\n\t     * @returns {*}\r\n\t     */\n\t    $.fn.autoNumeric = function (method) {\n\t        if (methods[method]) {\n\t            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                args[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            return methods[method].apply(this, args);\n\t        }\n\t\n\t        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n\t            // The options have been passed directly, without using a named method\n\t            return methods.init.apply(this, [method]);\n\t        }\n\t\n\t        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n\t    };\n\t\n\t    /**\r\n\t     * Return the default autoNumeric settings.\r\n\t     *\r\n\t     * @returns {object}\r\n\t     */\n\t    getDefaultConfig = function getDefaultConfig() {\n\t        return defaultSettings;\n\t    };\n\t\n\t    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\t\n\t    /**\r\n\t     * Return all the predefined language options in one object.\r\n\t     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\r\n\t     *\r\n\t     * @returns {object}\r\n\t     */\n\t    getLanguages = function getLanguages() {\n\t        return languageOption;\n\t    };\n\t\n\t    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\n\t\n\t    /**\r\n\t     * Public function that allows formatting without an element trigger.\r\n\t     *\r\n\t     * @param {number|string} value A number, or a string that represent a javascript number\r\n\t     * @param {object|null} options\r\n\t     * @returns {*}\r\n\t     */\n\t    autoFormat = function autoFormat(value) {\n\t        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        if (!isString(value) && !isNumber(value)) {\n\t            throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n\t        }\n\t\n\t        // Initiate a very basic settings object\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        if (value < 0) {\n\t            settings.negativeSignCharacter = '-';\n\t        }\n\t\n\t        if (isNull(settings.decimalPlacesOverride)) {\n\t            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n\t        }\n\t\n\t        // Check the validity of the `value` parameter\n\t        // Convert the value to a numeric string, stripping unnecessary characters in the process\n\t        var valueString = toNumericValue(value, settings);\n\t        if (isNaN(valueString)) {\n\t            throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n\t        }\n\t\n\t        // Basic tests to check if the given valueString is valid\n\t\n\t        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n\t            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n\t            minTest = _checkIfInRangeWithOv8[0],\n\t            maxTest = _checkIfInRangeWithOv8[1];\n\t\n\t        if (!minTest || !maxTest) {\n\t            // Throw a custom event\n\t            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n\t            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\t        }\n\t\n\t        // Everything is ok, proceed to rounding, formatting and grouping\n\t        valueString = roundValue(valueString, settings);\n\t        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n\t        valueString = addGroupSeparators(valueString, settings);\n\t\n\t        return valueString;\n\t    };\n\t\n\t    $.fn.autoFormat = autoFormat; // The jQuery export\n\t\n\t    /**\r\n\t     * Public function that allows unformatting without an element.\r\n\t     *\r\n\t     * @param {string|number} value\r\n\t     * @param {object} options\r\n\t     * @returns {*}\r\n\t     */\n\t    autoUnFormat = function autoUnFormat(value, options) {\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n\t        if (isNumber(value)) {\n\t            return Number(value);\n\t        }\n\t\n\t        if (isArray(value) || isObject(value)) {\n\t            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n\t            // Check the validity of the `value` parameter\n\t            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n\t        }\n\t\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n\t        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n\t        value = value.toString();\n\t\n\t        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n\t        if (isNegative(value)) {\n\t            settings.negativeSignCharacter = '-';\n\t        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n\t            settings.negativeSignCharacter = '-';\n\t            settings.hasFocus = true;\n\t            value = toggleNegativeBracket(value, settings);\n\t        }\n\t\n\t        value = value.replace(autoStrip, '');\n\t        value = value.replace(settings.decimalCharacter, '.');\n\t        value = toLocale(value, settings.outputFormat);\n\t\n\t        return value;\n\t    };\n\t\n\t    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\t\n\t    /**\r\n\t     * Validate the given option object.\r\n\t     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n\t     *\r\n\t     * This tests if the options are not conflicting and are well formatted.\r\n\t     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n\t     *\r\n\t     * @param {*} userOptions\r\n\t     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n\t     * @throws Error\r\n\t     */\n\t    validate = function validate(userOptions) {\n\t        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n\t            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n\t        }\n\t\n\t        // If the user used old options, we convert them to new ones\n\t        if (!isNull(userOptions)) {\n\t            convertOldOptionsToNewOnes(userOptions);\n\t        }\n\t\n\t        // The user can choose if the `userOptions` has already been extended with the default options, or not\n\t        var options = void 0;\n\t        if (shouldExtendDefaultOptions) {\n\t            options = $.extend({}, defaultSettings, userOptions);\n\t        } else {\n\t            options = userOptions;\n\t        }\n\t\n\t        // First things first, we test that the `showWarnings` option is valid\n\t        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n\t            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n\t        }\n\t\n\t        // Define the regular expressions needed for the following tests\n\t        var testPositiveInteger = /^[0-9]+$/;\n\t        var testNumericalCharacters = /[0-9]+/;\n\t        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n\t        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n\t        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\t\n\t        // Then tests the options individually\n\t        if (!isInArray(options.digitGroupSeparator, [',', // Comma\n\t        '.', // Dot\n\t        ' ', // Normal space\n\t        '\\u2009', // Thin-space\n\t        '\\u202F', // Narrow no-break space\n\t        '\\xA0', // No-break space\n\t        '', // No separator\n\t        \"'\", // Apostrophe\n\t        '', // Arabic thousands separator\n\t        ''])) {\n\t            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n\t            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n\t        }\n\t\n\t        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n\t            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.decimalCharacter, [',', // Comma\n\t        '.', // Dot\n\t        '', // Middle-dot\n\t        '', // Arabic decimal separator\n\t        ''])) {\n\t            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n\t        }\n\t\n\t        // Checks if the decimal and thousand characters are the same\n\t        if (options.decimalCharacter === options.digitGroupSeparator) {\n\t            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n\t        }\n\t\n\t        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n\t            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n\t        }\n\t\n\t        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n\t            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n\t            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\n\t            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\n\t            throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n\t        }\n\t\n\t        if (!isString(options.suffixText) || options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n\t            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n\t            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n\t        }\n\t\n\t        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n\t            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n\t        }\n\t\n\t        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n\t            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n\t        }\n\t\n\t        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n\t            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n\t        }\n\t\n\t        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n\t        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n\t        ) {\n\t                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n\t            }\n\t\n\t        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n\t        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n\t        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n\t            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n\t        }\n\t\n\t        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n\t            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n\t        }\n\t\n\t        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n\t            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n\t        }\n\t\n\t        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n\t        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n\t            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n\t        }\n\t\n\t        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n\t            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n\t            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n\t            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n\t            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n\t            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n\t            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n\t            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n\t            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n\t            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n\t            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n\t            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n\t            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n\t            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n\t            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n\t            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.isCancellable) && !isBoolean(options.isCancellable)) {\n\t            throwError('The cancellable behavior option \\'isCancellable\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.isCancellable + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.modifyValueOnWheel) && !isBoolean(options.modifyValueOnWheel)) {\n\t            throwError('The increment/decrement on mouse wheel option \\'modifyValueOnWheel\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.modifyValueOnWheel + '] given.');\n\t        }\n\t\n\t        if (!(isString(options.wheelStep) || isNumber(options.wheelStep)) || options.wheelStep !== 'progressive' && !testPositiveFloatOrInteger.test(options.wheelStep) || Number(options.wheelStep) === 0) {\n\t            // We do not accept a step equal to '0'\n\t            throwError('The wheel step value option \\'wheelStep\\' is invalid ; it should either be the string \\'progressive\\', or a number or a string that represents a positive number, [' + options.wheelStep + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n\t            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n\t        }\n\t    };\n\t\n\t    $.fn.autoValidate = validate;\n\t\n\t    /**\r\n\t     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n\t     *\r\n\t     * @param {object} options\r\n\t     * @returns {boolean}\r\n\t     */\n\t    areSettingsValid = function areSettingsValid(options) {\n\t        var isValid = true;\n\t        try {\n\t            validate(options);\n\t        } catch (error) {\n\t            isValid = false;\n\t        }\n\t\n\t        return isValid;\n\t    };\n\t\n\t    /**\r\n\t     * Take an arabic number as a string and return a javascript number.\r\n\t     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\r\n\t     * This returns `NaN` is the conversion is not possible.\r\n\t     * Based on http://stackoverflow.com/a/17025392/2834898\r\n\t     *\r\n\t     * @param {string} arabicNumbers\r\n\t     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\r\n\t     * @param {boolean} parseDecimalCharacter\r\n\t     * @param {boolean} parseThousandSeparator\r\n\t     * @returns {string|number|NaN}\r\n\t     */\n\t    function arabicToLatinNumbers(arabicNumbers) {\n\t        var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t        var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t        var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t\n\t        var result = arabicNumbers.toString();\n\t        if (result === '') {\n\t            return arabicNumbers;\n\t        }\n\t\n\t        if (parseDecimalCharacter) {\n\t            result = result.replace(//, '.'); // Decimal character\n\t        }\n\t\n\t        if (parseThousandSeparator) {\n\t            result = result.replace(//g, ''); // Thousand separator\n\t        }\n\t\n\t        // Replace the numbers only\n\t        result = result.replace(/[]/g, function (d) {\n\t            return d.charCodeAt(0) - 1632;\n\t        }) // Arabic numbers\n\t        .replace(/[]/g, function (d) {\n\t            return d.charCodeAt(0) - 1776;\n\t        }); // Persian numbers\n\t\n\t        // `NaN` has precedence over the string `'NaN'`\n\t        var resultAsNumber = Number(result);\n\t        if (isNaN(resultAsNumber)) {\n\t            return resultAsNumber;\n\t        }\n\t\n\t        if (returnANumber) {\n\t            result = resultAsNumber;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\r\n\t     * Create a custom event and immediately sent it from the given element.\r\n\t     * By default, if no element is given, the event is thrown from `document`.\r\n\t     *\r\n\t     * @param {string} eventName\r\n\t     * @param {Element} element\r\n\t     * @param {object} detail\r\n\t     */\n\t    function triggerEvent(eventName) {\n\t        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n\t        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t        var event = void 0;\n\t        if (window.CustomEvent) {\n\t            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n\t        } else {\n\t            event = document.createEvent('CustomEvent');\n\t            event.initCustomEvent(eventName, true, true, { detail: detail });\n\t        }\n\t\n\t        element.dispatchEvent(event);\n\t    }\n\t\n\t    /**\r\n\t     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n\t     */\n\t    (function () {\n\t        if (typeof window.CustomEvent === 'function') {\n\t            return false;\n\t        }\n\t\n\t        function CustomEvent(event, params) {\n\t            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n\t            var evt = document.createEvent('CustomEvent');\n\t            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n\t            return evt;\n\t        }\n\t\n\t        CustomEvent.prototype = window.Event.prototype;\n\t        window.CustomEvent = CustomEvent;\n\t    })();\n\t});\n\t\n\t/**\r\n\t * Temporary class declaration for the AutoNumeric object that will replace the current export\r\n\t * cf. https://github.com/BobKnothe/autoNumeric/issues/399\r\n\t */\n\t\n\tvar AutoNumeric = function AutoNumeric() {\n\t    _classCallCheck(this, AutoNumeric);\n\t};\n\t\n\t/**\r\n\t * Enumeration of the options values\r\n\t */\n\tAutoNumeric.options = {\n\t    digitGroupSeparator: {\n\t        comma: ',',\n\t        dot: '.',\n\t        normalSpace: ' ',\n\t        thinSpace: '\\u2009',\n\t        narrowNoBreakSpace: '\\u202F',\n\t        noBreakSpace: '\\xA0',\n\t        noSeparator: '',\n\t        apostrophe: \"'\",\n\t        arabicThousandsSeparator: '',\n\t        dotAbove: ''\n\t    },\n\t    noSeparatorOnFocus: {\n\t        noSeparator: true,\n\t        withSeparator: false\n\t    },\n\t    digitalGroupSpacing: {\n\t        default: '3'\n\t    },\n\t    decimalCharacter: {\n\t        comma: ',',\n\t        dot: '.',\n\t        middleDot: '',\n\t        arabicDecimalSeparator: '',\n\t        decimalSeparatorKeySymbol: ''\n\t    },\n\t    decimalCharacterAlternative: {\n\t        none: null\n\t    },\n\t    // cf. https://en.wikipedia.org/wiki/Currency_symbol\n\t    currencySymbol: {\n\t        default: '',\n\t        currencySign: '',\n\t        austral: '', // ARA\n\t        australCentavo: '',\n\t        baht: '', // THB\n\t        cedi: '', // GHS\n\t        cent: '',\n\t        colon: '', // CRC\n\t        cruzeiro: '', // BRB\n\t        dollar: '$',\n\t        dong: '', // VND\n\t        drachma: '', // GRD (or '.' or '.')\n\t        lepton: '.', // cents of the Drachma\n\t        dram: '', // AMD\n\t        european: '', // XEU (old currency before the Euro)\n\t        euro: '', // EUR\n\t        florin: '',\n\t        franc: '', // FRF\n\t        guarani: '', // PYG\n\t        hryvnia: '', // \n\t        kip: '', // LAK\n\t        att: '', // cents of the Kip\n\t        lira: '', // TRY\n\t        liraOld: '',\n\t        lari: '', // GEL\n\t        mark: '',\n\t        pfennig: '', // cents of the Mark\n\t        mill: '',\n\t        naira: '', // NGN\n\t        peseta: '',\n\t        peso: '', // PHP\n\t        pound: '',\n\t        riel: '', // KHR\n\t        ruble: '', // RUB\n\t        rupee: '', // INR\n\t        rupeeOld: '',\n\t        shekel: '',\n\t        shekelAlt: '',\n\t        taka: '', // BDT\n\t        tenge: '', // KZT\n\t        togrog: '', // MNT\n\t        won: '',\n\t        yen: ''\n\t    },\n\t    currencySymbolPlacement: {\n\t        prefix: 'p',\n\t        suffix: 's'\n\t    },\n\t    negativePositiveSignPlacement: {\n\t        prefix: 'p',\n\t        suffix: 's',\n\t        left: 'l',\n\t        right: 'r',\n\t        none: null\n\t    },\n\t    showPositiveSign: {\n\t        show: true,\n\t        hide: false\n\t    },\n\t    suffixText: {\n\t        default: ''\n\t    },\n\t    overrideMinMaxLimits: {\n\t        ceiling: 'ceiling',\n\t        floor: 'floor',\n\t        ignore: 'ignore',\n\t        doNotOverride: null\n\t    },\n\t    maximumValue: {\n\t        default: '9999999999999.99'\n\t    },\n\t    minimumValue: {\n\t        default: '-9999999999999.99'\n\t    },\n\t    decimalPlacesOverride: {\n\t        default: null\n\t    },\n\t    decimalPlacesShownOnFocus: {\n\t        default: null\n\t    },\n\t    scaleDivisor: {\n\t        default: null\n\t    },\n\t    scaleDecimalPlaces: {\n\t        default: null\n\t    },\n\t    scaleSymbol: {\n\t        default: null\n\t    },\n\t    saveValueToSessionStorage: {\n\t        save: true,\n\t        doNotSave: false\n\t    },\n\t    onInvalidPaste: {\n\t        error: 'error',\n\t        ignore: 'ignore',\n\t        clamp: 'clamp',\n\t        truncate: 'truncate',\n\t        replace: 'replace'\n\t    },\n\t    roundingMethod: {\n\t        halfUpSymmetric: 'S',\n\t        halfUpAsymmetric: 'A',\n\t        halfDownSymmetric: 's',\n\t        halfDownAsymmetric: 'a',\n\t        halfEvenBankersRounding: 'B',\n\t        upRoundAwayFromZero: 'U',\n\t        downRoundTowardZero: 'D',\n\t        toCeilingTowardPositiveInfinity: 'C',\n\t        toFloorTowardNegativeInfinity: 'F',\n\t        toNearest05: 'N05', // also 'CHF'\n\t        upToNext05: 'U05',\n\t        downToNext05: 'D05'\n\t    },\n\t    allowDecimalPadding: {\n\t        padding: true,\n\t        noPadding: false\n\t    },\n\t    negativeBracketsTypeOnBlur: {\n\t        parentheses: '(,)',\n\t        brackets: '[,]',\n\t        chevrons: '<,>',\n\t        curlyBraces: '{,}',\n\t        none: null\n\t    },\n\t    emptyInputBehavior: {\n\t        focus: 'focus',\n\t        press: 'press',\n\t        always: 'always',\n\t        zero: 'zero'\n\t    },\n\t    leadingZero: {\n\t        allow: 'allow',\n\t        deny: 'deny',\n\t        keep: 'keep'\n\t    },\n\t    formatOnPageLoad: {\n\t        format: true,\n\t        doNotFormat: false\n\t    },\n\t    selectNumberOnly: {\n\t        selectNumbersOnly: true,\n\t        selectAll: false\n\t    },\n\t    defaultValueOverride: {\n\t        default: null\n\t    },\n\t    unformatOnSubmit: {\n\t        unformat: true,\n\t        keepCurrentValue: false\n\t    },\n\t    outputFormat: {\n\t        string: 'string',\n\t        number: 'number',\n\t        dot: '.',\n\t        negativeDot: '-.',\n\t        comma: ',',\n\t        negativeComma: '-,',\n\t        dotNegative: '.-',\n\t        commaNegative: ',-',\n\t        none: null\n\t    },\n\t    isCancellable: {\n\t        cancellable: true,\n\t        notCancellable: false\n\t    },\n\t    modifyValueOnWheel: {\n\t        modifyValue: true,\n\t        doNothing: false\n\t    },\n\t    wheelStep: {\n\t        progressive: 'progressive'\n\t    },\n\t    showWarnings: {\n\t        show: true,\n\t        hide: false\n\t    },\n\t    failOnUnknownOption: {\n\t        fail: true,\n\t        ignore: false\n\t    }\n\t};\n\t\n\t/**\r\n\t * This exports the interface for the autoNumeric object\r\n\t */\n\texports.default = {\n\t    AutoNumeric: AutoNumeric,\n\t    format: autoFormat,\n\t    unFormat: autoUnFormat,\n\t    getDefaultConfig: getDefaultConfig,\n\t    getLanguages: getLanguages,\n\t    validate: validate, // an.validate(options) : throws if necessary\n\t    areSettingsValid: areSettingsValid };\n\t}.call(window));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// autoNumeric.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bdbf8a949af3a66cf46b","/**\r\n *               autoNumeric.js\r\n *\r\n * @version      3.0.0-beta.2\r\n * @date         2017-02-03 UTC 03:00\r\n *\r\n * @author       Bob Knothe\r\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\r\n *               cf. AUTHORS.md.\r\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n * @since        2009-08-09\r\n *\r\n * @summary      autoNumeric is a library that provides live as-you-type\r\n *               formatting for international numbers and currencies.\r\n *\r\n *               Note : Some functions are borrowed from big.js\r\n * @link         https://github.com/MikeMcl/big.js/\r\n *\r\n * Please report any bugs to https://github.com/BobKnothe/autoNumeric\r\n *\r\n * @license      Released under the MIT License\r\n * @link         http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sub license, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\n/* global module, require, define */\r\n\r\n// Functions names for ES6 exports\r\nlet autoFormat;\r\nlet autoUnFormat;\r\nlet getDefaultConfig;\r\nlet getLanguages;\r\nlet validate;\r\nlet areSettingsValid;\r\n\r\n// AutoNumeric default settings\r\n/**\r\n * List of allowed tag on which autoNumeric can be used.\r\n */\r\nconst allowedTagList = [\r\n    'b',\r\n    'caption',\r\n    'cite',\r\n    'code',\r\n    'const',\r\n    'dd',\r\n    'del',\r\n    'div',\r\n    'dfn',\r\n    'dt',\r\n    'em',\r\n    'h1',\r\n    'h2',\r\n    'h3',\r\n    'h4',\r\n    'h5',\r\n    'h6',\r\n    'ins',\r\n    'kdb',\r\n    'label',\r\n    'li',\r\n    'option',\r\n    'output',\r\n    'p',\r\n    'q',\r\n    's',\r\n    'sample',\r\n    'span',\r\n    'strong',\r\n    'td',\r\n    'th',\r\n    'u',\r\n];\r\n\r\n/**\r\n * Defaults options are public - these can be overridden by the following method:\r\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" \">`)\r\n * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' ' });`)\r\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n */\r\nconst defaultSettings = {\r\n    /* Allowed thousand grouping separator characters :\r\n     * ','      // Comma\r\n     * '.'      // Dot\r\n     * ' '      // Normal space\r\n     * '\\u2009' // Thin-space\r\n     * '\\u202f' // Narrow no-break space\r\n     * '\\u00a0' // No-break space\r\n     * ''       // No separator\r\n     * \"'\"      // Apostrophe\r\n     * ''      // Arabic thousands separator\r\n     * ''      // Dot above\r\n     * Deprecated older option name : aSep\r\n     */\r\n    digitGroupSeparator: ',',\r\n\r\n    /* Remove the thousand separator on focus, currency symbol and suffix on focus\r\n     * example if the input value \"$ 1,999.88 suffix\"\r\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n     * Deprecated older option name : nSep\r\n     */\r\n    noSeparatorOnFocus: false,\r\n\r\n    /* Digital grouping for the thousand separator used in Format\r\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\r\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\r\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n     * Deprecated older option name : dGroup\r\n     */\r\n    digitalGroupSpacing: '3',\r\n\r\n    /* Allowed decimal separator characters :\r\n     * ',' : Comma\r\n     * '.' : Dot\r\n     * '' : Middle-dot\r\n     * '' : Arabic decimal separator\r\n     * '' : Decimal separator key symbol\r\n     * Deprecated older option name : aDec\r\n     */\r\n    decimalCharacter: '.',\r\n\r\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\r\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\r\n     * a period 'full stop' as the decimal characters (France or Spain for instance).\r\n     * Deprecated older option name : altDec\r\n     */\r\n    decimalCharacterAlternative: null,\r\n\r\n    /* currencySymbol = allowed currency symbol\r\n     * Must be in quotes currencySymbol: \"$\"\r\n     * space to the right of the currency symbol currencySymbol: '$ '\r\n     * space to the left of the currency symbol currencySymbol: ' $'\r\n     * Deprecated older option name : aSign\r\n     */\r\n    currencySymbol: '',\r\n\r\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\r\n     * for prefix currencySymbolPlacement: \"p\" (default)\r\n     * for suffix currencySymbolPlacement: \"s\"\r\n     * Deprecated older option name : pSign\r\n     */\r\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\r\n    currencySymbolPlacement: 'p',\r\n\r\n    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\r\n     * -1,234.56  => default no options required\r\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\r\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\r\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\r\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\r\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\r\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\r\n     * Deprecated older option name : pNeg\r\n     */\r\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\r\n    negativePositiveSignPlacement: null,\r\n\r\n\r\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\r\n     * By default, this positive sign is not shown.\r\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\r\n     */\r\n    showPositiveSign: false,\r\n\r\n    /* Additional suffix\r\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\r\n     * Numeric characters and negative sign not allowed'\r\n     * Deprecated older option name : aSuffix\r\n     */\r\n    suffixText: '',\r\n\r\n    /* Override min max limits\r\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\r\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\r\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\r\n     * Deprecated older option name : oLimits\r\n     */\r\n    overrideMinMaxLimits: null,\r\n\r\n    /* Maximum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be larger than minimumValue\r\n     * Deprecated older option name : vMax\r\n     */\r\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\r\n\r\n    /* Minimum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be smaller than maximumValue\r\n     * Deprecated older option name : vMin\r\n     */\r\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\r\n\r\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\r\n     * Deprecated older option name : mDec\r\n     */\r\n    decimalPlacesOverride: null,\r\n\r\n    /* Expanded decimal places visible when input has focus - example:\r\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n     * the \"get\" method returns the extended decimal places\r\n     * Deprecated older option name : eDec\r\n     */\r\n    decimalPlacesShownOnFocus: null,\r\n\r\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\r\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\r\n     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\r\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n     */\r\n\r\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n     */\r\n    scaleDivisor: null,\r\n\r\n    /*\r\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n     * Deprecated older option name : scaleDecimal\r\n     */\r\n    scaleDecimalPlaces: null,\r\n\r\n    /*\r\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n     * This is optional too.\r\n     */\r\n    scaleSymbol: null,\r\n\r\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\r\n     * if ie 6 or 7 the value will be saved as a session cookie\r\n     * Deprecated older option name : aStor\r\n     */\r\n    saveValueToSessionStorage: false,\r\n\r\n    /*\r\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\r\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\r\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\r\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\r\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\r\n     *                The non-pasted numbers are dropped and therefore not used at all.\r\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\r\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\r\n     *\r\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\r\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\r\n     *          Only the first number will be used (here '123').\r\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\r\n     */\r\n    //TODO Shouldn't we use `truncate` as the default value?\r\n    onInvalidPaste: 'error',\r\n\r\n    /* method used for rounding\r\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\r\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\r\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\r\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\r\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n     * roundingMethod: \"U05\" Rounds up to next .05\r\n     * roundingMethod: \"D05\" Rounds down to next .05\r\n     * Deprecated older option name : mRound\r\n     */\r\n    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\r\n    //TODO Add an `an.roundingMethod` object that enum those options clearly\r\n    roundingMethod: 'S',\r\n\r\n    /* Allow padding the decimal places with zeros\r\n     * allowDecimalPadding: true - always Pad decimals with zeros\r\n     * allowDecimalPadding: false - does not pad with zeros.\r\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\r\n     *\r\n     * thanks to Jonas Johansson for the suggestion\r\n     * Deprecated older option name : aPad\r\n     */\r\n    allowDecimalPadding: true,\r\n\r\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n     * Those brackets are visible only when the field does NOT have the focus.\r\n     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n     * This option can be of the following values :\r\n     * null, // This is the default value, which deactivate this feature\r\n     * '(,)',\r\n     * '[,]',\r\n     * '<,>' or\r\n     * '{,}'\r\n     * Deprecated older option name : nBracket\r\n     */\r\n    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\r\n    negativeBracketsTypeOnBlur: null,\r\n\r\n    /* Displayed on empty string \"\"\r\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\r\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\r\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\r\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n     * Deprecated older option name : wEmpty\r\n     */\r\n    emptyInputBehavior: 'focus',\r\n\r\n    /* Controls leading zero behavior\r\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\r\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n     * Deprecated older option name : lZero\r\n     */\r\n    leadingZero: 'deny',\r\n\r\n    /* Determine if the default value will be formatted on initialization.\r\n     * true = automatically formats the default value on initialization\r\n     * false = will not format the default value on initialization\r\n     * Deprecated older option name : aForm\r\n     */\r\n    formatOnPageLoad: true,\r\n\r\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\r\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\r\n     * Deprecated older option name : sNumber\r\n     */\r\n    selectNumberOnly: false,\r\n\r\n    /* Helper option for ASP.NET postback\r\n     * should be the value of the unformatted default value\r\n     * examples:\r\n     * no default value=\"\" {defaultValueOverride: \"\"}\r\n     * value=1234.56 {defaultValueOverride: '1234.56'}\r\n     * Deprecated older option name : anDefault\r\n     */\r\n    defaultValueOverride: null,\r\n\r\n    /* Removes formatting on submit event\r\n     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n     * review the 'unSet' method for other formats\r\n     * Deprecated older option name : unSetOnSubmit\r\n     */\r\n    unformatOnSubmit: false,\r\n\r\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n     * Deprecated older option name : outputType\r\n     */\r\n    outputFormat: null,\r\n\r\n    /* Allow the user to 'cancel' and undo the changes he made to the given autonumeric-managed element, by pressing the 'Escape' key.\r\n     * Whenever the user 'validate' the input (either by hitting 'Enter', or blurring the element), the new value is saved for subsequent 'cancellation'.\r\n     *\r\n     * The process :\r\n     *   - save the input value on focus\r\n     *   - if the user change the input value, and hit `Escape`, then the initial value saved on focus is set back\r\n     *   - on the other hand if the user either have used `Enter` to validate (`Enter` throws a change event) his entries, or if the input value has been changed by another script in the mean time, then we save the new input value\r\n     *   - on a successful 'cancel', select the whole value (while respecting the `selectNumberOnly` option)\r\n     *   - bonus; if the value has not changed, hitting 'Esc' just select all the input value (while respecting the `selectNumberOnly` option)\r\n     */\r\n    isCancellable : true,\r\n\r\n    /* Allow the user to increment or decrement the element value with the mouse wheel.\r\n     * The wheel behavior can by modified by the `wheelStep` option.\r\n     * This `wheelStep` options can be used in two ways, either by setting :\r\n     * - a 'fixed' step value (`wheelStep : 1000`), or\r\n     * - the 'progressive' string (`wheelStep : 'progressive'`), which will then activate a special mode where the step is automatically calculated based on the element value size.\r\n     *\r\n     * Note :\r\n     * A special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\r\n     * You can use the 'Shift' modifier key while using the mouse wheel in order to temporarily disable the increment/decrement feature (useful on small screen where some badly configured inputs could use all the available space).\r\n     */\r\n    modifyValueOnWheel : true,\r\n\r\n    /* That option is linked to the `modifyValueOnWheel` one and will only be used if the latter is set to `true`.\r\n     * This option will modify the wheel behavior and can be used in two ways, either by setting :\r\n     * - a 'fixed' step value (a positive float or integer number `1000`), or\r\n     * - the `'progressive'` string.\r\n     *\r\n     * The 'fixed' mode always increment/decrement the element value by that amount, while respecting the `minimumValue` and `maximumValue` settings.\r\n     * The 'progressive' mode will increment/decrement the element value based on its current value. The bigger the number, the bigger the step, and vice versa.\r\n     */\r\n    wheelStep : 'progressive',\r\n\r\n    /* Defines if warnings should be shown\r\n     * Error handling function\r\n     * true => all warning are shown\r\n     * false => no warnings are shown, only the thrown errors\r\n     * Deprecated older option name : debug\r\n     */\r\n    showWarnings: true,\r\n\r\n    /*\r\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\r\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\r\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\r\n     */\r\n    failOnUnknownOption: false,\r\n};\r\n\r\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n * //TODO Replace every call to this object with a call to `keyName`\r\n * @deprecated\r\n */\r\nconst keyCode = {\r\n    Backspace:      8,\r\n    Tab:            9,\r\n    Enter:          13,\r\n    Shift:          16,\r\n    Ctrl:           17,\r\n    Alt:            18,\r\n    PauseBreak:     19,\r\n    CapsLock:       20,\r\n    Esc:            27,\r\n    Space:          32,\r\n    PageUp:         33,\r\n    PageDown:       34,\r\n    End:            35,\r\n    Home:           36,\r\n    LeftArrow:      37,\r\n    UpArrow:        38,\r\n    RightArrow:     39,\r\n    DownArrow:      40,\r\n    Insert:         45,\r\n    Delete:         46,\r\n    num0:           48,\r\n    num1:           49,\r\n    num2:           50,\r\n    num3:           51,\r\n    num4:           52,\r\n    num5:           53,\r\n    num6:           54,\r\n    num7:           55,\r\n    num8:           56,\r\n    num9:           57,\r\n    a:              65,\r\n    b:              66,\r\n    c:              67,\r\n    d:              68,\r\n    e:              69,\r\n    f:              70,\r\n    g:              71,\r\n    h:              72,\r\n    i:              73,\r\n    j:              74,\r\n    k:              75,\r\n    l:              76,\r\n    m:              77,\r\n    n:              78,\r\n    o:              79,\r\n    p:              80,\r\n    q:              81,\r\n    r:              82,\r\n    s:              83,\r\n    t:              84,\r\n    u:              85,\r\n    v:              86,\r\n    w:              87,\r\n    x:              88,\r\n    y:              89,\r\n    z:              90,\r\n    Windows:        91,\r\n    RightClick:     93,\r\n    numpad0:        96,\r\n    numpad1:        97,\r\n    numpad2:        98,\r\n    numpad3:        99,\r\n    numpad4:        100,\r\n    numpad5:        101,\r\n    numpad6:        102,\r\n    numpad7:        103,\r\n    numpad8:        104,\r\n    numpad9:        105,\r\n    MultiplyNumpad: 106,\r\n    PlusNumpad:     107,\r\n    MinusNumpad:    109,\r\n    DotNumpad:      110,\r\n    SlashNumpad:    111,\r\n    F1:             112,\r\n    F2:             113,\r\n    F3:             114,\r\n    F4:             115,\r\n    F5:             116,\r\n    F6:             117,\r\n    F7:             118,\r\n    F8:             119,\r\n    F9:             120,\r\n    F10:            121,\r\n    F11:            122,\r\n    F12:            123,\r\n    NumLock:        144,\r\n    ScrollLock:     145,\r\n    MyComputer:     182,\r\n    MyCalculator:   183,\r\n    Semicolon:      186,\r\n    Equal:          187,\r\n    Comma:          188,\r\n    Hyphen:         189,\r\n    Dot:            190,\r\n    Slash:          191,\r\n    Backquote:      192,\r\n    LeftBracket:    219,\r\n    Backslash:      220,\r\n    RightBracket:   221,\r\n    Quote:          222,\r\n    Command:        224,\r\n};\r\n\r\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\r\n * Those names are listed here :\r\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n */\r\nconst keyName = {\r\n    // Special values\r\n    Unidentified:   'Unidentified',\r\n\r\n    // Modifier keys\r\n    Alt:            'Alt',\r\n    AltGr:          'AltGraph',\r\n    CapsLock:       'CapsLock', // Under Chrome, e.key is empty for CapsLock\r\n    Ctrl:           'Control',\r\n    Fn:             'Fn',\r\n    FnLock:         'FnLock',\r\n    Hyper:          'Hyper', // 'OS' under Firefox\r\n    Meta:           'Meta', // The Windows, Command or  key // 'OS' under Firefox and IE9\r\n    Windows:        'Meta', // This is a non-official key name\r\n    Command:        'Meta', // This is a non-official key name\r\n    NumLock:        'NumLock',\r\n    ScrollLock:     'ScrollLock',\r\n    Shift:          'Shift',\r\n    Super:          'Super', // 'OS' under Firefox\r\n    Symbol:         'Symbol',\r\n    SymbolLock:     'SymbolLock',\r\n\r\n    // Whitespace keys\r\n    Enter:          'Enter',\r\n    Tab:            'Tab',\r\n    Space:          ' ', // 'Spacebar' for Firefox <37, and IE9\r\n\r\n    // Navigation keys\r\n    DownArrow:      'ArrowDown', // 'Down' for Firefox <=36, and IE9\r\n    LeftArrow:      'ArrowLeft', // 'Left' for Firefox <=36, and IE9\r\n    RightArrow:     'ArrowRight', // 'Right' for Firefox <=36, and IE9\r\n    UpArrow:        'ArrowUp', // 'Up' for Firefox <=36, and IE9\r\n    End:            'End',\r\n    Home:           'Home',\r\n    PageDown:       'PageDown',\r\n    PageUp:         'PageUp',\r\n\r\n    // Editing keys\r\n    Backspace:      'Backspace',\r\n    Clear:          'Clear',\r\n    Copy:           'Copy',\r\n    CrSel:          'CrSel', // 'Crsel' for Firefox <=36, and IE9\r\n    Cut:            'Cut',\r\n    Delete:         'Delete', // 'Del' for Firefox <=36, and IE9\r\n    EraseEof:       'EraseEof',\r\n    ExSel:          'ExSel', // 'Exsel' for Firefox <=36, and IE9\r\n    Insert:         'Insert',\r\n    Paste:          'Paste',\r\n    Redo:           'Redo',\r\n    Undo:           'Undo',\r\n\r\n    // UI keys\r\n    Accept:         'Accept',\r\n    Again:          'Again',\r\n    Attn:           'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\r\n    Cancel:         'Cancel',\r\n    ContextMenu:    'ContextMenu', // 'Apps' for Firefox <=36, and IE9\r\n    Esc:            'Escape', // 'Esc' for Firefox <=36, and IE9\r\n    Execute:        'Execute',\r\n    Find:           'Find',\r\n    Finish:         'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\r\n    Help:           'Help',\r\n    Pause:          'Pause',\r\n    Play:           'Play',\r\n    Props:          'Props',\r\n    Select:         'Select',\r\n    ZoomIn:         'ZoomIn',\r\n    ZoomOut:        'ZoomOut',\r\n\r\n    // Device keys\r\n    BrightnessDown: 'BrightnessDown',\r\n    BrightnessUp:   'BrightnessUp',\r\n    Eject:          'Eject',\r\n    LogOff:         'LogOff',\r\n    Power:          'Power',\r\n    PowerOff:       'PowerOff',\r\n    PrintScreen:    'PrintScreen',\r\n    Hibernate:      'Hibernate', // 'Unidentified' for Firefox <=37\r\n    Standby:        'Standby', // 'Unidentified' for Firefox <=36, and IE9\r\n    WakeUp:         'WakeUp',\r\n\r\n    // IME and composition keys\r\n    Compose:        'Compose',\r\n    Dead:           'Dead',\r\n\r\n    // Function keys\r\n    F1:             'F1',\r\n    F2:             'F2',\r\n    F3:             'F3',\r\n    F4:             'F4',\r\n    F5:             'F5',\r\n    F6:             'F6',\r\n    F7:             'F7',\r\n    F8:             'F8',\r\n    F9:             'F9',\r\n    F10:            'F10',\r\n    F11:            'F11',\r\n    F12:            'F12',\r\n\r\n    // Document keys\r\n    Print:          'Print',\r\n\r\n    // 'Normal' keys\r\n    num0:           '0',\r\n    num1:           '1',\r\n    num2:           '2',\r\n    num3:           '3',\r\n    num4:           '4',\r\n    num5:           '5',\r\n    num6:           '6',\r\n    num7:           '7',\r\n    num8:           '8',\r\n    num9:           '9',\r\n    numpad0:        '0',\r\n    numpad1:        '1',\r\n    numpad2:        '2',\r\n    numpad3:        '3',\r\n    numpad4:        '4',\r\n    numpad5:        '5',\r\n    numpad6:        '6',\r\n    numpad7:        '7',\r\n    numpad8:        '8',\r\n    numpad9:        '9',\r\n    a:              'a',\r\n    b:              'b',\r\n    c:              'c',\r\n    d:              'd',\r\n    e:              'e',\r\n    f:              'f',\r\n    g:              'g',\r\n    h:              'h',\r\n    i:              'i',\r\n    j:              'j',\r\n    k:              'k',\r\n    l:              'l',\r\n    m:              'm',\r\n    n:              'n',\r\n    o:              'o',\r\n    p:              'p',\r\n    q:              'q',\r\n    r:              'r',\r\n    s:              's',\r\n    t:              't',\r\n    u:              'u',\r\n    v:              'v',\r\n    w:              'w',\r\n    x:              'x',\r\n    y:              'y',\r\n    z:              'z',\r\n    MultiplyNumpad: '*',\r\n    PlusNumpad:     '+',\r\n    MinusNumpad:    '-',\r\n    DotNumpad:      '.',\r\n    SlashNumpad:    '/',\r\n    Semicolon:      ';',\r\n    Equal:          '=',\r\n    Comma:          ',',\r\n    Hyphen:         '-',\r\n    Minus:          '-',\r\n    Plus:           '+',\r\n    Dot:            '.',\r\n    Slash:          '/',\r\n    Backquote:      '`',\r\n    LeftBracket:    '[',\r\n    RightBracket:   ']',\r\n    Backslash:      '\\\\',\r\n    Quote:          \"'\",\r\n};\r\n\r\nconst defaultMinimumValue     = '-999999999999.99';\r\nconst defaultMaximumValue     = '999999999999.99';\r\nconst defaultRoundingMethod   = 'U';\r\nconst defaultLeadingZero      = 'deny';\r\nconst defaultSelectNumberOnly = true;\r\n\r\n/**\r\n * Predefined options for the most common languages\r\n */\r\nconst languageOption = {\r\n    French: { // Franais\r\n        digitGroupSeparator        : '.', // or '\\u202f'\r\n        decimalCharacter           : ',',\r\n        decimalCharacterAlternative: '.',\r\n        currencySymbol             : '\\u202f',\r\n        currencySymbolPlacement    : 's',\r\n        selectNumberOnly           : defaultSelectNumberOnly,\r\n        roundingMethod             : defaultRoundingMethod,\r\n        leadingZero                : defaultLeadingZero,\r\n        minimumValue               : defaultMinimumValue,\r\n        maximumValue               : defaultMaximumValue,\r\n    },\r\n    NorthAmerican: {\r\n        digitGroupSeparator    : ',',\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '$',\r\n        currencySymbolPlacement: 'p',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n    British: {\r\n        digitGroupSeparator    : ',',\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '',\r\n        currencySymbolPlacement: 'p',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n    Swiss: { // Suisse\r\n        digitGroupSeparator    : `'`,\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '\\u202fCHF',\r\n        currencySymbolPlacement: 's',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n    Japanese: { // \r\n        digitGroupSeparator    : ',',\r\n        decimalCharacter       : '.',\r\n        currencySymbol         : '',\r\n        currencySymbolPlacement: 'p',\r\n        selectNumberOnly       : defaultSelectNumberOnly,\r\n        roundingMethod         : defaultRoundingMethod,\r\n        leadingZero            : defaultLeadingZero,\r\n        minimumValue           : defaultMinimumValue,\r\n        maximumValue           : defaultMaximumValue,\r\n    },\r\n};\r\nlanguageOption.Spanish = languageOption.French; // Espaol (idem French)\r\nlanguageOption.Chinese = languageOption.Japanese; //  (Chinese)\r\n\r\n/**\r\n * UMD structure\r\n */\r\n(function(factory) {\r\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\r\nif (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define(['jquery'], factory);\r\n} else if (typeof module === 'object' && module.exports) {\r\n    // Node/CommonJS\r\n    module.exports = factory(require('jquery'));\r\n} else {\r\n    // Browser globals\r\n    factory(window.jQuery);\r\n}\r\n}($ => {\r\n    // Helper functions\r\n\r\n    /**\r\n     * Return TRUE if the `value` is null\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\r\n     */\r\n    function isNull(value) {\r\n        return value === null;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the `value` is undefined\r\n     *\r\n     * @static\r\n     * @param {*} value The value to test\r\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\r\n     */\r\n    function isUndefined(value) {\r\n        return value === void(0);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the `value` is undefined, null or empty\r\n     *\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\r\n    function isUndefinedOrNullOrEmpty(value) {\r\n        return value === null || value === void(0) || '' === value;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given parameter is a String\r\n     *\r\n     * @param {*} str\r\n     * @returns {boolean}\r\n     */\r\n    function isString(str) {\r\n        return (typeof str === 'string' || str instanceof String);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a boolean\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\r\n    function isBoolean(value) {\r\n        return typeof(value) === 'boolean';\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a string 'true' or 'false'\r\n     *\r\n     * This function accepts any cases for those strings.\r\n     * @param {string} value\r\n     * @returns {boolean}\r\n     */\r\n    function isTrueOrFalseString(value) {\r\n        const lowercaseValue = String(value).toLowerCase();\r\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is an object\r\n     *\r\n     * @param {*} reference\r\n     * @returns {boolean}\r\n     */\r\n    function isObject(reference) {\r\n        return typeof reference === 'object' && reference !== null && !Array.isArray(reference);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given object is empty\r\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n     *\r\n     * @param {object} obj\r\n     * @returns {boolean}\r\n     */\r\n    function isEmptyObj(obj) {\r\n        for (const prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a number (or a number written as a string).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\r\n    function isNumber(n) {\r\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is an integer (and not a float).\r\n     *\r\n     * @param {*} n\r\n     * @returns {boolean}\r\n     */\r\n    function isInt(n) {\r\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\r\n    }\r\n\r\n    /**\r\n     * Return the pasted text that will be used.\r\n     *\r\n     * @param {string} text\r\n     * @param {AutoNumericHolder} holder\r\n     * @returns {string|void|XML|*}\r\n     */\r\n    function preparePastedText(text, holder) {\r\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\r\n    }\r\n\r\n    /**\r\n     * Return TRUE is the string `str` contains the string `needle`\r\n     * Note: this function does not coerce the parameters types\r\n     *\r\n     * @param {string} str\r\n     * @param {string} needle\r\n     * @returns {boolean}\r\n     */\r\n    function contains(str, needle) {\r\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\r\n            return false;\r\n        }\r\n\r\n        return str.indexOf(needle) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the `needle` is in the array\r\n     *\r\n     * @param {*} needle\r\n     * @param {Array} array\r\n     * @returns {boolean}\r\n     */\r\n    function isInArray(needle, array) {\r\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\r\n            return false;\r\n        }\r\n\r\n        return array.indexOf(needle) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is an Array\r\n     *\r\n     * @param {*} arr\r\n     * @throws Error\r\n     * @returns {*|boolean}\r\n     */\r\n    function isArray(arr) {\r\n        if (Object.prototype.toString.call([]) === '[object Array]') { // Make sure an array has a class attribute of [object Array]\r\n            // Test passed, now check if is an Array\r\n            return Array.isArray(arr) || (typeof arr === 'object' && Object.prototype.toString.call(arr) === '[object Array]');\r\n        }\r\n        else {\r\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n     *\r\n     * @param {string} str\r\n     * @returns {boolean}\r\n     */\r\n    // function hasDecimals(str) {\r\n    //     const [, decimalPart] = str.split('.');\r\n    //     return !isUndefined(decimalPart);\r\n    // }\r\n\r\n    /**\r\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n     *\r\n     * @param {string} str\r\n     * @returns {int}\r\n     */\r\n    function decimalPlaces(str) {\r\n        const [, decimalPart] = str.split('.');\r\n        if (!isUndefined(decimalPart)) {\r\n            return decimalPart.length;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Return the code for the key used to generate the given event.\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string|Number}\r\n     */\r\n    function keyCodeNumber(event) {\r\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\r\n        return (typeof event.which === 'undefined')?event.keyCode:event.which;\r\n    }\r\n\r\n    /**\r\n     * Return the character from the event key code.\r\n     * @example character(50) => '2'\r\n     *\r\n     * @param {Event} event\r\n     * @returns {string}\r\n     */\r\n    function character(event) {\r\n        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\r\n            return String.fromCharCode(keyCodeNumber(event));\r\n        } else {\r\n            return event.key;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\r\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\r\n     * @returns {boolean}\r\n     */\r\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\r\n        const parsedValue = parseStr(value);\r\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given string contains a negative sign :\r\n     * - everywhere in the string (by default), or\r\n     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\r\n     *\r\n     * @param {string} numericString A number represented by a string\r\n     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\r\n     * @returns {boolean}\r\n     */\r\n    function isNegative(numericString, checkEverywhere = true) {\r\n        //TODO Use the `negativeSignCharacter` from the settings here\r\n        if (checkEverywhere) {\r\n            return contains(numericString, '-');\r\n        }\r\n\r\n        return isNegativeStrict(numericString);\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\r\n     *\r\n     * @example isNegativeStrict('1234.56')     => false\r\n     * @example isNegativeStrict('1234.56-')    => false\r\n     * @example isNegativeStrict('-1234.56')    => true\r\n     * @example isNegativeStrict('-1,234.56 ') => true\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\r\n    function isNegativeStrict(numericString) {\r\n        //TODO Using the `negativeSignCharacter` from the settings here\r\n        return numericString.charAt(0) === '-';\r\n    }\r\n\r\n    /**\r\n     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 '), or is empty (' ').\r\n     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {boolean}\r\n     */\r\n    function isZeroOrHasNoValue(numericString) {\r\n        return !(/[1-9]/g).test(numericString);\r\n    }\r\n\r\n    /**\r\n     * Return the negative version of the value (represented as a string) given as a parameter.\r\n     *\r\n     * @param {string} value\r\n     * @returns {*}\r\n     */\r\n    function setRawNegativeSign(value) {\r\n        if (!isNegativeStrict(value)) {\r\n            return `-${value}`;\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\r\n     *\r\n     * @param {string} string\r\n     * @param {int} index\r\n     * @param {string} newCharacter\r\n     * @returns {string}\r\n     */\r\n    function replaceCharAt(string, index, newCharacter) {\r\n        return `${string.substr(0, index)}${newCharacter}${string.substr(index + newCharacter.length)}`;\r\n    }\r\n\r\n    /**\r\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} settings\r\n     * @returns {number}\r\n     */\r\n    function clampToRangeLimits(value, settings) {\r\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\r\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\r\n    }\r\n\r\n    /**\r\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\r\n     *\r\n     * @param {string} formattedNumberString\r\n     * @param {int} caretPosition This must be a positive integer\r\n     * @param {string} decimalCharacter\r\n     * @returns {number}\r\n     */\r\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\r\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\r\n        const numberDotOrNegativeSign = new RegExp(`[0-9${decimalCharacter}-]`); // No need to escape the decimal character here, since it's in `[]`\r\n\r\n        let numberDotAndNegativeSignCount = 0;\r\n        for (let i = 0; i < caretPosition; i++) {\r\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\r\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\r\n                numberDotAndNegativeSignCount++;\r\n            }\r\n        }\r\n\r\n        return numberDotAndNegativeSignCount;\r\n    }\r\n\r\n    /**\r\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\r\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\r\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\r\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\r\n     *\r\n     * @example\r\n     * 1234567|89.01   : position 7 (rawNumberString)\r\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\r\n     *\r\n     * @param {string} rawNumberString\r\n     * @param {int} caretPositionInRawValue\r\n     * @param {string} formattedNumberString\r\n     * @param {string} decimalCharacter\r\n     * @returns {*}\r\n     */\r\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\r\n        const formattedNumberStringSize = formattedNumberString.length;\r\n        const rawNumberStringSize = rawNumberString.length;\r\n\r\n        let formattedNumberStringIndex;\r\n        let rawNumberStringIndex = 0;\r\n        for (formattedNumberStringIndex = 0;\r\n             formattedNumberStringIndex < formattedNumberStringSize &&\r\n             rawNumberStringIndex < rawNumberStringSize &&\r\n             rawNumberStringIndex < caretPositionInRawValue;\r\n             formattedNumberStringIndex++) {\r\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] ||\r\n                (rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter)) {\r\n                rawNumberStringIndex++;\r\n            }\r\n        }\r\n\r\n        return formattedNumberStringIndex;\r\n    }\r\n\r\n    /**\r\n     * Count the number of occurrence of the given character, in the given text.\r\n     *\r\n     * @param {string} character\r\n     * @param {string} text\r\n     * @returns {number}\r\n     */\r\n    function countCharInText(character, text) {\r\n        let charCounter = 0;\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (text[i] === character) {\r\n                charCounter++;\r\n            }\r\n        }\r\n\r\n        return charCounter;\r\n    }\r\n\r\n    /**\r\n     * Return the index that can be used to set the caret position.\r\n     * This takes into account that the position is starting at '0', not 1.\r\n     *\r\n     * @param {int} characterCount\r\n     * @returns {number}\r\n     */\r\n    function convertCharacterCountToIndexPosition(characterCount) {\r\n        return Math.max(characterCount, characterCount - 1);\r\n    }\r\n\r\n    /**\r\n     * Cross browser routine for getting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @returns {{}}\r\n     */\r\n    function getElementSelection(that) {\r\n        const position = {};\r\n        if (isUndefined(that.selectionStart)) {\r\n            that.focus();\r\n            const select = document.selection.createRange();\r\n            position.length = select.text.length;\r\n            select.moveStart('character', -that.value.length);\r\n            position.end = select.text.length;\r\n            position.start = position.end - position.length;\r\n        } else {\r\n            position.start = that.selectionStart;\r\n            position.end = that.selectionEnd;\r\n            position.length = position.end - position.start;\r\n        }\r\n\r\n        return position;\r\n    }\r\n\r\n    /**\r\n     * Cross browser routine for setting selected range/cursor position\r\n     *\r\n     * @param {HTMLElement|EventTarget} that\r\n     * @param {int} start\r\n     * @param {int|null} end\r\n     */\r\n    function setElementSelection(that, start, end = null) {\r\n        if (isUndefinedOrNullOrEmpty(end)) {\r\n            end = start;\r\n        }\r\n\r\n        if (isUndefined(that.selectionStart)) {\r\n            that.focus();\r\n            const range = that.createTextRange();\r\n            range.collapse(true);\r\n            range.moveEnd('character', end);\r\n            range.moveStart('character', start);\r\n            range.select();\r\n        } else {\r\n            that.selectionStart = start;\r\n            that.selectionEnd = end;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function that throw error messages\r\n     *\r\n     * @param {string} message\r\n     */\r\n    function throwError(message) {\r\n        throw new Error(message);\r\n    }\r\n\r\n    /**\r\n     * Function that display a warning messages, according to the debug level.\r\n     *\r\n     * @param {string} message\r\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\r\n     */\r\n    function warning(message, showWarning = true) {\r\n        if (showWarning) {\r\n            /* eslint no-console: 0 */\r\n            console.warn(`Warning: ${message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return `true` if the given event is a wheelup event\r\n     *\r\n     * @param {Event} DOMevent\r\n     * @returns {boolean}\r\n     */\r\n    function isWheelUpEvent(DOMevent) {\r\n        if (!DOMevent.deltaY) {\r\n            throwError(`The event passed as a parameter is not a wheel event, ${DOMevent.type} given.`);\r\n        }\r\n\r\n        return DOMevent.deltaY < 0;\r\n    }\r\n\r\n    /**\r\n     * Return `true` if the given event is a wheeldown event\r\n     *\r\n     * @param {Event} DOMevent\r\n     * @returns {boolean}\r\n     */\r\n    function isWheelDownEvent(DOMevent) {\r\n        if (!DOMevent.deltaY) {\r\n            throwError(`The event passed as a parameter is not a wheel event, ${DOMevent.type} given.`);\r\n        }\r\n\r\n        return DOMevent.deltaY > 0;\r\n    }\r\n\r\n    /**\r\n     * Return the 'nearest rounded' value, according to the given step size.\r\n     * @example roundToNearest(264789, 10000)) => 260000\r\n     *\r\n     * @param {number} value\r\n     * @param {number} stepPlace\r\n     * @returns {*}\r\n     */\r\n    function roundToNearest(value, stepPlace = 1000) {\r\n        if (value <= 10 && value >= -10) {\r\n            return value;\r\n        }\r\n\r\n        if (0 === value) {\r\n            return 0;\r\n        }\r\n\r\n        return Math.round(value / stepPlace) * stepPlace;\r\n    }\r\n\r\n    /**\r\n     * Return the 'nearest rounded' value automatically by adding or subtracting the calculated offset to the initial value.\r\n     * This is done without having to pass a step to this function.\r\n     * @example                    Calculated offset\r\n     *           1 ->           1 (10)\r\n     *          14 ->          10 (10)\r\n     *         143 ->         140 (10)\r\n     *       1.278 ->       1.300 (100)\r\n     *      28.456 ->      28.500 (100)\r\n     *     276.345 ->     276.000 (1000)\r\n     *   4.534.061 ->   4.530.000 (10000)\r\n     *  66.723.844 ->  66.700.000 (100000)\r\n     * 257.833.411 -> 258.000.000 (1000000)\r\n     *\r\n     * @param {number} value\r\n     * @param {boolean} isAddition\r\n     * @returns {*}\r\n     */\r\n    function modifyAndRoundToNearestAuto(value, isAddition) {\r\n        value = parseInt(value, 10);\r\n        const lengthValue = Math.abs(value).toString().length; // Math.abs is needed here to omit the negative sign '-' in case of a negative value\r\n\r\n        let pow;\r\n        switch (lengthValue) {\r\n            // Special cases for small numbers\r\n            case 1:\r\n                pow = 0;\r\n                break;\r\n            case 2:\r\n            case 3:\r\n                pow = 1;\r\n                break;\r\n            case 4:\r\n            case 5:\r\n                pow = 2;\r\n                break;\r\n            // Default behavior\r\n            default:\r\n                pow = lengthValue - 3;\r\n        }\r\n        const offset = Math.pow(10, pow);\r\n\r\n        let result;\r\n        if (isAddition) {\r\n            result = value + offset;\r\n        } else {\r\n            result = value - offset;\r\n        }\r\n\r\n        return roundToNearest(result, Math.pow(10, pow));\r\n    }\r\n\r\n    /**\r\n     * Return the 'nearest rounded' value automatically by adding the calculated offset to the initial value.\r\n     *\r\n     * @param {number} value\r\n     * @returns {*}\r\n     */\r\n    function addAndRoundToNearestAuto(value) {\r\n        return modifyAndRoundToNearestAuto(value, true);\r\n    }\r\n\r\n    /**\r\n     * Return the 'nearest rounded' value automatically by subtracting the calculated offset to the initial value.\r\n     *\r\n     * @param {number} value\r\n     * @returns {*}\r\n     */\r\n    function subtractAndRoundToNearestAuto(value) {\r\n        return modifyAndRoundToNearestAuto(value, false);\r\n    }\r\n\r\n    // autoNumeric-specific functions\r\n\r\n    /**\r\n     * Run any callbacks found in the settings object.\r\n     * Any parameter could be a callback:\r\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     */\r\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\r\n        // Loops through the settings object (option array) to find the following\r\n        $.each(settings, (k, val) => {\r\n            if (typeof val === 'function') {\r\n                settings[k] = val($this, settings, k);\r\n            } else if (typeof $this.autoNumeric[val] === 'function') {\r\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\r\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\r\n     *\r\n     * @param {string} minimumValue\r\n     * @param {string} maximumValue\r\n     * @returns {number}\r\n     */\r\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\r\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\r\n    }\r\n\r\n    /**\r\n     * Strip all unwanted non-number characters.\r\n     * This keeps the numbers, the negative sign as well as the custom decimal character.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} leftOrAll\r\n     * @returns {string|*}\r\n     */\r\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\r\n        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\r\n        //TODO Refactor this with `convertToNumericString()` if possible?\r\n        if (settings.currencySymbol !== '') {\r\n            // Remove currency sign\r\n            s = s.replace(settings.currencySymbol, '');\r\n        }\r\n        if (settings.suffixText) {\r\n            // Remove suffix\r\n            while (contains(s, settings.suffixText)) {\r\n                s = s.replace(settings.suffixText, '');\r\n            }\r\n        }\r\n\r\n        // First replace anything before digits\r\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\r\n\r\n        if ((settings.negativePositiveSignPlacement === 's' ||\r\n            (settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p')) &&\r\n            isNegative(s) &&\r\n            s !== '') {\r\n            settings.trailingNegative = true;\r\n        }\r\n\r\n        // Then replace anything after digits\r\n        s = s.replace(settings.skipLastAutoStrip, '$1');\r\n\r\n        // Then remove any uninteresting characters\r\n        s = s.replace(settings.allowedAutoStrip, '');\r\n        if (settings.decimalCharacterAlternative) {\r\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\r\n        }\r\n\r\n        // Get only number string\r\n        const m = s.match(settings.numRegAutoStrip);\r\n        s = m ? [m[1], m[2], m[3]].join('') : '';\r\n\r\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\r\n            let nSign = '';\r\n            const [integerPart, decimalPart] = s.split(settings.decimalCharacter);\r\n            let modifiedIntegerPart = integerPart;\r\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\r\n                nSign = settings.negativeSignCharacter;\r\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\r\n            }\r\n\r\n            // Strip leading zero on positive value if need\r\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\r\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\r\n            }\r\n\r\n            // Strip leading zero on negative value if need\r\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\r\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\r\n            }\r\n\r\n            s = `${nSign}${modifiedIntegerPart}${isUndefined(decimalPart)?'':settings.decimalCharacter + decimalPart}`;\r\n        }\r\n\r\n        if ((leftOrAll && settings.leadingZero === 'deny') ||\r\n            (!settings.hasFocus && settings.leadingZero === 'allow')) {\r\n            s = s.replace(settings.stripReg, '$1$2');\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Sets or removes brackets on negative values, depending on the focus state.\r\n     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\r\n     * //TODO Use another object to keep track of internal data that are not settings\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function toggleNegativeBracket(s, settings) {\r\n        if ((settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l') ||\r\n            (settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p')) {\r\n            //TODO Split the first and last bracket only once during the settings initialization\r\n            const [firstBracket, lastBracket] = settings.negativeBracketsTypeOnBlur.split(',');\r\n            if (!settings.hasFocus) {\r\n                // Add brackets\r\n                s = s.replace(settings.negativeSignCharacter, '');\r\n                s = firstBracket + s + lastBracket;\r\n            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\r\n                // Remove brackets\r\n                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\r\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\r\n                s = s.replace(lastBracket, '');\r\n            }\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\r\n     *\r\n     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\r\n     * Lastly, it also put the negative sign back to its normal position if needed.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string|void|XML|*}\r\n     */\r\n    function convertToNumericString(s, settings) {\r\n        // Remove the currency symbol\r\n        s = s.replace(settings.currencySymbol, '');\r\n\r\n        // Remove the grouping separators (thousands separators usually)\r\n        s = s.replace(settings.digitGroupSeparator, '');\r\n\r\n        // Replace the decimal character by a dot\r\n        if (settings.decimalCharacter !== '.') {\r\n            s = s.replace(settings.decimalCharacter, '.');\r\n        }\r\n\r\n        // Move the trailing negative sign to the right position, if any\r\n        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\r\n            s = s.replace('-', '');\r\n            s = '-' + s;\r\n        }\r\n\r\n        // Convert any arabic numbers to latin ones\r\n        const temp = arabicToLatinNumbers(s, true, false, false);\r\n        if (!isNaN(temp)) {\r\n            s = temp.toString();\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n     * See the \"outputFormat\" option definition for more details.\r\n     *\r\n     * @param {string|null} value\r\n     * @param {string} locale\r\n     * @returns {*}\r\n     */\r\n    function toLocale(value, locale) {\r\n        if (isNull(locale) || locale === 'string') {\r\n            return value;\r\n        }\r\n\r\n        let result;\r\n        switch (locale) {\r\n            case 'number':\r\n                result = Number(value);\r\n                break;\r\n            case '.-':\r\n                result = isNegative(value) ? value.replace('-', '') + '-' : value;\r\n                break;\r\n            case ',':\r\n            case '-,':\r\n                result = value.replace('.', ',');\r\n                break;\r\n            case ',-':\r\n                result = value.replace('.', ',');\r\n                result = isNegative(result) ? result.replace('-', '') + '-' : result;\r\n                break;\r\n            // The default case\r\n            case '.':\r\n            case '-.':\r\n                result = value;\r\n                break;\r\n            default :\r\n                throwError(`The given outputFormat [${locale}] option is not recognized.`);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\r\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\r\n        if (settings.decimalCharacter !== '.') {\r\n            s = s.replace(settings.decimalCharacter, '.');\r\n        }\r\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\r\n            s = s.replace(settings.negativeSignCharacter, '-');\r\n        }\r\n        if (!s.match(/\\d/)) {\r\n            // The default value returned by `get` is not formatted with decimals\r\n            s += '0';\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Modify the negative sign and the decimal character to use those defined in the settings.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\r\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\r\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\r\n            s = s.replace('-', settings.negativeSignCharacter);\r\n        }\r\n        if (settings.decimalCharacter !== '.') {\r\n            s = s.replace('.', settings.decimalCharacter);\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Private function to check for empty value\r\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @param {boolean} signOnEmpty\r\n     * @returns {*}\r\n     */\r\n    function checkEmpty(inputValue, settings, signOnEmpty) {\r\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\r\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\r\n                return (settings.negativePositiveSignPlacement === 'l') ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\r\n            }\r\n\r\n            return inputValue;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Modify the input value by adding the group separators, as defined in the settings.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function addGroupSeparators(inputValue, settings) {\r\n        if (settings.strip) {\r\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\r\n        }\r\n\r\n        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\r\n        if (settings.trailingNegative && !isNegative(inputValue)) {\r\n            inputValue = '-' + inputValue;\r\n        }\r\n\r\n        const empty = checkEmpty(inputValue, settings, true);\r\n        const isValueNegative = isNegative(inputValue);\r\n        const isZero = isZeroOrHasNoValue(inputValue);\r\n        if (isValueNegative) {\r\n            inputValue = inputValue.replace('-', '');\r\n        }\r\n\r\n        if (!isNull(empty)) {\r\n            return empty;\r\n        }\r\n\r\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\r\n        let digitalGroup;\r\n        switch (settings.digitalGroupSpacing) {\r\n            case '2':\r\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\r\n                break;\r\n            case '2s':\r\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\r\n                break;\r\n            case '4':\r\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\r\n                break;\r\n            default :\r\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\r\n        }\r\n\r\n        // Splits the string at the decimal string\r\n        let [integerPart, decimalPart] = inputValue.split(settings.decimalCharacter);\r\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\r\n            [integerPart, decimalPart] = inputValue.split(settings.decimalCharacterAlternative);\r\n        }\r\n\r\n        if (settings.digitGroupSeparator !== '') {\r\n            // Re-inserts the thousand separator via a regular expression\r\n            while (digitalGroup.test(integerPart)) {\r\n                integerPart = integerPart.replace(digitalGroup, `$1${settings.digitGroupSeparator}$2`);\r\n            }\r\n        }\r\n\r\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\r\n            if (decimalPart.length > settings.decimalPlacesOverride) {\r\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\r\n            }\r\n\r\n            // Joins the whole number with the decimal value\r\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\r\n        } else {\r\n            // Otherwise if it's an integer\r\n            inputValue = integerPart;\r\n        }\r\n\r\n        settings.trailingNegative = false;\r\n\r\n        if (settings.currencySymbolPlacement === 'p') {\r\n            if (isValueNegative) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'l':\r\n                        inputValue = `${settings.negativeSignCharacter}${settings.currencySymbol}${inputValue}`;\r\n                        break;\r\n                    case 'r':\r\n                        inputValue = `${settings.currencySymbol}${settings.negativeSignCharacter}${inputValue}`;\r\n                        break;\r\n                    case 's':\r\n                        inputValue = `${settings.currencySymbol}${inputValue}${settings.negativeSignCharacter}`;\r\n                        settings.trailingNegative = true;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else if (settings.showPositiveSign && !isZero) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'l':\r\n                        inputValue = `${settings.positiveSignCharacter}${settings.currencySymbol}${inputValue}`;\r\n                        break;\r\n                    case 'r':\r\n                        inputValue = `${settings.currencySymbol}${settings.positiveSignCharacter}${inputValue}`;\r\n                        break;\r\n                    case 's':\r\n                        inputValue = `${settings.currencySymbol}${inputValue}${settings.positiveSignCharacter}`;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else {\r\n                inputValue = settings.currencySymbol + inputValue;\r\n            }\r\n        }\r\n\r\n        if (settings.currencySymbolPlacement === 's') {\r\n            if (isValueNegative) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'r':\r\n                        inputValue = `${inputValue}${settings.currencySymbol}${settings.negativeSignCharacter}`;\r\n                        settings.trailingNegative = true;\r\n                        break;\r\n                    case 'l':\r\n                        inputValue = `${inputValue}${settings.negativeSignCharacter}${settings.currencySymbol}`;\r\n                        settings.trailingNegative = true;\r\n                        break;\r\n                    case 'p':\r\n                        inputValue = `${settings.negativeSignCharacter}${inputValue}${settings.currencySymbol}`;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else if (settings.showPositiveSign && !isZero) {\r\n                switch (settings.negativePositiveSignPlacement) {\r\n                    case 'r':\r\n                        inputValue = `${inputValue}${settings.currencySymbol}${settings.positiveSignCharacter}`;\r\n                        break;\r\n                    case 'l':\r\n                        inputValue = `${inputValue}${settings.positiveSignCharacter}${settings.currencySymbol}`;\r\n                        break;\r\n                    case 'p':\r\n                        inputValue = `${settings.positiveSignCharacter}${inputValue}${settings.currencySymbol}`;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else {\r\n                inputValue = inputValue + settings.currencySymbol;\r\n            }\r\n        }\r\n\r\n        // Removes the negative sign and places brackets\r\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\r\n            inputValue = toggleNegativeBracket(inputValue, settings);\r\n        }\r\n\r\n        return inputValue + settings.suffixText;\r\n    }\r\n\r\n    /**\r\n     * Truncate not needed zeros\r\n     *\r\n     * @param {string} roundedInputValue\r\n     * @param {int} temporaryDecimalPlacesOverride\r\n     * @returns {void|XML|string|*}\r\n     */\r\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\r\n        let regex;\r\n        switch (temporaryDecimalPlacesOverride) {\r\n            case 0:\r\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\r\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\r\n                break;\r\n            case 1:\r\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\r\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\r\n                break;\r\n            default :\r\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\r\n                regex = new RegExp(`(\\\\.\\\\d{${temporaryDecimalPlacesOverride}}(?:\\\\d*[1-9])?)0*`);\r\n        }\r\n\r\n        // If there are no decimal places, we don't need a decimal point at the end\r\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\r\n        if (temporaryDecimalPlacesOverride === 0) {\r\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\r\n        }\r\n\r\n        return roundedInputValue;\r\n    }\r\n\r\n    /**\r\n     * Round the input value using the rounding method defined in the settings.\r\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\r\n     *\r\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function roundValue(inputValue, settings) {\r\n        inputValue = (inputValue === '') ? '0' : inputValue.toString();\r\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\r\n            switch (settings.roundingMethod) {\r\n                case 'N05':\r\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\r\n                    break;\r\n                case 'U05':\r\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\r\n                    break;\r\n                default :\r\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\r\n            }\r\n\r\n            let result;\r\n            if (!contains(inputValue, '.')) {\r\n                result = inputValue + '.00';\r\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\r\n                result = inputValue + '0';\r\n            } else {\r\n                result = inputValue;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        let ivRounded = '';\r\n        let i = 0;\r\n        let nSign = '';\r\n        let temporaryDecimalPlacesOverride;\r\n\r\n        // sets the truncate zero method\r\n        if (settings.allowDecimalPadding) {\r\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\r\n        } else {\r\n            temporaryDecimalPlacesOverride = 0;\r\n        }\r\n\r\n        // Checks if the inputValue (input Value) is a negative value\r\n        if (isNegativeStrict(inputValue)) {\r\n            nSign = '-';\r\n\r\n            // Removes the negative sign that will be added back later if required\r\n            inputValue = inputValue.replace('-', '');\r\n        }\r\n\r\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\r\n        if (!inputValue.match(/^\\d/)) {\r\n            inputValue = '0' + inputValue;\r\n        }\r\n\r\n        // Determines if the value is equal to zero. If it is, remove the negative sign\r\n        if (Number(inputValue) === 0) {\r\n            nSign = '';\r\n        }\r\n\r\n        // Trims leading zero's as needed\r\n        if ((Number(inputValue) > 0 && settings.leadingZero !== 'keep') || (inputValue.length > 0 && settings.leadingZero === 'allow')) {\r\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\r\n        }\r\n\r\n        const dPos = inputValue.lastIndexOf('.');\r\n        const inputValueHasADot = dPos === -1;\r\n\r\n        // Virtual decimal position\r\n        const vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\r\n\r\n        // Checks decimal places to determine if rounding is required :\r\n        // Check if no rounding is required\r\n        let cDec = (inputValue.length - 1) - vdPos;\r\n\r\n        if (cDec <= settings.decimalPlacesOverride) {\r\n            // Check if we need to pad with zeros\r\n            ivRounded = inputValue;\r\n            if (cDec < temporaryDecimalPlacesOverride) {\r\n                if (inputValueHasADot) {\r\n                    ivRounded += settings.decimalCharacter;\r\n                }\r\n\r\n                let zeros = '000000';\r\n                while (cDec < temporaryDecimalPlacesOverride) {\r\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\r\n                    ivRounded += zeros;\r\n                    cDec += zeros.length;\r\n                }\r\n            } else if (cDec > temporaryDecimalPlacesOverride) {\r\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\r\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\r\n                ivRounded = ivRounded.replace(/\\.$/, '');\r\n            }\r\n\r\n            return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\r\n        }\r\n\r\n        // Rounded length of the string after rounding\r\n        let rLength;\r\n        if (inputValueHasADot) {\r\n            rLength = settings.decimalPlacesOverride - 1;\r\n        } else {\r\n            rLength = settings.decimalPlacesOverride + dPos;\r\n        }\r\n\r\n        const tRound = Number(inputValue.charAt(rLength + 1));\r\n        const odd = (inputValue.charAt(rLength) === '.') ? (inputValue.charAt(rLength - 1) % 2) : (inputValue.charAt(rLength) % 2);\r\n        let ivArray = inputValue.substring(0, rLength + 1).split('');\r\n\r\n        if ((tRound > 4 && settings.roundingMethod === 'S')                  || // Round half up symmetric\r\n            (tRound > 4 && settings.roundingMethod === 'A' && nSign === '')  || // Round half up asymmetric positive values\r\n            (tRound > 5 && settings.roundingMethod === 'A' && nSign === '-') || // Round half up asymmetric negative values\r\n            (tRound > 5 && settings.roundingMethod === 's')                  || // Round half down symmetric\r\n            (tRound > 5 && settings.roundingMethod === 'a' && nSign === '')  || // Round half down asymmetric positive values\r\n            (tRound > 4 && settings.roundingMethod === 'a' && nSign === '-') || // Round half down asymmetric negative values\r\n            (tRound > 5 && settings.roundingMethod === 'B')                  || // Round half even \"Banker's Rounding\"\r\n            (tRound === 5 && settings.roundingMethod === 'B' && odd === 1)   || // Round half even \"Banker's Rounding\"\r\n            (tRound > 0 && settings.roundingMethod === 'C' && nSign === '')  || // Round to ceiling toward positive infinite\r\n            (tRound > 0 && settings.roundingMethod === 'F' && nSign === '-') || // Round to floor toward negative infinite\r\n            (tRound > 0 && settings.roundingMethod === 'U')) {                  // Round up away from zero\r\n            // Round up the last digit if required, and continue until no more 9's are found\r\n            for (i = (ivArray.length - 1); i >= 0; i -= 1) {\r\n                if (ivArray[i] !== '.') {\r\n                    ivArray[i] = +ivArray[i] + 1;\r\n                    if (ivArray[i] < 10) {\r\n                        break;\r\n                    }\r\n\r\n                    if (i > 0) {\r\n                        ivArray[i] = '0';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reconstruct the string, converting any 10's to 0's\r\n        ivArray = ivArray.slice(0, rLength + 1);\r\n\r\n        // Return the rounded value\r\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\r\n\r\n        return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\r\n    }\r\n\r\n    /**\r\n     * Truncates the decimal part of a number.\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {boolean} isPaste\r\n     * @returns {*}\r\n     */\r\n    function truncateDecimal(s, settings, isPaste) {\r\n        s = (isPaste) ? roundValue(s, settings) : s;\r\n\r\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\r\n            const [integerPart, decimalPart] = s.split(settings.decimalCharacter);\r\n\r\n            // truncate decimal part to satisfying length since we would round it anyway\r\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\r\n                if (settings.decimalPlacesOverride > 0) {\r\n                    const modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\r\n                    s = `${integerPart}${settings.decimalCharacter}${modifiedDecimalPart}`;\r\n                } else {\r\n                    s = integerPart;\r\n                }\r\n            }\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\r\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {number|string} n A numeric value.\r\n     * @returns {{}}\r\n     */\r\n    function parseStr(n) {\r\n        const x = {}; // A Big number instance.\r\n        let e;\r\n        let i;\r\n        let nL;\r\n        let j;\r\n\r\n        // Minus zero?\r\n        if (n === 0 && 1 / n < 0) {\r\n            n = '-0';\r\n        }\r\n\r\n        // Determine sign. 1 positive, -1 negative\r\n        n = n.toString();\r\n        if (isNegativeStrict(n)) {\r\n            n = n.slice(1);\r\n            x.s = -1;\r\n        } else {\r\n            x.s = 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        e = n.indexOf('.');\r\n        if (e > -1) {\r\n            n = n.replace('.', '');\r\n        }\r\n\r\n        // length of string if no decimal character\r\n        if (e < 0) {\r\n            // Integer\r\n            e = n.length;\r\n        }\r\n\r\n        // Determine leading zeros\r\n        i = (n.search(/[1-9]/i) === -1) ? n.length : n.search(/[1-9]/i);\r\n        nL = n.length;\r\n        if (i === nL) {\r\n            // Zero\r\n            x.e = 0;\r\n            x.c = [0];\r\n        } else {\r\n            // Determine trailing zeros\r\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\r\n                nL -= 1;\r\n            }\r\n            nL -= 1;\r\n\r\n            // Decimal location\r\n            x.e = e - i - 1;\r\n            x.c = [];\r\n\r\n            // Convert string to array of digits without leading/trailing zeros\r\n            for (e = 0; i <= nL; i += 1) {\r\n                x.c[e] = +n.charAt(i);\r\n                e += 1;\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Function to test if the input value falls with the Min / Max settings.\r\n     * This uses the parsed strings for the above parseStr function.\r\n     *\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\r\n     *\r\n     * @param {object} y Big number instance\r\n     * @param {object} x Big number instance\r\n     * @returns {*}\r\n     */\r\n    function testMinMax(y, x) {\r\n        const xc = x.c;\r\n        const yc = y.c;\r\n        let i = x.s;\r\n        let j = y.s;\r\n        let k = x.e;\r\n        let l = y.e;\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n            let result;\r\n            if (!xc[0]) {\r\n                result = !yc[0]?0:-j;\r\n            } else {\r\n                result = i;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Signs differ?\r\n        if (i !== j) {\r\n            return i;\r\n        }\r\n        const xNeg = i < 0;\r\n\r\n        // Compare exponents\r\n        if (k !== l) {\r\n            return (k > l ^ xNeg)?1:-1;\r\n        }\r\n        i = -1;\r\n        k = xc.length;\r\n        l = yc.length;\r\n        j = (k < l) ? k : l;\r\n\r\n        // Compare digit by digit\r\n        for (i += 1; i < j; i += 1) {\r\n            if (xc[i] !== yc[i]) {\r\n                return (xc[i] > yc[i] ^ xNeg)?1:-1;\r\n            }\r\n        }\r\n\r\n        // Compare lengths\r\n        let result;\r\n        if (k === l) {\r\n            result = 0;\r\n        } else {\r\n            result = (k > l ^ xNeg)?1:-1;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check that the number satisfy the format conditions\r\n     * and lays between settings.minimumValue and settings.maximumValue\r\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\r\n    function checkIfInRangeWithOverrideOption(s, settings) {\r\n        s = s.toString();\r\n        s = s.replace(',', '.');\r\n        const minParse = parseStr(settings.minimumValue);\r\n        const maxParse = parseStr(settings.maximumValue);\r\n        const valParse = parseStr(s);\r\n\r\n        let result;\r\n        switch (settings.overrideMinMaxLimits) {\r\n            case 'floor':\r\n                result = [testMinMax(minParse, valParse) > -1, true];\r\n                break;\r\n            case 'ceiling':\r\n                result = [true, testMinMax(maxParse, valParse) < 1];\r\n                break;\r\n            case 'ignore':\r\n                result = [true, true];\r\n                break;\r\n            default:\r\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Thanks to Anthony & Evan C\r\n     *\r\n     * @param {Element|string} element\r\n     * @returns {*|jQuery|HTMLElement}\r\n     */\r\n    function getCurrentElement(element) {\r\n        /*\r\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\r\n         * for jQuery to be able to parse the selector correctly.\r\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\r\n         */\r\n        if (isString(element)) {\r\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\r\n            element = `#${element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1')}`;\r\n        }\r\n\r\n        return $(element);\r\n    }\r\n\r\n    /**\r\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {object} settings\r\n     * @param {boolean} update\r\n     * @returns {*}\r\n     */\r\n    function getAutoNumericHolder($this, settings, update = false) {\r\n        let data = $this.data('autoNumeric');\r\n        if (!data) {\r\n            data = {};\r\n            $this.data('autoNumeric', data);\r\n        }\r\n\r\n        let holder = data.holder;\r\n        if (update || (isUndefined(holder) && settings)) {\r\n            holder = new AutoNumericHolder($this.get(0), settings);\r\n            data.holder = holder;\r\n        }\r\n\r\n        return holder;\r\n    }\r\n\r\n    /**\r\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\r\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function keepAnOriginalSettingsCopy(settings) {\r\n        //TODO Rename the old option names to the new ones\r\n        settings.oDec     = settings.decimalPlacesOverride;\r\n        settings.oPad     = settings.allowDecimalPadding;\r\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\r\n        settings.oSep     = settings.digitGroupSeparator;\r\n        settings.oSign    = settings.currencySymbol;\r\n        settings.oSuffix  = settings.suffixText;\r\n    }\r\n\r\n    /**\r\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\r\n     * This is taken from Quirksmode.\r\n     *\r\n     * @param {string} name\r\n     * @returns {*}\r\n     */\r\n    function readCookie(name) {\r\n        const nameEQ = name + '=';\r\n        const ca = document.cookie.split(';');\r\n        let c = '';\r\n        for (let i = 0; i < ca.length; i += 1) {\r\n            c = ca[i];\r\n            while (c.charAt(0) === ' ') {\r\n                c = c.substring(1, c.length);\r\n            }\r\n            if (c.indexOf(nameEQ) === 0) {\r\n                return c.substring(nameEQ.length, c.length);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test if sessionStorage is supported.\r\n     * This is taken from Modernizr.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function storageTest() {\r\n        const mod = 'modernizr';\r\n        try {\r\n            sessionStorage.setItem(mod, mod);\r\n            sessionStorage.removeItem(mod);\r\n            return true;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * properly formats the string to a numeric when leadingZero does not 'keep'.\r\n     *\r\n     * @param {string} value\r\n     * @param {object} settings\r\n     * @returns {string}\r\n     */\r\n    function cleanLeadingTrailingZeros(value, settings) {\r\n        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\r\n        if (value === '') {\r\n            return '';\r\n        }\r\n\r\n        // Return '0' if the value is zero\r\n        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\r\n            return '0';\r\n        }\r\n\r\n        if (settings.leadingZero !== 'keep') {\r\n            // Trim leading zero's - leaves one zero to the left of the decimal point\r\n            value = value.replace(/^(-)?0+(?=\\d)/g,'$1');\r\n\r\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\r\n            if (contains(value, '.')) {\r\n                // Trims trailing zeros after the decimal point\r\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\r\n            }\r\n        }\r\n        // Strips trailing decimal point\r\n        value = value.replace(/\\.$/, '');\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Remove the trailing zeros in the decimal part of a number.\r\n     *\r\n     * @param {string} numericString\r\n     * @returns {*}\r\n     */\r\n    function trimPaddedZerosFromDecimalPlaces(numericString) {\r\n        const [integerPart, decimalPart] = numericString.split('.');\r\n        if (isUndefinedOrNullOrEmpty(decimalPart)) {\r\n            return integerPart;\r\n        }\r\n\r\n        const trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\r\n\r\n        let result;\r\n        if (trimmedDecimalPart === '') {\r\n            result = integerPart;\r\n        } else {\r\n            result = `${integerPart}.${trimmedDecimalPart}`;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\r\n     *\r\n     * @param {Element|EventTarget} element\r\n     * @param {object} settings\r\n     * @param {string} action\r\n     * @returns {*}\r\n     */\r\n    function saveValueToPersistentStorage(element, settings, action) {\r\n        if (settings.saveValueToSessionStorage) {\r\n            const storedName = (element.name !== '' && !isUndefined(element.name)) ?`AUTO_${decodeURIComponent(element.name)}` :`AUTO_${element.id}`;\r\n            let date;\r\n            let expires;\r\n\r\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\r\n            if (storageTest() === false) {\r\n                switch (action) {\r\n                    case 'set':\r\n                        document.cookie = `${storedName}=${settings.rawValue}; expires= ; path=/`;\r\n                        break;\r\n                    case 'wipe':\r\n                        date = new Date();\r\n                        date.setTime(date.getTime() + (-1 * 24 * 60 * 60 * 1000));\r\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\r\n                        document.cookie = `${storedName}='' ;${expires}; path=/`;\r\n                        break;\r\n                    case 'get':\r\n                        return readCookie(storedName);\r\n                }\r\n            } else {\r\n                switch (action) {\r\n                    case 'set':\r\n                        sessionStorage.setItem(storedName, settings.rawValue);\r\n                        break;\r\n                    case 'wipe':\r\n                        sessionStorage.removeItem(storedName);\r\n                        break;\r\n                    case 'get':\r\n                        return sessionStorage.getItem(storedName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Holder object for field properties\r\n     */\r\n    class AutoNumericHolder {\r\n        /**\r\n         * Class constructor\r\n         *\r\n         * @param {HTMLElement} that - A reference to the current DOM element\r\n         * @param {object} settings\r\n         */\r\n        constructor(that, settings) {\r\n            this.settings = settings;\r\n            this.that = that;\r\n            this.$that = $(that);\r\n            this.formatted = false;\r\n            this.settingsClone = settings;\r\n            this.value = that.value;\r\n            // Note: This variable is needed and not a duplicate of `initialValueOnKeydown` nor `valueOnFocus` since it serves a different purpose and has a different lifecycle\r\n            this.savedCancellableValue = null;\r\n        }\r\n\r\n        /**\r\n         * Update the value and the selection values inside the AutoNumericHolder object.\r\n         * This keeps tracks of the input value, as well as the current selection.\r\n         * This also resets the 'processed' and 'formatted' state.\r\n         *\r\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\r\n         *        this function is called on each event handler.\r\n         *\r\n         * @private\r\n         */\r\n        _updateAutoNumericHolderProperties() {\r\n            this.value = this.that.value;\r\n            this.selection = getElementSelection(this.that);\r\n            this.processed = false;\r\n            this.formatted = false;\r\n        }\r\n\r\n        /**\r\n         * Update the keycode of the key that triggered the given event.\r\n         * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\r\n         *\r\n         * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\r\n         * e.key describe the key name used to trigger the event.\r\n         * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\r\n         * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n         * The key list is described here\r\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n         *\r\n         * @param {Event} e\r\n         * @private\r\n         */\r\n        _updateAutoNumericHolderEventKeycode(e) {\r\n            // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\r\n            this.eventKeyCode = keyCodeNumber(e);\r\n        }\r\n\r\n        /**\r\n         * Save the unformatted element value.\r\n         * This is used in the 'cancellable' feature where the element value is saved on focus and input validation, to be used if the user wants to cancel his modifications by hitting the 'Escape' key.\r\n         *\r\n         * @private\r\n         */\r\n        _saveCancellableValue() {\r\n            this.savedCancellableValue = this.settings.rawValue;\r\n        }\r\n\r\n        /**\r\n         * Set the text selection inside the input with the given start and end position.\r\n         *\r\n         * @param {int} start\r\n         * @param {int} end\r\n         * @param {undefined|boolean} setReal\r\n         * @private\r\n         */\r\n        _setSelection(start, end, setReal) {\r\n            //TODO Modify setReal to be more explicit (and a boolean)\r\n            start = Math.max(start, 0);\r\n            end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\r\n            this.selection = {\r\n                start,\r\n                end,\r\n                length: end - start,\r\n            };\r\n\r\n            if (isUndefined(setReal) || setReal) {\r\n                setElementSelection(this.that, start, end);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the caret position inside the input at the given position.\r\n         *\r\n         * @param {int} pos\r\n         * @param {undefined|boolean} setReal\r\n         * @private\r\n         */\r\n        _setCaretPosition(pos, setReal) {\r\n            //TODO Modify setReal to be more explicit (and a boolean)\r\n            this._setSelection(pos, pos, setReal);\r\n        }\r\n\r\n        /**\r\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n         * Those parts are left 'untouched', ie. formatted by autoNumeric.\r\n         *\r\n         * @returns {[string, string]} The parts on the left and right of the caret or selection\r\n         * @private\r\n         */\r\n        _getLeftAndRightPartAroundTheSelection() {\r\n            const value = this.value;\r\n            const left = value.substring(0, this.selection.start);\r\n            const right = value.substring(this.selection.end, value.length);\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\r\n         * Those parts are unformatted (stripped) of any non-numbers characters.\r\n         *\r\n         * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\r\n         * @private\r\n         */\r\n        _getUnformattedLeftAndRightPartAroundTheSelection() {\r\n            const settingsClone = this.settingsClone;\r\n            let [left, right] = this._getLeftAndRightPartAroundTheSelection();\r\n            if (left === '' && right === '') {\r\n                settingsClone.trailingNegative = false;\r\n            }\r\n            // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\r\n            let stripZeros = true;\r\n            if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\r\n                stripZeros = false;\r\n            }\r\n            left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\r\n            right = stripAllNonNumberCharacters(right, this.settingsClone, false);\r\n\r\n            if (settingsClone.trailingNegative && !isNegative(left)) {\r\n                left = '-' + left;\r\n                right = (right === '-') ? '' : right;\r\n                settingsClone.trailingNegative = false;\r\n            }\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Strip parts from excess characters and leading zeros.\r\n         *\r\n         * @param {string} left\r\n         * @param {string} right\r\n         * @returns {[*,*]}\r\n         * @private\r\n         */\r\n        _normalizeParts(left, right) {\r\n            const settingsClone = this.settingsClone;\r\n\r\n            // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\r\n            let stripZeros = true;\r\n            if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\r\n                stripZeros = false;\r\n            }\r\n            left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\r\n\r\n            // If right is not empty and first character is not decimalCharacter\r\n            right = stripAllNonNumberCharacters(right, settingsClone, false);\r\n\r\n            // Prevents multiple leading zeros from being entered\r\n            if (settingsClone.leadingZero === 'deny' &&\r\n                (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) &&\r\n                Number(left) === 0 &&\r\n                !contains(left, settingsClone.decimalCharacter)  && right !== '') {\r\n                left = left.substring(0, left.length - 1);\r\n            }\r\n\r\n            if (settingsClone.trailingNegative && !isNegative(left)) {\r\n                left = '-' + left;\r\n                settingsClone.trailingNegative = false;\r\n            }\r\n\r\n            // Insert zero if has leading dot\r\n            this.newValue = left + right;\r\n            if (settingsClone.decimalCharacter) {\r\n                const m = this.newValue.match(new RegExp(`^${settingsClone.aNegRegAutoStrip}\\\\${settingsClone.decimalCharacter}`));\r\n                if (m) {\r\n                    left = left.replace(m[1], m[1] + '0');\r\n                    this.newValue = left + right;\r\n                }\r\n            }\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\r\n         *\r\n         * @param {string} left\r\n         * @param {string} right\r\n         * @param {boolean} isPaste\r\n         * @returns {boolean}\r\n         * @private\r\n         */\r\n        _setValueParts(left, right, isPaste = false) {\r\n            const settingsClone = this.settingsClone;\r\n            const parts = this._normalizeParts(left, right);\r\n            const [minTest, maxTest] = checkIfInRangeWithOverrideOption(this.newValue, settingsClone);\r\n            let position = parts[0].length;\r\n            this.newValue = parts.join('');\r\n\r\n            if (minTest && maxTest) {\r\n                this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\r\n                //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\r\n                const testValue = (contains(this.newValue, ',')) ? this.newValue.replace(',', '.') : this.newValue;\r\n                if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\r\n                    settingsClone.rawValue = (settingsClone.emptyInputBehavior === 'zero') ? '0' : '';\r\n                } else {\r\n                    settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\r\n                }\r\n\r\n                if (position > this.newValue.length) {\r\n                    position = this.newValue.length;\r\n                }\r\n\r\n                // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\r\n                if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\r\n                    // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\r\n                    if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\r\n                        position = 1;\r\n                    } else {\r\n                        position = 0;\r\n                    }\r\n                }\r\n\r\n                this.value = this.newValue;\r\n                this._setCaretPosition(position, false);\r\n\r\n                return true;\r\n            }\r\n\r\n            if (!minTest) {\r\n                this.$that.trigger('autoNumeric:minExceeded');\r\n            } else if (!maxTest) {\r\n                this.$that.trigger('autoNumeric:maxExceeded');\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Helper function for `_expandSelectionOnSign()`.\r\n         *\r\n         * @returns {*} Sign position of a formatted value\r\n         * @private\r\n         */\r\n        _getSignPosition() {\r\n            const settingsClone = this.settingsClone;\r\n            const currencySymbol = settingsClone.currencySymbol;\r\n            const that = this.that;\r\n\r\n            if (currencySymbol) {\r\n                const currencySymbolLen = currencySymbol.length;\r\n                if (settingsClone.currencySymbolPlacement === 'p') {\r\n                    const hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\r\n                    return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\r\n                }\r\n                const valueLen = that.value.length;\r\n                return [valueLen - currencySymbolLen, valueLen];\r\n            }\r\n\r\n            return [1000, -1];\r\n        }\r\n\r\n        /**\r\n         * Expands selection to cover whole sign\r\n         * Prevents partial deletion/copying/overwriting of a sign\r\n         *\r\n         * @param {undefined|boolean} setReal\r\n         * @private\r\n         */\r\n        _expandSelectionOnSign(setReal) {\r\n            //TODO Modify setReal to be more explicit (and a boolean only)\r\n            //TODO Use array destructuring here to set signPosition to more explicit variables\r\n            const signPosition = this._getSignPosition();\r\n            const selection = this.selection;\r\n\r\n            // If selection catches something except sign and catches only space from sign\r\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\r\n                // Then select without empty space\r\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\r\n                    if (selection.start < signPosition[0]) {\r\n                        this._setSelection(selection.start, signPosition[0], setReal);\r\n                    } else {\r\n                        this._setSelection(signPosition[1], selection.end, setReal);\r\n                    }\r\n                } else {\r\n                    // Else select with whole sign\r\n                    this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Try to strip pasted value to digits\r\n         */\r\n        _checkPaste() {\r\n            if (!isUndefined(this.valuePartsBeforePaste)) {\r\n                const oldParts = this.valuePartsBeforePaste;\r\n                const [left, right] = this._getLeftAndRightPartAroundTheSelection();\r\n\r\n                // Try to strip the pasted value first\r\n                delete this.valuePartsBeforePaste;\r\n\r\n                const modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\r\n                if (!this._setValueParts(modifiedLeftPart, right, true)) {\r\n                    this.value = oldParts.join('');\r\n                    this._setCaretPosition(oldParts[0].length, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Process pasting, cursor moving and skipping of not interesting keys.\r\n         * If this function returns TRUE, then further processing is not performed.\r\n         *\r\n         * @param {Event} e\r\n         * @returns {boolean}\r\n         * @private\r\n         */\r\n        _skipAlways(e) {\r\n            // Catch the ctrl up on ctrl-v\r\n            if (((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste)) || (e.shiftKey && this.eventKeyCode === keyCode.Insert)) {\r\n                //TODO Move this test inside the `onKeyup` handler\r\n                this._checkPaste();\r\n                return false;\r\n            }\r\n\r\n            // Skip all function keys (F1-F12), Windows keys, tab and other special keys\r\n            if ((this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12) ||\r\n                (this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick) ||\r\n                (this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space) ||\r\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\r\n                (this.eventKeyCode < keyCode.Backspace &&\r\n                (e.which === 0 || e.which === this.eventKeyCode)) ||\r\n                this.eventKeyCode === keyCode.NumLock ||\r\n                this.eventKeyCode === keyCode.ScrollLock ||\r\n                this.eventKeyCode === keyCode.Insert ||\r\n                this.eventKeyCode === keyCode.Command) {\r\n                return true;\r\n            }\r\n\r\n            // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\r\n            if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\r\n                if (this.settings.selectNumberOnly) {\r\n                    // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\r\n                    e.preventDefault();\r\n                    this._selectOnlyNumbers();\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\r\n            if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\r\n                if (e.type === 'keydown') {\r\n                    this._expandSelectionOnSign();\r\n                }\r\n\r\n                // Try to prevent wrong paste\r\n                if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\r\n                    if (e.type === 'keydown' || e.type === 'keypress') {\r\n                        if (isUndefined(this.valuePartsBeforePaste)) {\r\n                            this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\r\n                        }\r\n                    } else {\r\n                        this._checkPaste();\r\n                    }\r\n                }\r\n\r\n                return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\r\n            }\r\n\r\n            if (e.ctrlKey || e.metaKey) {\r\n                return true;\r\n            }\r\n\r\n            // Jump over thousand separator\r\n            //TODO Move this test inside the `onKeydown` handler\r\n            if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\r\n                if (e.type === 'keydown' && !e.shiftKey) {\r\n                    if (this.eventKeyCode === keyCode.LeftArrow &&\r\n                        (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator ||\r\n                        this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\r\n                        this._setCaretPosition(this.selection.start - 1);\r\n                    } else if (this.eventKeyCode === keyCode.RightArrow &&\r\n                        (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator ||\r\n                        this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\r\n                        this._setCaretPosition(this.selection.start + 1);\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n\r\n            return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\r\n        }\r\n\r\n        /**\r\n         * Select the whole element content, based on the `selectNumberOnly` option.\r\n         * @private\r\n         */\r\n        _select() {\r\n            if (this.settings.selectNumberOnly) {\r\n                this._selectOnlyNumbers();\r\n            } else {\r\n                this._defaultSelectAll();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Select the whole element content (including the currency symbol).\r\n         * @private\r\n         */\r\n        _defaultSelectAll() {\r\n            setElementSelection(this.that, 0, this.that.value.length);\r\n        }\r\n\r\n        /**\r\n         * Select only the numbers in the formatted input, leaving out the currency symbol.\r\n         * @private\r\n         */\r\n        _selectOnlyNumbers() {\r\n            const valueLen = this.that.value.length;\r\n            const currencySymbolLen = this.settings.currencySymbol.length;\r\n            const negLen = (!isNegative(this.that.value))?0:1;\r\n            const suffixTextLen = this.settings.suffixText.length;\r\n            const currencySymbolPlacement = this.settings.currencySymbolPlacement;\r\n            const negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\r\n\r\n            let start;\r\n            if (currencySymbolPlacement === 's') {\r\n                start = 0;\r\n            } else {\r\n                start = (negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0)?currencySymbolLen + 1:currencySymbolLen;\r\n            }\r\n\r\n            let end;\r\n            if (currencySymbolPlacement === 'p') {\r\n                end = valueLen - suffixTextLen;\r\n            } else {\r\n                switch (negativePositiveSignPlacement) {\r\n                    case 'l':\r\n                        end = valueLen - (suffixTextLen + currencySymbolLen);\r\n                        break;\r\n                    case 'r':\r\n                        end = (currencySymbolLen > 0)?valueLen - (currencySymbolLen + negLen + suffixTextLen):valueLen - (currencySymbolLen + suffixTextLen);\r\n                        break;\r\n                    default :\r\n                        end = valueLen - (currencySymbolLen + suffixTextLen);\r\n                }\r\n            }\r\n\r\n            setElementSelection(this.that, start, end);\r\n        }\r\n\r\n        /**\r\n         * Process deletion of characters when the minus sign is to the right of the numeric characters.\r\n         *\r\n         * @param {string} left The part on the left of the caret or selection\r\n         * @param {string} right The part on the right of the caret or selection\r\n         * @returns {[string, string]}\r\n         * @private\r\n         */\r\n        _processCharacterDeletionIfTrailingNegativeSign([left, right]) {\r\n            const settingsClone = this.settingsClone;\r\n            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\r\n                if (this.eventKeyCode === keyCode.Backspace) {\r\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '');\r\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\r\n                        left = left.substring(1);\r\n                    } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    }\r\n                } else {\r\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '');\r\n                    if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n                    if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\r\n                        left = left.substring(1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\r\n            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\r\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length);\r\n                if (this.eventKeyCode === keyCode.Backspace) {\r\n                    if (this.selection.start === (this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) && contains(this.value, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1);\r\n                    } else if (left !== '-' && ((this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter)) || !contains(this.value, settingsClone.negativeSignCharacter))) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    }\r\n                } else {\r\n                    if (left[0] === '-') {\r\n                        right = right.substring(1);\r\n                    }\r\n                    if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\r\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length);\r\n                if (this.eventKeyCode === keyCode.Backspace) {\r\n                    if (this.selection.start === (this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length)) {\r\n                        left = left.substring(1);\r\n                    } else if (left !== '-' && this.selection.start <= (this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length)) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    }\r\n                } else {\r\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '');\r\n                    if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1);\r\n                    }\r\n                    right = right.substring(1);\r\n                }\r\n            }\r\n\r\n            return [left, right];\r\n        }\r\n\r\n        /**\r\n         * Process the deletion of characters.\r\n         */\r\n        _processCharacterDeletion() {\r\n            const settingsClone = this.settingsClone;\r\n\r\n            let left;\r\n            let right;\r\n\r\n            if (!this.selection.length) {\r\n                [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n                if (left === '' && right === '') {\r\n                    settingsClone.throwInput = false;\r\n                }\r\n\r\n                if (((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') ||\r\n                    (settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r'))) &&\r\n                    isNegative(this.value)) { //TODO Change `this.value` to `this.that.value`?\r\n                    [left, right] = this._processCharacterDeletionIfTrailingNegativeSign([left, right]);\r\n                } else {\r\n                    if (this.eventKeyCode === keyCode.Backspace) {\r\n                        left = left.substring(0, left.length - 1);\r\n                    } else {\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n                }\r\n            } else {\r\n                this._expandSelectionOnSign(false);\r\n                [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n            }\r\n\r\n            this._setValueParts(left, right);\r\n        }\r\n\r\n        /**\r\n         * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\r\n         * Returns TRUE if the keycode is allowed.\r\n         * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\r\n         *\r\n         * @param {Event} e\r\n         * @returns {boolean}\r\n         */\r\n        _processCharacterInsertion(e) {\r\n            const settingsClone = this.settingsClone;\r\n            let [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n            settingsClone.throwInput = true;\r\n\r\n            // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\r\n            const eventCharacter = character(e);\r\n\r\n            // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\r\n            // Do not allow decimal character if no decimal part allowed\r\n            if (eventCharacter === settingsClone.decimalCharacter ||\r\n                (settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative) ||\r\n                ((eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad)) {\r\n                if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\r\n                    return true;\r\n                }\r\n\r\n                // Do not allow decimal character before negativeSignCharacter character\r\n                if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\r\n                    return true;\r\n                }\r\n\r\n                // Do not allow decimal character if other decimal character present\r\n                if (contains(left, settingsClone.decimalCharacter)) {\r\n                    return true;\r\n                }\r\n\r\n                if (right.indexOf(settingsClone.decimalCharacter) > 0) {\r\n                    return true;\r\n                }\r\n\r\n                if (right.indexOf(settingsClone.decimalCharacter) === 0) {\r\n                    right = right.substr(1);\r\n                }\r\n\r\n                this._setValueParts(left + settingsClone.decimalCharacter, right);\r\n\r\n                return true;\r\n            }\r\n\r\n            // Prevent minus if not allowed\r\n            if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\r\n                if (!settingsClone) {\r\n                    return true;\r\n                }\r\n\r\n                // Caret is always after minus\r\n                if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') || (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p')) {\r\n                    if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\r\n                        left = settingsClone.negativeSignCharacter;\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n\r\n                    // Change number sign, remove part if should\r\n                    if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\r\n                        left = left.substring(1, left.length);\r\n                    } else {\r\n                        left = (eventCharacter === '-') ? settingsClone.negativeSignCharacter + left : left;\r\n                    }\r\n                } else {\r\n                    if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\r\n                        left = settingsClone.negativeSignCharacter;\r\n                        right = right.substring(1, right.length);\r\n                    }\r\n\r\n                    // Change number sign, remove part if should\r\n                    if (left.charAt(0) === settingsClone.negativeSignCharacter) {\r\n                        left = left.substring(1, left.length);\r\n                    } else {\r\n                        left = (eventCharacter === '-') ? settingsClone.negativeSignCharacter + left : left;\r\n                    }\r\n                }\r\n\r\n                this._setValueParts(left, right);\r\n\r\n                return true;\r\n            }\r\n\r\n            // If the user tries to insert digit before minus sign\r\n            const eventNumber = Number(eventCharacter);\r\n            if (eventNumber >= 0 && eventNumber <= 9) {\r\n                if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\r\n                    left = settingsClone.negativeSignCharacter;\r\n                    right = right.substring(1, right.length);\r\n                }\r\n\r\n                if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\r\n                    left = settingsClone.negativeSignCharacter + left;\r\n                }\r\n\r\n                this._setValueParts(left + eventCharacter, right);\r\n\r\n                return true;\r\n            }\r\n\r\n            // Prevent any other character\r\n            settingsClone.throwInput = false;\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Formatting of just processed value while keeping the cursor position\r\n         *\r\n         * @param {Event} e\r\n         * @private\r\n         */\r\n        _formatValue(e) {\r\n            const settingsClone = this.settingsClone;\r\n            const leftLength = this.value;\r\n            let [left] = this._getUnformattedLeftAndRightPartAroundTheSelection();\r\n\r\n            // No grouping separator and no currency sign\r\n            if ((settingsClone.digitGroupSeparator  === '' || (settingsClone.digitGroupSeparator !== ''  && !contains(leftLength, settingsClone.digitGroupSeparator))) &&\r\n                (settingsClone.currencySymbol === '' || (settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol)))) {\r\n                let [subParts] = leftLength.split(settingsClone.decimalCharacter);\r\n                let nSign = '';\r\n                if (isNegative(subParts)) {\r\n                    nSign = '-';\r\n                    subParts = subParts.replace('-', '');\r\n                    left = left.replace('-', '');\r\n                }\r\n\r\n                // Strip leading zero on positive value if needed\r\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\r\n                    left = left.slice(1);\r\n                }\r\n\r\n                // Strip leading zero on negative value if needed\r\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\r\n                    left = left.slice(1);\r\n                }\r\n\r\n                left = nSign + left;\r\n            }\r\n\r\n            const value = addGroupSeparators(this.value, this.settingsClone);\r\n            let position = value.length;\r\n            if (value) {\r\n                // Prepare regexp which searches for cursor position from unformatted left part\r\n                const leftAr = left.split('');\r\n\r\n                // Fixes caret position with trailing minus sign\r\n                if ((settingsClone.negativePositiveSignPlacement === 's' || (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p')) &&\r\n                    leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\r\n                    leftAr.shift();\r\n\r\n                    if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) &&\r\n                        settingsClone.caretFix) {\r\n                        if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\r\n                            leftAr.push('-');\r\n                            settingsClone.caretFix = e.type === 'keydown';\r\n                        }\r\n\r\n                        if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\r\n                            leftAr.push('-');\r\n                            settingsClone.caretFix = e.type === 'keydown';\r\n                        }\r\n\r\n                        if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\r\n                            const signParts = settingsClone.currencySymbol.split('');\r\n                            const escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\r\n                            const escapedParts = [];\r\n                            $.each(signParts, (i, miniParts) => {\r\n                                miniParts = signParts[i];\r\n                                if (isInArray(miniParts, escapeChr)) {\r\n                                    escapedParts.push('\\\\' + miniParts);\r\n                                } else {\r\n                                    escapedParts.push(miniParts);\r\n                                }\r\n                            });\r\n\r\n                            if (this.eventKeyCode === keyCode.Backspace) {\r\n                                escapedParts.push('-');\r\n                            }\r\n\r\n                            // Pushing the escaped sign\r\n                            leftAr.push(escapedParts.join(''));\r\n                            settingsClone.caretFix = e.type === 'keydown';\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < leftAr.length; i++) {\r\n                    if (!leftAr[i].match('\\\\d')) {\r\n                        leftAr[i] = '\\\\' + leftAr[i];\r\n                    }\r\n                }\r\n\r\n                const leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\r\n\r\n                // Search cursor position in formatted value\r\n                const newLeft = value.match(leftReg);\r\n                if (newLeft) {\r\n                    position = newLeft[0].length;\r\n\r\n                    // If the positive sign is shown, calculate the caret position accordingly\r\n                    if (settingsClone.showPositiveSign) {\r\n                        if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\r\n                            position = (newLeft.input.indexOf(settingsClone.currencySymbol) === 1) ? settingsClone.currencySymbol.length + 1 : 1;\r\n                        }\r\n\r\n                        if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\r\n                            position = settingsClone.currencySymbol.length + 1;\r\n                        }\r\n                    }\r\n\r\n                    // If we are just before the sign which is in prefix position\r\n                    if (((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter) || (position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter)) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\r\n                        // Place caret after prefix sign\r\n                        //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\r\n                        position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\r\n                    }\r\n                } else {\r\n                    if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\r\n                        // If we could not find a place for cursor and have a sign as a suffix\r\n                        // Place caret before suffix currency sign\r\n                        position -= settingsClone.currencySymbol.length;\r\n                    }\r\n\r\n                    if (settingsClone.suffixText) {\r\n                        // If we could not find a place for cursor and have a suffix\r\n                        // Place caret before suffix\r\n                        position -= settingsClone.suffixText.length;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Only update the value if it has changed. This prevents modifying the selection, if any.\r\n            if (value !== this.that.value ||\r\n                value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\r\n                this.that.value = value;\r\n                this._setCaretPosition(position);\r\n            }\r\n\r\n            this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n     *\r\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n     *\r\n     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\r\n     *\r\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n     * @param {HTMLElement} that - A reference to the current DOM element\r\n     * @returns {*}\r\n     * @private\r\n     */\r\n    function _getStringOrArray(getArrayBehavior = true, that) {\r\n        const $this = getCurrentElement(that);\r\n        const formIndex = $('form').index($this);\r\n        const allFormElements = $(`form:eq(${formIndex})`)[0];\r\n        const aiIndex = [];\r\n\r\n        // all input index\r\n        const scIndex = [];\r\n\r\n        // successful control index\r\n        const rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\r\n\r\n        // from jQuery serialize method\r\n        const rSubmittable = /^(?:input|select|textarea|keygen)/i;\r\n\r\n        // from jQuery serialize method\r\n        const rCheckableType = /^(?:checkbox|radio)$/i;\r\n        const rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\r\n\r\n        let count = 0;\r\n\r\n        // index of successful elements\r\n        $.each(allFormElements, (i, field) => {\r\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\r\n                scIndex.push(count);\r\n                count++;\r\n            } else {\r\n                scIndex.push(-1);\r\n            }\r\n        });\r\n\r\n        // index of all inputs tags except checkbox\r\n        count = 0;\r\n        $.each(allFormElements, (i, field) => {\r\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\r\n                aiIndex.push(count);\r\n                count++;\r\n            } else {\r\n                aiIndex.push(-1);\r\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\r\n                    count++;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (getArrayBehavior) {\r\n            const formFields = $this.serializeArray();\r\n\r\n            $.each(formFields, (i, field) => {\r\n                const scElement = scIndex.indexOf(i);\r\n\r\n                if (scElement > -1 && aiIndex[scElement] > -1) {\r\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\r\n                    const settings = testInput.data('autoNumeric');\r\n\r\n                    if (typeof settings === 'object') {\r\n                        field.value = testInput.autoNumeric('getLocalized').toString();\r\n                    }\r\n                }\r\n            });\r\n\r\n            return formFields;\r\n        }\r\n        else {\r\n            // getString() behavior\r\n            const formFields = $this.serialize();\r\n            const formParts = formFields.split('&');\r\n\r\n            $.each(formParts, i => {\r\n                const [inputName, inputValue] = formParts[i].split('=');\r\n                const scElement = scIndex.indexOf(i);\r\n\r\n                // If the current element is a valid element\r\n                if (scElement > -1 && aiIndex[scElement] > -1) {\r\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\r\n                    const settings = testInput.data('autoNumeric');\r\n\r\n                    if (typeof settings === 'object') {\r\n                        if (inputValue !== null) {\r\n                            const modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\r\n                            formParts[i] = `${inputName}=${modifiedInputValue}`;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            return formParts.join('&');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'focusin' and 'mouseenter' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onFocusInAndMouseEnter($this, holder, e) {\r\n        const settings = holder.settingsClone;\r\n\r\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\r\n            settings.hasFocus = true;\r\n\r\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\r\n                $this.val(toggleNegativeBracket(e.target.value, settings));\r\n            }\r\n\r\n            // clean the value to compare to rawValue\r\n            let result = stripAllNonNumberCharacters(e.target.value, settings, true);\r\n            result = convertToNumericString(result, settings);\r\n            result = cleanLeadingTrailingZeros(result, settings);\r\n            if (settings.trailingNegative) {\r\n                result = '-' + result;\r\n            }\r\n\r\n            if (settings.decimalPlacesShownOnFocus) {\r\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\r\n                $this.autoNumeric('set', settings.rawValue);\r\n            } else if (settings.scaleDivisor) {\r\n                settings.decimalPlacesOverride = settings.oDec;\r\n                $this.autoNumeric('set', settings.rawValue);\r\n            } else if (settings.noSeparatorOnFocus) {\r\n                settings.digitGroupSeparator = '';\r\n                settings.currencySymbol = '';\r\n                settings.suffixText = '';\r\n                $this.autoNumeric('set', settings.rawValue);\r\n            } else if (result !== settings.rawValue) {\r\n                $this.autoNumeric('set', result);\r\n            }\r\n\r\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\r\n            holder.valueOnFocus = e.target.value;\r\n            holder.lastVal = holder.valueOnFocus;\r\n            const onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\r\n            if ((onEmpty !== null && onEmpty !== '') && settings.emptyInputBehavior === 'focus') {\r\n                $this.val(onEmpty);\r\n\r\n                // If there is a currency symbol and its on the right hand side, then we place the caret accordingly on the far left side\r\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\r\n                    setElementSelection(e.target, 0);\r\n                }\r\n            } else {\r\n                // Otherwise by default the whole input content is selected on focus (following the `selectNumberOnly` option)\r\n                //XXX Firefox <47 does not respect this selection...Oh well.\r\n                holder._select();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for the 'focus' event\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     */\r\n    function onFocus(holder) {\r\n        if (holder.settings.isCancellable) {\r\n            // Save the current unformatted value for later use by the 'cancellable' feature\r\n            holder._saveCancellableValue();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'keydown' events.\r\n     * The user just started pushing any key, hence one event is sent.\r\n     *\r\n     * Note :\r\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\r\n     * - keydown\r\n     * - keypress\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * ...when inputting a modifier key (ie. 'ctrl') :\r\n     * - keydown\r\n     * - keyup\r\n     *\r\n     * If 'delete' or 'backspace' is entered, the following events are sent :\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has not changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - keyup\r\n     *\r\n     * If 'enter' is entered and the value has been changed, the following events are sent :\r\n     * - keydown\r\n     * - keypress\r\n     * - change\r\n     * - keyup\r\n     *\r\n     * When a paste is done, the following events are sent :\r\n     * - input (if paste is done with the mouse)\r\n     *\r\n     * - keydown (if paste is done with ctrl+v)\r\n     * - keydown\r\n     * - input\r\n     * - keyup\r\n     * - keyup\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onKeydown(holder, e) {\r\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\r\n        holder._updateAutoNumericHolderEventKeycode(e);\r\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\r\n\r\n        if (holder.that.readOnly) {\r\n            holder.processed = true;\r\n\r\n            return;\r\n        }\r\n\r\n        if (holder.eventKeyCode === keyCode.Esc) {\r\n            //XXX The default 'Escape' key behavior differs between Firefox and Chrome, Firefox already having a built-in 'cancellable-like' feature. This is why we call `e.preventDefault()` here instead of just when `isCancellable` is set to `true`. This allow us to keep the same behavior across browsers.\r\n            e.preventDefault();\r\n\r\n            if (holder.settings.isCancellable) {\r\n                // If the user wants to cancel its modifications :\r\n                // We set back the saved value\r\n                holder.$that.autoNumeric('set', holder.savedCancellableValue);\r\n                // And we need to send an 'input' event when setting back the initial value in order to make other scripts aware of the value change...\r\n                triggerEvent('input', e.target);\r\n            }\r\n\r\n            // ..and lastly we update the caret selection, even if the option `isCancellable` is false\r\n            holder._select();\r\n        }\r\n\r\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\r\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\r\n            triggerEvent('change', e.target);\r\n            holder.valueOnFocus = e.target.value;\r\n\r\n            if (holder.settings.isCancellable) {\r\n                // If the user activated the 'cancellable' feature, we save the validated value when 'Enter' is hit\r\n                holder._saveCancellableValue();\r\n            }\r\n        }\r\n\r\n        holder._updateAutoNumericHolderProperties(e);\r\n\r\n        if (holder._skipAlways(e)) {\r\n            holder.processed = true;\r\n\r\n            return;\r\n        }\r\n\r\n        // Check if the key is a delete/backspace key\r\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\r\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\r\n            holder.processed = true;\r\n            holder._formatValue(e);\r\n\r\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\r\n            if ((e.target.value !== holder.lastVal) && holder.settingsClone.throwInput) {\r\n                // Throw an input event when a character deletion is detected\r\n                triggerEvent('input', e.target);\r\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\r\n            }\r\n\r\n            holder.lastVal = e.target.value;\r\n            holder.settingsClone.throwInput = true;\r\n\r\n            return;\r\n        }\r\n\r\n        holder.formatted = false; //TODO Is this line needed?\r\n    }\r\n\r\n    /**\r\n     * Handler for 'keypress' events.\r\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\r\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onKeypress(holder, e) {\r\n        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\r\n        const eventCharacter = character(e);\r\n\r\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\r\n        if (eventCharacter === keyName.Insert) {\r\n            return;\r\n        }\r\n\r\n        const processed = holder.processed;\r\n        holder._updateAutoNumericHolderProperties(e);\r\n\r\n        if (holder._skipAlways(e)) {\r\n            return;\r\n        }\r\n\r\n        if (processed) {\r\n            e.preventDefault();\r\n\r\n            return;\r\n        }\r\n\r\n        const isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\r\n        if (isCharacterInsertionAllowed) {\r\n            holder._formatValue(e);\r\n            if ((e.target.value !== holder.lastVal) && holder.settingsClone.throwInput) {\r\n                // Throws input event on adding a character\r\n                triggerEvent('input', e.target);\r\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\r\n            }\r\n            else {\r\n                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) &&\r\n                    (getElementSelection(e.target).start === getElementSelection(e.target).end) &&\r\n                    getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\r\n                    const position = getElementSelection(e.target).start + 1;\r\n                    setElementSelection(e.target, position);\r\n                }\r\n                e.preventDefault();\r\n            }\r\n\r\n            holder.lastVal = e.target.value;\r\n            holder.settingsClone.throwInput = true;\r\n\r\n            return;\r\n        }\r\n\r\n        e.preventDefault();\r\n\r\n        holder.formatted = false;\r\n    }\r\n\r\n    /**\r\n     * Handler for 'keyup' events.\r\n     * The user just released any key, hence one event is sent.\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {object} settings\r\n     * @param {Event} e\r\n     */\r\n    function onKeyup(holder, settings, e) {\r\n        if (holder.settings.isCancellable && holder.eventKeyCode === keyCode.Esc) {\r\n            // If the user wants to cancel its modifications, we drop the 'keyup' event for the Esc key\r\n            e.preventDefault();\r\n            return;\r\n        }\r\n\r\n        holder._updateAutoNumericHolderProperties(e);\r\n\r\n        const skip = holder._skipAlways(e);\r\n        delete holder.valuePartsBeforePaste;\r\n        if (skip || e.target.value === '') {\r\n            return;\r\n        }\r\n\r\n        // Added to properly place the caret when only the currency sign is present\r\n        if (e.target.value === holder.settingsClone.currencySymbol) {\r\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\r\n                setElementSelection(e.target, 0);\r\n            } else {\r\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length);\r\n            }\r\n        } else if (holder.eventKeyCode === keyCode.Tab) {\r\n            setElementSelection(e.target, 0, e.target.value.length);\r\n        }\r\n\r\n        if ((e.target.value === holder.settingsClone.suffixText) ||\r\n            (holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '')) {\r\n            setElementSelection(e.target, 0);\r\n        }\r\n\r\n        // Saves the extended decimal to preserve the data when navigating away from the page\r\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\r\n            saveValueToPersistentStorage(e.target, settings, 'set');\r\n        }\r\n\r\n        if (!holder.formatted) {\r\n            holder._formatValue(e);\r\n        }\r\n\r\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\r\n        if (e.target.value !== holder.initialValueOnKeydown) {\r\n            triggerEvent('autoNumeric:formatted', e.target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'focusout' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onFocusOutAndMouseLeave($this, holder, e) {\r\n        if (!$this.is(':focus')) {\r\n            let value = e.target.value;\r\n            const origValue = value;\r\n            const settings = holder.settingsClone;\r\n            settings.hasFocus = false;\r\n\r\n            if (settings.saveValueToSessionStorage) {\r\n                saveValueToPersistentStorage(e.target, settings, 'set');\r\n            }\r\n\r\n            if (settings.noSeparatorOnFocus === true) {\r\n                settings.digitGroupSeparator = settings.oSep;\r\n                settings.currencySymbol = settings.oSign;\r\n                settings.suffixText = settings.oSuffix;\r\n            }\r\n\r\n            if (settings.decimalPlacesShownOnFocus !== null) {\r\n                settings.decimalPlacesOverride = settings.oDec;\r\n                settings.allowDecimalPadding = settings.oPad;\r\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\r\n            }\r\n\r\n            value = stripAllNonNumberCharacters(value, settings, true);\r\n\r\n            if (value !== '') {\r\n                if (settings.trailingNegative && !isNegative(value)) {\r\n                    value = '-' + value;\r\n                    settings.trailingNegative = false;\r\n                }\r\n\r\n                const [minTest, maxTest] = checkIfInRangeWithOverrideOption(value, settings);\r\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\r\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\r\n                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\r\n\r\n                    if (settings.scaleDivisor) {\r\n                        value = value / settings.scaleDivisor;\r\n                        value = value.toString();\r\n                    }\r\n\r\n                    settings.decimalPlacesOverride = (settings.scaleDivisor && settings.scaleDecimalPlaces) ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\r\n                    value = roundValue(value, settings);\r\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\r\n                } else {\r\n                    if (!minTest) {\r\n                        $this.trigger('autoNumeric:minExceeded');\r\n                    }\r\n                    if (!maxTest) {\r\n                        $this.trigger('autoNumeric:maxExceeded');\r\n                    }\r\n\r\n                    value = settings.rawValue;\r\n                }\r\n            } else {\r\n                if (settings.emptyInputBehavior === 'zero') {\r\n                    settings.rawValue = '0';\r\n                    value = roundValue('0', settings);\r\n                } else {\r\n                    settings.rawValue = '';\r\n                }\r\n            }\r\n\r\n            let groupedValue = checkEmpty(value, settings, false);\r\n            if (groupedValue === null) {\r\n                groupedValue = addGroupSeparators(value, settings);\r\n            }\r\n\r\n            if (groupedValue !== origValue) {\r\n                groupedValue = (settings.scaleSymbol) ? groupedValue + settings.scaleSymbol : groupedValue;\r\n                $this.val(groupedValue);\r\n            }\r\n\r\n            if (groupedValue !== holder.valueOnFocus) {\r\n                $this.change();\r\n                delete holder.valueOnFocus;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'paste' event\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onPaste($this, holder, e) {\r\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\r\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\r\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\r\n        e.preventDefault();\r\n\r\n        let rawPastedText = e.clipboardData.getData('text/plain');\r\n\r\n        // 0. Special case if the user has selected all the input text before pasting\r\n        const initialFormattedValue = e.target.value;\r\n        const selectionStart = e.target.selectionStart || 0;\r\n        const selectionEnd = e.target.selectionEnd || 0;\r\n        const selectionSize = selectionEnd - selectionStart;\r\n        let isAllInputTextSelected = false;\r\n\r\n        if (selectionSize === initialFormattedValue.length) {\r\n            isAllInputTextSelected = true;\r\n        }\r\n\r\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\r\n        const isPasteNegative = isNegativeStrict(rawPastedText);\r\n        if (isPasteNegative) {\r\n            // 1a. Remove the negative sign from the pasted text\r\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\r\n        }\r\n\r\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\r\n        const untranslatedPastedText = preparePastedText(rawPastedText, holder);\r\n\r\n        let pastedText;\r\n        if (untranslatedPastedText === '.') {\r\n            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\r\n            pastedText = '.';\r\n        } else {\r\n            // Normal case\r\n            // Allow pasting arabic numbers\r\n            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\r\n        }\r\n\r\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\r\n        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\r\n            if (holder.settings.onInvalidPaste === 'error') {\r\n                //TODO Should we send a warning instead of throwing an error?\r\n                throwError(`The pasted value '${rawPastedText}' is not a valid paste content.`);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // 4. Calculate the paste result\r\n        let caretPositionOnInitialTextAfterPasting;\r\n        let initialUnformattedNumber;\r\n        if (e.target.value === '') {\r\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\r\n            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\r\n            initialUnformattedNumber = '';\r\n        } else {\r\n            initialUnformattedNumber = $this.autoNumeric('get');\r\n        }\r\n        let isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\r\n        let isPasteNegativeAndInitialValueIsPositive;\r\n        let result;\r\n\r\n        // If the pasted content is negative, then the result will be negative too\r\n        if (isPasteNegative && !isInitialValueNegative) {\r\n            initialUnformattedNumber = `-${initialUnformattedNumber}`;\r\n            isInitialValueNegative = true;\r\n            isPasteNegativeAndInitialValueIsPositive = true;\r\n        }\r\n        else {\r\n            isPasteNegativeAndInitialValueIsPositive = false;\r\n        }\r\n\r\n        let leftPartContainedADot = false;\r\n        switch (holder.settings.onInvalidPaste) {\r\n            /* 4a. Truncate paste behavior:\r\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\r\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\r\n             * Otherwise paste all the numbers in the clipboard.\r\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\r\n             *\r\n             * 4b. Replace paste behavior:\r\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\r\n             */\r\n            /* eslint no-case-declarations: 0 */\r\n            case 'truncate':\r\n            case 'replace':\r\n                const leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\r\n                const rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\r\n\r\n                if (selectionStart !== selectionEnd) {\r\n                    // a. If there is a selection, remove the selected part, and return the left and right part\r\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\r\n                } else {\r\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\r\n                    result = preparePastedText(initialFormattedValue, holder);\r\n                }\r\n\r\n                // Add back the negative sign if needed\r\n                if (isInitialValueNegative) {\r\n                    result = setRawNegativeSign(result);\r\n                }\r\n\r\n                // Build the unformatted result string\r\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\r\n                if (isPasteNegativeAndInitialValueIsPositive) {\r\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\r\n                    caretPositionOnInitialTextAfterPasting++;\r\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\r\n                }\r\n\r\n                let leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\r\n                let rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\r\n                if (pastedText === '.') {\r\n                    if (contains(leftPart, '.')) {\r\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\r\n                        // To do so, we keep that info in order to modify the caret position later\r\n                        leftPartContainedADot = true;\r\n                        leftPart = leftPart.replace('.', '');\r\n                    }\r\n                    rightPart = rightPart.replace('.', '');\r\n                }\r\n                // -- Here, we are good to go to continue on the same basis\r\n\r\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\r\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\r\n                const minParse = parseStr(holder.settings.minimumValue);\r\n                const maxParse = parseStr(holder.settings.maximumValue);\r\n                let lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\r\n                let pastedTextIndex = 0;\r\n                let modifiedLeftPart = leftPart;\r\n\r\n                while (pastedTextIndex < pastedText.length) {\r\n                    // Modify the result with another pasted character\r\n                    modifiedLeftPart += pastedText[pastedTextIndex];\r\n                    result = modifiedLeftPart + rightPart;\r\n\r\n                    // Check the range limits\r\n                    if (!checkIfInRange(result, minParse, maxParse)) {\r\n                        // The result is out of the range limits, stop the loop here\r\n                        break;\r\n                    }\r\n\r\n                    // Save the last good known result\r\n                    lastGoodKnownResult = result;\r\n\r\n                    // Update the local variables for the next loop\r\n                    pastedTextIndex++;\r\n                }\r\n\r\n                // Update the last caret position where to insert a new number\r\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\r\n\r\n                //XXX Here we have the result for the `truncate` option\r\n                if (holder.settings.onInvalidPaste === 'truncate') {\r\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\r\n                    result = lastGoodKnownResult;\r\n\r\n                    if (leftPartContainedADot) {\r\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\r\n                        caretPositionOnInitialTextAfterPasting--;\r\n                    }\r\n                    break;\r\n                }\r\n                //XXX ...else we need to continue modifying the result for the 'replace' option\r\n\r\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\r\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\r\n                //    If you do get to the range limits, use the previous known good value within those limits.\r\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\r\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\r\n                let lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\r\n                const lastGoodKnownResultSize = lastGoodKnownResult.length;\r\n\r\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\r\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\r\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\r\n                        lastGoodKnownResultIndex++;\r\n                        continue;\r\n                    }\r\n\r\n                    // This replace one character at a time\r\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\r\n\r\n                    // Check the range limits\r\n                    if (!checkIfInRange(result, minParse, maxParse)) {\r\n                        // The result is out of the range limits, stop the loop here\r\n                        break;\r\n                    }\r\n\r\n                    // Save the last good known result\r\n                    lastGoodKnownResult = result;\r\n\r\n                    // Update the local variables for the next loop\r\n                    pastedTextIndex++;\r\n                    lastGoodKnownResultIndex++;\r\n                }\r\n\r\n                // Update the last caret position where to insert a new number\r\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\r\n\r\n                if (leftPartContainedADot) {\r\n                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\r\n                    caretPositionOnInitialTextAfterPasting--;\r\n                }\r\n\r\n                result = lastGoodKnownResult;\r\n\r\n                break;\r\n            /* 4c. Normal paste behavior:\r\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\r\n             */\r\n            case 'error':\r\n            case 'ignore':\r\n            case 'clamp':\r\n            default:\r\n                // 1. Generate the unformatted result\r\n                const leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\r\n                const rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\r\n\r\n                if (selectionStart !== selectionEnd) {\r\n                    // a. If there is a selection, remove the selected part, and return the left and right part\r\n                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\r\n                } else {\r\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\r\n                    result = preparePastedText(initialFormattedValue, holder);\r\n                }\r\n\r\n                // Add back the negative sign if needed\r\n                if (isInitialValueNegative) {\r\n                    result = setRawNegativeSign(result);\r\n                }\r\n\r\n                // Build the unformatted result string\r\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\r\n                if (isPasteNegativeAndInitialValueIsPositive) {\r\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\r\n                    caretPositionOnInitialTextAfterPasting++;\r\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\r\n                }\r\n\r\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\r\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\r\n                if (pastedText === '.') {\r\n                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\r\n                    if (contains(leftPart, '.')) {\r\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\r\n                        // To do so, we keep that info in order to modify the caret position later\r\n                        leftPartContainedADot = true;\r\n                        leftPart = leftPart.replace('.', '');\r\n                    }\r\n                    rightPart = rightPart.replace('.', '');\r\n                }\r\n                // -- Here, we are good to go to continue on the same basis\r\n\r\n                // Generate the unformatted result\r\n                result = `${leftPart}${pastedText}${rightPart}`;\r\n\r\n                // 2. Calculate the caret position in the unformatted value, for later use\r\n                if (selectionStart === selectionEnd) {\r\n                    // There is no selection, then the caret position is set after the pasted text\r\n                    const indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\r\n                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\r\n                } else {\r\n                    if (isAllInputTextSelected) {\r\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\r\n                        caretPositionOnInitialTextAfterPasting = result.length;\r\n                    } else if (rightPart === '') {\r\n                        // If the user selected from the caret position to the end of the input (on the far right)\r\n                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\r\n                    } else {\r\n                        // Normal case\r\n                        const indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\r\n\r\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\r\n                        const selectedText = e.target.value.slice(selectionStart, selectionEnd);\r\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\r\n                    }\r\n                }\r\n\r\n                // Modify the caret position for special cases, only if the whole input has not been selected\r\n                if (!isAllInputTextSelected) {\r\n                    if (isPasteNegativeAndInitialValueIsPositive) {\r\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\r\n                        caretPositionOnInitialTextAfterPasting++;\r\n                    }\r\n\r\n                    if (leftPartContainedADot) {\r\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\r\n                        caretPositionOnInitialTextAfterPasting--;\r\n                    }\r\n                }\r\n        }\r\n\r\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\r\n        if (!isNumber(result) || result === '') {\r\n            if (holder.settings.onInvalidPaste === 'error') {\r\n                throwError(`The pasted value '${rawPastedText}' would result into an invalid content '${result}'.`); //TODO Should we send a warning instead of throwing an error?\r\n                //TODO This is not DRY ; refactor with above\r\n            }\r\n            return;\r\n        }\r\n\r\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\r\n        /*\r\n         * If 'error' (this is the default) :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, then throw an error in the console.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'ignore' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, do nothing more.\r\n         *      - Do not change the input value, do not change the current selection.\r\n         * If 'clamp' :\r\n         *      - Normal paste behavior.\r\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\r\n         *        paste result.\r\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\r\n         * If 'truncate' :\r\n         *      - Truncate paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         * If 'replace' :\r\n         *      - Replace paste behavior.\r\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\r\n         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\r\n         *      - Change the caret position to be positioned after the last pasted character.\r\n         */\r\n        let valueHasBeenSet = false;\r\n        let valueHasBeenClamped = false;\r\n        try {\r\n            $this.autoNumeric('set', result);\r\n            valueHasBeenSet = true;\r\n        }\r\n        catch (error) {\r\n            let clampedValue;\r\n            switch (holder.settings.onInvalidPaste) {\r\n                case 'clamp':\r\n                    clampedValue = clampToRangeLimits(result, holder.settings);\r\n                    try {\r\n                        $this.autoNumeric('set', clampedValue);\r\n                    }\r\n                    catch (error) {\r\n                        throwError(`Fatal error: Unable to set the clamped value '${clampedValue}'.`);\r\n                    }\r\n\r\n                    valueHasBeenClamped = true;\r\n                    valueHasBeenSet = true;\r\n                    result = clampedValue; // This is used only for setting the caret position later\r\n                    break;\r\n                case 'error':\r\n                case 'truncate':\r\n                case 'replace':\r\n                    // Throw an error message\r\n                    throwError(`The pasted value '${rawPastedText}' results in a value '${result}' that is outside of the minimum [${holder.settings.minimumValue}] and maximum [${holder.settings.maximumValue}] value range.`);\r\n                // falls through\r\n                case 'ignore':\r\n                // Do nothing\r\n                // falls through\r\n                default :\r\n                    return; // ...and nothing else should be changed\r\n            }\r\n        }\r\n\r\n        // 7. Then lastly, set the caret position at the right logical place\r\n        let caretPositionInFormattedNumber;\r\n        if (valueHasBeenSet) {\r\n            switch (holder.settings.onInvalidPaste) {\r\n                case 'clamp':\r\n                    if (valueHasBeenClamped) {\r\n                        if (holder.settings.currencySymbolPlacement === 's') {\r\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\r\n                        } else {\r\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\r\n                        }\r\n\r\n                        break;\r\n                    } // else if the value has not been clamped, the default behavior is used...\r\n                // falls through\r\n                case 'error':\r\n                case 'ignore':\r\n                case 'truncate':\r\n                case 'replace':\r\n                default :\r\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\r\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\r\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\r\n            }\r\n        }\r\n\r\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\r\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\r\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\r\n            triggerEvent('input', e.target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onBlur(holder, e) {\r\n        if (e.target.value !== holder.valueOnFocus) {\r\n            triggerEvent('change', e.target);\r\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'wheel' event\r\n     *\r\n     * @param {AutoNumericHolder} holder\r\n     * @param {Event} e\r\n     */\r\n    function onWheel(holder, e) {\r\n        // If the user is using the 'Shift' key modifier, then we ignore the wheel event\r\n        // This special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\r\n        // If that's the case, then he can use the 'Shift' modifier key while using the mouse wheel in order to bypass the increment/decrement feature\r\n        // This is useful on small screen where some badly configured inputs could use all the available space.\r\n        if (!e.shiftKey && holder.settings.modifyValueOnWheel) {\r\n            // 0) First, save the caret position so we can set it back once the value has been changed\r\n            const selectionStart = e.target.selectionStart || 0;\r\n            const selectionEnd = e.target.selectionEnd || 0;\r\n\r\n            // 1) Get the unformatted value\r\n            const currentUnformattedValue = holder.settings.rawValue;\r\n            let result;\r\n            if (isUndefinedOrNullOrEmpty(currentUnformattedValue)) {\r\n                // If by default the input is empty, start at '0'\r\n                if (holder.settings.minimumValue > 0 || holder.settings.maximumValue < 0) {\r\n                    // or if '0' is not between min and max value, 'minimumValue' if the user does a wheelup, 'maximumValue' if the user does a wheeldown\r\n                    if (isWheelUpEvent(e)) {\r\n                        result = holder.settings.minimumValue;\r\n                    } else if (isWheelDownEvent(e)) {\r\n                        result = holder.settings.maximumValue;\r\n                    } else {\r\n                        throwError(`The event is not a 'wheel' event.`);\r\n                    }\r\n                } else {\r\n                    result = 0;\r\n                }\r\n            } else {\r\n                result = currentUnformattedValue;\r\n            }\r\n\r\n            result = +result; // Typecast to a number needed for the following addition/subtraction\r\n\r\n            // 2) Increment/Decrement the value\r\n            // But first, choose the increment/decrement method ; fixed or progressive\r\n            if (isNumber(holder.settings.wheelStep)) {\r\n                const step = +holder.settings.wheelStep; // Typecast to a number needed for the following addition/subtraction\r\n                // Fixed method\r\n                // This is the simplest method, where a fixed offset in added/subtracted from the current value\r\n                if (isWheelUpEvent(e)) { // Increment\r\n                    result = result + step;\r\n                } else if (isWheelDownEvent(e)) { // Decrement\r\n                    result = result - step;\r\n                }\r\n            } else {\r\n                // Progressive method\r\n                // For this method, we calculate an offset that is in relation to the size of the current number (using only the integer part size).\r\n                // The bigger the number, the bigger the offset (usually the number count in the integer part minus 3, except for small numbers where a different behavior is better for the user experience).\r\n                if (isWheelUpEvent(e)) { // Increment\r\n                    result = addAndRoundToNearestAuto(result);\r\n                } else if (isWheelDownEvent(e)) { // Decrement\r\n                    result = subtractAndRoundToNearestAuto(result);\r\n                }\r\n            }\r\n\r\n            // 3) Set the new value so it gets formatted\r\n            // First clamp the result if needed\r\n            result = clampToRangeLimits(result, holder.settings);\r\n            if (result !== +currentUnformattedValue) {\r\n                // Only 'set' the value if it has changed. For instance 'set' should not happen if the user hits a limit and continue to try to go past it since we clamp the value.\r\n                holder.$that.autoNumeric('set', result);\r\n            }\r\n\r\n            //XXX Do not prevent if the value is not modified? From a UX point of view, preventing the wheel event when the user use it on top of an autoNumeric element should always be done, even if the value does not change. Perhaps that could affect other scripts relying on this event to be sent though.\r\n            e.preventDefault(); // We prevent the page to scroll while we increment/decrement the value\r\n\r\n            // 4) Finally, we set back the caret position/selection\r\n            // There is no need to take into account the fact that the number count could be different at the end of the wheel event ; it would be too complex and most of the time unreliable\r\n            holder._setSelection(selectionStart, selectionEnd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for 'submit' events\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {AutoNumericHolder} holder\r\n     */\r\n    function onSubmit($this, holder) {\r\n        $this.closest('form').on('submit.autoNumeric', () => {\r\n            if (holder) {\r\n                const $settings = holder.settingsClone;\r\n\r\n                if ($settings.unformatOnSubmit) {\r\n                    $this.val($settings.rawValue);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n     *\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @returns {boolean|*}\r\n     */\r\n    function getInputIfSupportedTagAndType($this) {\r\n        // Supported input type\r\n        const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\r\n\r\n        // Checks for non-supported input types\r\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\r\n            throwError(`The input type \"${$this.prop('type')}\" is not supported by autoNumeric`);\r\n        }\r\n\r\n        // Checks for non-supported tags\r\n        const currentElementTag = $this.prop('tagName').toLowerCase();\r\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\r\n            throwError(`The <${currentElementTag}> tag is not supported by autoNumeric`);\r\n        }\r\n\r\n        return $input;\r\n    }\r\n\r\n    /**\r\n     * Formats the default value on page load.\r\n     * This is called only if the `formatOnPageLoad` option is set to `true`.\r\n     *\r\n     * @param {object} settings\r\n     * @param {object} $input jQuery-selected <input> element\r\n     * @param {object} $this jQuery-selected DOM element\r\n     */\r\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\r\n        let setValue = true;\r\n\r\n        if ($input) {\r\n            const currentValue = $this.val();\r\n            /*\r\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\r\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n             *\r\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\r\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n             * we should ignore `defaultValueOverride` altogether.\r\n             */\r\n            const unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup\r\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\r\n                // Check if the `value` is valid or not\r\n                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\r\n                    $this.autoNumeric('set', unLocalizedCurrentValue);\r\n                    setValue = false;\r\n                } else {\r\n                    // If not, inform the developer that nothing usable has been provided\r\n                    throwError(`The value [${currentValue}] used in the input is not a valid value autoNumeric can work with.`);\r\n                }\r\n            } else {\r\n                /* Checks for :\r\n                 * - page reload from back button, and\r\n                 * - ASP.net form post back\r\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n                 */\r\n                if ((settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue) ||\r\n                    (settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value')) ||\r\n                    (currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue))) {\r\n                    if ((settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage) ||\r\n                        (settings.scaleDivisor && settings.saveValueToSessionStorage)) {\r\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\r\n                    }\r\n\r\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\r\n                    if (!settings.saveValueToSessionStorage) {\r\n                        let toStrip;\r\n\r\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\r\n                            settings.hasFocus = true;\r\n                            toStrip = toggleNegativeBracket(currentValue, settings);\r\n                        } else {\r\n                            toStrip = currentValue;\r\n                        }\r\n\r\n                        if ((settings.negativePositiveSignPlacement === 's' ||\r\n                            (settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's')) &&\r\n                            settings.negativeSignCharacter !== '' &&\r\n                            isNegative(currentValue)) {\r\n                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\r\n                        } else {\r\n                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\r\n                        }\r\n                    }\r\n\r\n                    setValue = false;\r\n                }\r\n            }\r\n\r\n            if (currentValue === '') {\r\n                switch (settings.emptyInputBehavior) {\r\n                    case 'focus':\r\n                        setValue = false;\r\n                        break;\r\n                    case 'always':\r\n                        $this.val(settings.currencySymbol);\r\n                        setValue = false;\r\n                        break;\r\n                    case 'zero':\r\n                        $this.autoNumeric('set', '0');\r\n                        setValue = false;\r\n                        break;\r\n                    default :\r\n                    //\r\n                }\r\n            } else if (setValue && currentValue === $this.attr('value')) {\r\n                $this.autoNumeric('set', currentValue);\r\n            }\r\n        }\r\n\r\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\r\n            if (settings.defaultValueOverride !== null) {\r\n                if (settings.defaultValueOverride === $this.text()) {\r\n                    $this.autoNumeric('set', $this.text());\r\n                }\r\n            } else {\r\n                $this.autoNumeric('set', $this.text());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\r\n     *\r\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\r\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\r\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\r\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function correctNegativePositiveSignPlacementOption(settings) {\r\n        // If negativePositiveSignPlacement is already set, we do not overwrite it\r\n        if (!isNull(settings.negativePositiveSignPlacement)) {\r\n            return;\r\n        }\r\n\r\n        if (!isUndefined(settings) &&\r\n            isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) &&\r\n            !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\r\n            switch (settings.currencySymbolPlacement) {\r\n                case 's':\r\n                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 \r\n                    break;\r\n                case 'p':\r\n                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\r\n                    break;\r\n                default :\r\n                //\r\n            }\r\n        } else {\r\n            // Sets the default value if `negativePositiveSignPlacement` is `null`\r\n            settings.negativePositiveSignPlacement = 'l';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function calculateVMinAndVMaxIntegerSizes(settings) {\r\n        let [maximumValueIntegerPart] = settings.maximumValue.toString().split('.');\r\n        let [minimumValueIntegerPart] = (!settings.minimumValue && settings.minimumValue !== 0)?[]:settings.minimumValue.toString().split('.');\r\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\r\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\r\n\r\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\r\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\r\n    }\r\n\r\n    /**\r\n     * Modify `decimalPlacesOverride` as needed\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function correctDecimalPlacesOverrideOption(settings) {\r\n        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\r\n            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\r\n            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\r\n        }\r\n        else if (isNull(settings.decimalPlacesOverride)) {\r\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\r\n        }\r\n        settings.oDec = String(settings.decimalPlacesOverride);\r\n\r\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\r\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\r\n    }\r\n\r\n    /**\r\n     * Sets the alternative decimal separator key.\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\r\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\r\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\r\n                settings.decimalCharacterAlternative = ',';\r\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\r\n                settings.decimalCharacterAlternative = '.';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Caches regular expressions for stripAllNonNumberCharacters\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function cachesUsualRegularExpressions(settings) {\r\n        const allNumbersReg = '[0-9]';\r\n        const noAllNumbersReg = '[^0-9]';\r\n\r\n        // Test if there is a negative character in the string\r\n        const aNegReg = settings.negativeSignCharacter?`([-\\\\${settings.negativeSignCharacter}]?)`:'(-?)';\r\n        settings.aNegRegAutoStrip = aNegReg;\r\n\r\n        let negativeSignRegPart;\r\n        if (settings.negativeSignCharacter) {\r\n            negativeSignRegPart = `\\\\${settings.negativeSignCharacter}`;\r\n        } else {\r\n            negativeSignRegPart = '';\r\n        }\r\n        settings.skipFirstAutoStrip = new RegExp(`${aNegReg}[^-${negativeSignRegPart}\\\\${settings.decimalCharacter}${allNumbersReg}].*?(${allNumbersReg}|\\\\${settings.decimalCharacter}${allNumbersReg})`);\r\n        settings.skipLastAutoStrip = new RegExp(`(${allNumbersReg}\\\\${settings.decimalCharacter}?)[^\\\\${settings.decimalCharacter}${allNumbersReg}]${noAllNumbersReg}*$`);\r\n\r\n        const allowed = `-0123456789\\\\${settings.decimalCharacter}`;\r\n        settings.allowedAutoStrip = new RegExp(`[^${allowed}]`, 'g');\r\n        settings.numRegAutoStrip = new RegExp(`${aNegReg}(?:\\\\${settings.decimalCharacter}?(${allNumbersReg}+\\\\${settings.decimalCharacter}${allNumbersReg}+)|(${allNumbersReg}*(?:\\\\${settings.decimalCharacter}${allNumbersReg}*)?))`);\r\n\r\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\r\n        settings.stripReg = new RegExp(`^${settings.aNegRegAutoStrip}0*(${allNumbersReg})`);\r\n    }\r\n\r\n    /**\r\n     * Modify the user settings to make them 'exploitable' later.\r\n     *\r\n     * @param {object} settings\r\n     */\r\n    function transformOptionsValuesToDefaultTypes(settings) {\r\n        $.each(settings, (key, value) => {\r\n            // Convert the string 'true' and 'false' to real Boolean\r\n            if (value === 'true' || value === 'false') {\r\n                settings[key] = value === 'true';\r\n            }\r\n\r\n            // Convert numbers in options to strings\r\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\r\n            if (typeof value === 'number' && key !== 'aScale') {\r\n                settings[key] = value.toString();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Convert the old settings options name to new ones.\r\n     *\r\n     * @param {object} options\r\n     */\r\n    function convertOldOptionsToNewOnes(options) {\r\n        //TODO Delete this function once the old options are not used anymore\r\n        const oldOptionsConverter = {\r\n            // Old option name, with their corresponding new option\r\n            aSep                         : 'digitGroupSeparator',\r\n            nSep                         : 'noSeparatorOnFocus',\r\n            dGroup                       : 'digitalGroupSpacing',\r\n            aDec                         : 'decimalCharacter',\r\n            altDec                       : 'decimalCharacterAlternative',\r\n            aSign                        : 'currencySymbol',\r\n            pSign                        : 'currencySymbolPlacement',\r\n            pNeg                         : 'negativePositiveSignPlacement',\r\n            aSuffix                      : 'suffixText',\r\n            oLimits                      : 'overrideMinMaxLimits',\r\n            vMax                         : 'maximumValue',\r\n            vMin                         : 'minimumValue',\r\n            mDec                         : 'decimalPlacesOverride',\r\n            eDec                         : 'decimalPlacesShownOnFocus',\r\n            scaleDecimal                 : 'scaleDecimalPlaces',\r\n            aStor                        : 'saveValueToSessionStorage',\r\n            mRound                       : 'roundingMethod',\r\n            aPad                         : 'allowDecimalPadding',\r\n            nBracket                     : 'negativeBracketsTypeOnBlur',\r\n            wEmpty                       : 'emptyInputBehavior',\r\n            lZero                        : 'leadingZero',\r\n            aForm                        : 'formatOnPageLoad',\r\n            sNumber                      : 'selectNumberOnly',\r\n            anDefault                    : 'defaultValueOverride',\r\n            unSetOnSubmit                : 'unformatOnSubmit',\r\n            outputType                   : 'outputFormat',\r\n            debug                        : 'showWarnings',\r\n            // Current options :\r\n            digitGroupSeparator          : true,\r\n            noSeparatorOnFocus           : true,\r\n            digitalGroupSpacing          : true,\r\n            decimalCharacter             : true,\r\n            decimalCharacterAlternative  : true,\r\n            currencySymbol               : true,\r\n            currencySymbolPlacement      : true,\r\n            negativePositiveSignPlacement: true,\r\n            showPositiveSign             : true,\r\n            suffixText                   : true,\r\n            overrideMinMaxLimits         : true,\r\n            maximumValue                 : true,\r\n            minimumValue                 : true,\r\n            decimalPlacesOverride        : true,\r\n            decimalPlacesShownOnFocus    : true,\r\n            scaleDivisor                 : true,\r\n            scaleDecimalPlaces           : true,\r\n            scaleSymbol                  : true,\r\n            saveValueToSessionStorage    : true,\r\n            onInvalidPaste               : true,\r\n            roundingMethod               : true,\r\n            allowDecimalPadding          : true,\r\n            negativeBracketsTypeOnBlur   : true,\r\n            emptyInputBehavior           : true,\r\n            leadingZero                  : true,\r\n            formatOnPageLoad             : true,\r\n            selectNumberOnly             : true,\r\n            defaultValueOverride         : true,\r\n            unformatOnSubmit             : true,\r\n            outputFormat                 : true,\r\n            isCancellable                : true,\r\n            modifyValueOnWheel           : true,\r\n            wheelStep                    : true,\r\n            showWarnings                 : true,\r\n            failOnUnknownOption          : true,\r\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\r\n            hasFocus             : true,\r\n            runOnce              : true,\r\n            rawValue             : true,\r\n            trailingNegative     : true,\r\n            caretFix             : true,\r\n            throwInput           : true,\r\n            strip                : true,\r\n            tagList              : true,\r\n            negativeSignCharacter: true,\r\n            positiveSignCharacter: true,\r\n            mIntPos              : true,\r\n            mIntNeg              : true,\r\n            oDec                 : true,\r\n            oPad                 : true,\r\n            oBracket             : true,\r\n            oSep                 : true,\r\n            oSign                : true,\r\n            oSuffix              : true,\r\n            aNegRegAutoStrip     : true,\r\n            skipFirstAutoStrip   : true,\r\n            skipLastAutoStrip    : true,\r\n            allowedAutoStrip     : true,\r\n            numRegAutoStrip      : true,\r\n            stripReg             : true,\r\n            holder               : true,\r\n        };\r\n\r\n        for (const option in options) {\r\n            if (options.hasOwnProperty(option)) {\r\n                if (oldOptionsConverter[option] === true) {\r\n                    // If the option is a 'new' option, we continue looping\r\n                    continue;\r\n                }\r\n\r\n                if (oldOptionsConverter.hasOwnProperty(option)) {\r\n                    // Else we have an 'old' option name\r\n                    warning(`You are using the deprecated option name '${option}'. Please use '${oldOptionsConverter[option]}' instead from now on. The old option name will be dropped soon.`, true);\r\n\r\n                    // Then we modify the initial option object to use the new options instead of the old ones\r\n                    options[oldOptionsConverter[option]] = options[option];\r\n                    delete options[option];\r\n                } else if (options.failOnUnknownOption) {\r\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\r\n                    throwError(`Option name '${option}' is unknown. Please fix the options passed to autoNumeric`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n     *\r\n     * @param {object} options\r\n     * @param {object} $this jQuery-selected DOM element\r\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\r\n     * @returns {object|null}\r\n     */\r\n    function getInitialSettings(options, $this, update = false) {\r\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\r\n        let settings = $this.data('autoNumeric');\r\n\r\n        // If the user used old options, we convert them to new ones\r\n        if (update || !isNull(options)) {\r\n            convertOldOptionsToNewOnes(options);\r\n        }\r\n\r\n        if (update || isUndefined(settings)) {\r\n            if (update) {\r\n                // The settings are updated\r\n                settings = $.extend(settings, options);\r\n            } else {\r\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\r\n                // The settings are generated for the first time\r\n                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\r\n                const tagData = $this.data();\r\n                settings = $.extend({}, defaultSettings, tagData, options, {\r\n                    hasFocus        : false,\r\n                    runOnce         : false,\r\n                    rawValue        : '',\r\n                    trailingNegative: false,\r\n                    caretFix        : false,\r\n                    throwInput      : true, // Throw input event\r\n                    strip           : true,\r\n                    tagList         : allowedTagList,\r\n                });\r\n            }\r\n\r\n            // Modify the user settings to make them 'exploitable'\r\n            transformOptionsValuesToDefaultTypes(settings);\r\n\r\n            // Improve the `negativePositiveSignPlacement` option if needed\r\n            correctNegativePositiveSignPlacementOption(settings);\r\n\r\n            // Set the negative and positive signs, as needed\r\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\r\n            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\r\n\r\n            // Additional changes to the settings object (from the original autoCode() function)\r\n            runCallbacksFoundInTheSettingsObject($this, settings);\r\n            calculateVMinAndVMaxIntegerSizes(settings);\r\n            correctDecimalPlacesOverrideOption(settings);\r\n            setsAlternativeDecimalSeparatorCharacter(settings);\r\n            cachesUsualRegularExpressions(settings);\r\n\r\n            // Validate the settings\r\n            validate(settings, false); // Throws if necessary\r\n\r\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\r\n            keepAnOriginalSettingsCopy(settings);\r\n\r\n            // Save our new settings\r\n            $this.data('autoNumeric', settings);\r\n\r\n            return settings;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert the `value` parameter that can either be :\r\n     * - a real number,\r\n     * - a string representing a real number, or\r\n     * - a string representing a localized number (with specific group separators and decimal character),\r\n     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\r\n     *\r\n     * This function returns `NaN` if such conversion fails.\r\n     *\r\n     * @param {int|float|string} value\r\n     * @param {object} settings\r\n     * @returns {string|NaN}\r\n     */\r\n    function toNumericValue(value, settings) {\r\n        let result;\r\n        if (isNumber(Number(value))) {\r\n            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\r\n            result = value;\r\n        } else {\r\n            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\r\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\r\n            result = convertToNumericString(value.toString(), settings);\r\n\r\n            // If the result is still not a numeric string, then we throw a warning\r\n            if (!isNumber(Number(result))) {\r\n                warning(`The value \"${value}\" being \"set\" is not numeric and therefore cannot be used appropriately.`, settings.showWarnings);\r\n                result = NaN;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Methods supported by autoNumeric\r\n     */\r\n    const methods = {\r\n        /**\r\n         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\r\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\r\n         */\r\n        init(options) {\r\n            return this.each(function() {\r\n                const $this = $(this);\r\n                const $input = getInputIfSupportedTagAndType($this);\r\n\r\n                const settings = getInitialSettings(options, $this, false);\r\n                if (isNull(settings)) {\r\n                    return this;\r\n                }\r\n\r\n                // Create the AutoNumericHolder object that store the field properties\r\n                const holder = getAutoNumericHolder($this, settings, false);\r\n\r\n                if (!settings.runOnce && settings.formatOnPageLoad) {\r\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\r\n                }\r\n\r\n                settings.runOnce = true;\r\n\r\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\r\n                if ($input) {\r\n                    this.addEventListener('focusin', e => { onFocusInAndMouseEnter($this, holder, e); }, false);\r\n                    this.addEventListener('focus', () => { onFocus(holder); }, false);\r\n                    this.addEventListener('mouseenter', e => { onFocusInAndMouseEnter($this, holder, e); }, false);\r\n                    this.addEventListener('blur', e => { onFocusOutAndMouseLeave($this, holder, e); }, false);\r\n                    this.addEventListener('mouseleave', e => { onFocusOutAndMouseLeave($this, holder, e); }, false);\r\n                    this.addEventListener('keydown', e => { onKeydown(holder, e); }, false);\r\n                    this.addEventListener('keypress', e => { onKeypress(holder, e); }, false);\r\n                    this.addEventListener('keyup', e => { onKeyup(holder, settings, e); }, false);\r\n                    this.addEventListener('blur', e => { onBlur(holder, e); }, false);\r\n                    this.addEventListener('paste', e => { onPaste($this, holder, e); }, false);\r\n                    this.addEventListener('wheel', e => { onWheel(holder, e); }, false);\r\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to stop and remove autoNumeric for the current element.\r\n         * Note: this does not remove the formatting.\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\r\n        destroy() {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    $this.val('');\r\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\r\n                    $this.removeData('autoNumeric');\r\n                    $this.off('.autoNumeric');\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\r\n        wipe() {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    $this.val('');\r\n                    settings.rawValue = '';\r\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method that updates the autoNumeric settings.\r\n         * It can be called multiple times if needed.\r\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\r\n         *\r\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\r\n         *\r\n         * @param {object} options\r\n         * @returns {*|jQuery}\r\n         */\r\n        update(options) {\r\n            return $(this).each(function() {\r\n                // Retrieve the current unformatted input value\r\n                const $this = getCurrentElement(this);\r\n                const strip = $this.autoNumeric('get');\r\n\r\n                // Update the settings\r\n                const settings = getInitialSettings(options, $this, true);\r\n\r\n                // Update the AutoNumericHolder object that store the field properties\r\n                getAutoNumericHolder($this, settings, true);\r\n\r\n                // Reformat the input value with the new settings\r\n                if ($this.val() !== '' || $this.text() !== '') {\r\n                    return $this.autoNumeric('set', strip);\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to format the value passed as a parameter.\r\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n         * and must contain only numbers and one decimal (period) character\r\n         *\r\n         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\r\n         *\r\n         * @param {*} newValue\r\n         * @returns {*|jQuery}\r\n         */\r\n        set(newValue) {\r\n            return $(this).each(function() {\r\n                if (newValue === null || isUndefined(newValue)) {\r\n                    return;\r\n                }\r\n\r\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings !== 'object') {\r\n                    throwError(`Initializing autoNumeric is required prior to calling the \"set\" method.`);\r\n                }\r\n                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\r\n                settings.trailingNegative = false;\r\n\r\n                const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\r\n\r\n                let value = toNumericValue(newValue, settings);\r\n                if (isNaN(value)) {\r\n                    return $this.val('');\r\n                }\r\n\r\n                if (value !== '') {\r\n                    const [minTest, maxTest] = checkIfInRangeWithOverrideOption(value, settings);\r\n                    // This test is needed by the showPositiveSign option\r\n                    const isZero = isZeroOrHasNoValue(value);\r\n                    if (isZero) {\r\n                        value = '0';\r\n                    }\r\n\r\n                    if (minTest && maxTest) {\r\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\r\n                            // to ensure rounding does not happen twice\r\n                            let hasBeenRounded = false;\r\n\r\n                            // rounds the the extended decimal places\r\n                            if (settings.decimalPlacesShownOnFocus) {\r\n                                const tempDecimal = settings.decimalPlacesOverride;\r\n                                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\r\n                                value = roundValue(value, settings);\r\n                                hasBeenRounded = true;\r\n                                settings.decimalPlacesOverride = tempDecimal;\r\n                            }\r\n\r\n                            if (settings.scaleDivisor && !settings.onOff) {\r\n                                value = toNumericValue(value, settings);\r\n                                value = value / settings.scaleDivisor;\r\n                                value = value.toString();\r\n                                if (settings.scaleDecimalPlaces) {\r\n                                    const tempDecimal = settings.decimalPlacesOverride;\r\n                                    settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\r\n                                    value = roundValue(value, settings);\r\n                                    hasBeenRounded = true;\r\n                                    settings.decimalPlacesOverride = tempDecimal;\r\n                                }\r\n                            }\r\n\r\n                            // Rounds if this has not been done already\r\n                            if (!hasBeenRounded) {\r\n                                value = roundValue(value, settings);\r\n                            }\r\n\r\n                            // Stores rawValue including the decimalPlacesShownOnFocus\r\n                            settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\r\n\r\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\r\n                            value = addGroupSeparators(value, settings);\r\n                        }\r\n\r\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\r\n                            saveValueToPersistentStorage($this[0], settings, 'set');\r\n                        }\r\n                    } else {\r\n                        settings.rawValue = '';\r\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\r\n                        const attemptedValue = value;\r\n                        value = '';\r\n                        if (!minTest) {\r\n                            $this.trigger('autoNumeric:minExceeded');\r\n                        }\r\n\r\n                        if (!maxTest) {\r\n                            $this.trigger('autoNumeric:maxExceeded');\r\n                        }\r\n\r\n                        throwError(`The value [${attemptedValue}] being set falls outside of the minimumValue [${settings.minimumValue}] and maximumValue [${settings.maximumValue}] range set for this element`);\r\n\r\n                        return $this.val('');\r\n                    }\r\n                } else {\r\n                    return $this.val('');\r\n                }\r\n\r\n                if (!settings.hasFocus && settings.scaleSymbol) {\r\n                    value = value + settings.scaleSymbol;\r\n                }\r\n\r\n                if ($input) {\r\n                    return $this.val(value);\r\n                }\r\n\r\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\r\n                    return $this.text(value);\r\n                }\r\n\r\n                return false;\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to un-format inputs.\r\n         * This is handy to use right before form submission.\r\n         *\r\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\r\n         * Please see option \"outputFormat\" for more details\r\n         *\r\n         * @example $(someSelector).autoNumeric('unSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\r\n        unSet() {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    settings.hasFocus = true;\r\n                    $this.val($this.autoNumeric('getLocalized'));\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Method to re-format inputs.\r\n         * This is handy to use right after form submission.\r\n         *\r\n         * This is called after the 'unSet' method to reformat the input\r\n         *\r\n         * @example $(someSelector).autoNumeric('reSet');\r\n         *\r\n         * @returns {*|jQuery}\r\n         */\r\n        reSet() {\r\n            return $(this).each(function() {\r\n                const $this = getCurrentElement(this);\r\n                const settings = $this.data('autoNumeric');\r\n                if (typeof settings === 'object') {\r\n                    $this.autoNumeric('set', $this.val());\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Return the unformatted value as a string.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('get');\r\n         *\r\n         * @returns {string}\r\n         */\r\n        get() {\r\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\r\n            const $this = getCurrentElement(this);\r\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\r\n            const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\r\n            const settings = $this.data('autoNumeric');\r\n            if (typeof settings !== 'object') {\r\n                throwError(`Initializing autoNumeric is required prior to calling the \"get\" method.`);\r\n            }\r\n\r\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\r\n            let value = '';\r\n            if ($input) {\r\n                value = $this.eq(0).val();\r\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\r\n                value = $this.eq(0).text();\r\n            } else {\r\n                throwError(`The \"<${$this.prop('tagName').toLowerCase()}>\" tag is not supported by autoNumeric`);\r\n            }\r\n\r\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\r\n                value = settings.rawValue;\r\n            } else {\r\n                // Test if the value is negative\r\n                const isValueNegative = isNegative(value);\r\n\r\n                if (!(/\\d/).test(value) && settings.emptyInputBehavior === 'focus') {\r\n                    return '';\r\n                }\r\n\r\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\r\n                    settings.hasFocus = true;\r\n                    value = toggleNegativeBracket(value, settings);\r\n                }\r\n\r\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\r\n                    // Strips trailing negative symbol\r\n                    value = stripAllNonNumberCharacters(value, settings, true);\r\n                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\r\n                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\r\n\r\n                    // Places the negative symbol in front of the trailing negative\r\n                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\r\n                        value = '-' + value;\r\n                    }\r\n                }\r\n\r\n                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\r\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\r\n                }\r\n            }\r\n\r\n            // Always return a numeric string\r\n            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\r\n            return trimPaddedZerosFromDecimalPlaces(value);\r\n        },\r\n\r\n        /**\r\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\r\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n         * - a plain number (if the setting 'number' is used).\r\n         *\r\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n         * Check the \"outputFormat\" option definition for more details.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getLocalized');\r\n         *\r\n         * @returns {*}\r\n         */\r\n        getLocalized() {\r\n            const $this = getCurrentElement(this);\r\n            let value = $this.autoNumeric('get');\r\n            const settings = $this.data('autoNumeric');\r\n\r\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\r\n                value = '0';\r\n            }\r\n\r\n            return toLocale(value, settings.outputFormat);\r\n        },\r\n\r\n        /**\r\n         * Return the input unformatted value as a real Javascript number.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('getNumber');\r\n         *\r\n         * @returns {number}\r\n         */\r\n        getNumber() {\r\n            const $this = getCurrentElement(this);\r\n            const value = $this.autoNumeric('get');\r\n\r\n            return toLocale(value, 'number');\r\n        },\r\n\r\n        /**\r\n         * Return the current formatted value of the autoNumeric element.\r\n         * @usage aNInput.autoNumeric('getFormatted'))\r\n         *\r\n         * @returns {string}\r\n         */\r\n        getFormatted() {\r\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\r\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\r\n                throwError('Unable to get the formatted string from the element.');\r\n            }\r\n\r\n            return this[0].value;\r\n        },\r\n\r\n        /**\r\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {string}\r\n         */\r\n        getString() {\r\n            return _getStringOrArray(false, this);\r\n        },\r\n\r\n        /**\r\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\r\n         *\r\n         * @returns {{}|[]}\r\n         */\r\n        getArray() {\r\n            return _getStringOrArray(true, this);\r\n        },\r\n\r\n        /**\r\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('getSettings');\r\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\r\n         *\r\n         * @returns {object}\r\n         */\r\n        getSettings() {\r\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\r\n            return this.data('autoNumeric');\r\n        },\r\n    };\r\n\r\n    /**\r\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n     * It initialize autoNumeric on the given element.\r\n     *\r\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\r\n     * @param {*} args\r\n     * @returns {*}\r\n     */\r\n    $.fn.autoNumeric = function(method, ...args) {\r\n        if (methods[method]) {\r\n            return methods[method].apply(this, args);\r\n        }\r\n\r\n        if (typeof method === 'object' || !method) {\r\n            // The options have been passed directly, without using a named method\r\n            return methods.init.apply(this, [method]);\r\n        }\r\n\r\n        throwError(`Method \"${method}\" is not supported by autoNumeric`);\r\n    };\r\n\r\n    /**\r\n     * Return the default autoNumeric settings.\r\n     *\r\n     * @returns {object}\r\n     */\r\n    getDefaultConfig = () => defaultSettings;\r\n\r\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\r\n\r\n    /**\r\n     * Return all the predefined language options in one object.\r\n     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\r\n     *\r\n     * @returns {object}\r\n     */\r\n    getLanguages = () => languageOption;\r\n\r\n    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\r\n\r\n    /**\r\n     * Public function that allows formatting without an element trigger.\r\n     *\r\n     * @param {number|string} value A number, or a string that represent a javascript number\r\n     * @param {object|null} options\r\n     * @returns {*}\r\n     */\r\n    autoFormat = (value, options = null) => {\r\n        if (isUndefined(value) || value === null) {\r\n            return null;\r\n        }\r\n\r\n        if (!isString(value) && !isNumber(value)) {\r\n            throwError(`The value \"${value}\" being \"set\" is not numeric and therefore cannot be used appropriately.`);\r\n        }\r\n\r\n        // Initiate a very basic settings object\r\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\r\n        if (value < 0) {\r\n            settings.negativeSignCharacter = '-';\r\n        }\r\n\r\n        if (isNull(settings.decimalPlacesOverride)) {\r\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\r\n        }\r\n\r\n        // Check the validity of the `value` parameter\r\n        // Convert the value to a numeric string, stripping unnecessary characters in the process\r\n        let valueString = toNumericValue(value, settings);\r\n        if (isNaN(valueString)) {\r\n            throwError(`The value [${valueString}] that you are trying to format is not a recognized number.`);\r\n        }\r\n\r\n        // Basic tests to check if the given valueString is valid\r\n        const [minTest, maxTest] = checkIfInRangeWithOverrideOption(valueString, settings);\r\n        if (!minTest || !maxTest) {\r\n            // Throw a custom event\r\n            triggerEvent('autoFormat.autoNumeric', document, `Range test failed`);\r\n            throwError(`The value [${valueString}] being set falls outside of the minimumValue [${settings.minimumValue}] and maximumValue [${settings.maximumValue}] range set for this element`);\r\n        }\r\n\r\n        // Everything is ok, proceed to rounding, formatting and grouping\r\n        valueString = roundValue(valueString, settings);\r\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\r\n        valueString = addGroupSeparators(valueString, settings);\r\n\r\n        return valueString;\r\n    };\r\n\r\n    $.fn.autoFormat = autoFormat; // The jQuery export\r\n\r\n    /**\r\n     * Public function that allows unformatting without an element.\r\n     *\r\n     * @param {string|number} value\r\n     * @param {object} options\r\n     * @returns {*}\r\n     */\r\n    autoUnFormat = (value, options) => {\r\n        if (isUndefined(value) || value === null) {\r\n            return null;\r\n        }\r\n\r\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\r\n        if (isNumber(value)) {\r\n            return Number(value);\r\n        }\r\n\r\n        if (isArray(value) || isObject(value)) { //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\r\n            // Check the validity of the `value` parameter\r\n            throwError(`A number or a string representing a number is needed to be able to unformat it, [${value}] given.`);\r\n        }\r\n\r\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\r\n        const allowed = `-0123456789\\\\${settings.decimalCharacter}`;\r\n        const autoStrip = new RegExp(`[^${allowed}]`, 'gi');\r\n        value = value.toString();\r\n\r\n        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\r\n        if (isNegative(value)) {\r\n            settings.negativeSignCharacter = '-';\r\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\r\n            settings.negativeSignCharacter = '-';\r\n            settings.hasFocus = true;\r\n            value = toggleNegativeBracket(value, settings);\r\n        }\r\n\r\n        value = value.replace(autoStrip, '');\r\n        value = value.replace(settings.decimalCharacter, '.');\r\n        value = toLocale(value, settings.outputFormat);\r\n\r\n        return value;\r\n    };\r\n\r\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\r\n\r\n    /**\r\n     * Validate the given option object.\r\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n     *\r\n     * This tests if the options are not conflicting and are well formatted.\r\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n     *\r\n     * @param {*} userOptions\r\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n     * @throws Error\r\n     */\r\n    validate = (userOptions, shouldExtendDefaultOptions = true) => {\r\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\r\n            throwError(`The userOptions are invalid ; it should be a valid object, [${userOptions}] given.`);\r\n        }\r\n\r\n        // If the user used old options, we convert them to new ones\r\n        if (!isNull(userOptions)) {\r\n            convertOldOptionsToNewOnes(userOptions);\r\n        }\r\n\r\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\r\n        let options;\r\n        if (shouldExtendDefaultOptions) {\r\n            options = $.extend({}, defaultSettings, userOptions);\r\n        } else {\r\n            options = userOptions;\r\n        }\r\n\r\n        // First things first, we test that the `showWarnings` option is valid\r\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\r\n            throwError(`The debug option 'showWarnings' is invalid ; it should be either 'false' or 'true', [${options.showWarnings}] given.`);\r\n        }\r\n\r\n        // Define the regular expressions needed for the following tests\r\n        const testPositiveInteger = /^[0-9]+$/;\r\n        const testNumericalCharacters = /[0-9]+/;\r\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\r\n        const testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\r\n        const testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\r\n\r\n        // Then tests the options individually\r\n        if (!isInArray(options.digitGroupSeparator, [\r\n            ',',      // Comma\r\n            '.',      // Dot\r\n            ' ',      // Normal space\r\n            '\\u2009', // Thin-space\r\n            '\\u202f', // Narrow no-break space\r\n            '\\u00a0', // No-break space\r\n            '',       // No separator\r\n            \"'\",      // Apostrophe\r\n            '',      // Arabic thousands separator\r\n            '',      // Dot above\r\n        ])) {\r\n            throwError(`The thousand separator character option 'digitGroupSeparator' is invalid ; it should be ',', '.', '', '', \"'\", ' ', '\\u2009', '\\u202f', '\\u00a0' or empty (''), [${options.digitGroupSeparator}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\r\n            throwError(`The 'noSeparatorOnFocus' option is invalid ; it should be either 'false' or 'true', [${options.noSeparatorOnFocus}] given.`);\r\n        }\r\n\r\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\r\n            throwError(`The digital grouping for thousand separator option 'digitalGroupSpacing' is invalid ; it should be a positive integer, [${options.digitalGroupSpacing}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.decimalCharacter, [\r\n            ',', // Comma\r\n            '.', // Dot\r\n            '', // Middle-dot\r\n            '', // Arabic decimal separator\r\n            '', // Decimal separator key symbol\r\n        ])) {\r\n            throwError(`The decimal separator character option 'decimalCharacter' is invalid ; it should be '.', ',', '', '' or '', [${options.decimalCharacter}] given.`);\r\n        }\r\n\r\n        // Checks if the decimal and thousand characters are the same\r\n        if (options.decimalCharacter === options.digitGroupSeparator) {\r\n            throwError(`autoNumeric will not function properly when the decimal character 'decimalCharacter' [${options.decimalCharacter}] and the thousand separator 'digitGroupSeparator' [${options.digitGroupSeparator}] are the same character.`);\r\n        }\r\n\r\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\r\n            throwError(`The alternate decimal separator character option 'decimalCharacterAlternative' is invalid ; it should be a string, [${options.decimalCharacterAlternative}] given.`);\r\n        }\r\n\r\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\r\n            throwError(`The currency symbol option 'currencySymbol' is invalid ; it should be a string, [${options.currencySymbol}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\r\n            throwError(`The placement of the currency sign option 'currencySymbolPlacement' is invalid ; it should either be 'p' (prefix) or 's' (suffix), [${options.currencySymbolPlacement}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\r\n            throwError(`The placement of the negative sign option 'negativePositiveSignPlacement' is invalid ; it should either be 'p' (prefix), 's' (suffix), 'l' (left), 'r' (right) or 'null', [${options.negativePositiveSignPlacement}] given.`);\r\n        }\r\n        \r\n        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\r\n            throwError(`The show positive sign option 'showPositiveSign' is invalid ; it should be either 'false' or 'true', [${options.showPositiveSign}] given.`);\r\n        }\r\n\r\n        if (!isString(options.suffixText) || (options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText)))) {\r\n            throwError(`The additional suffix option 'suffixText' is invalid ; it should not contains the negative sign '-' nor any numerical characters, [${options.suffixText}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\r\n            throwError(`The override min & max limits option 'overrideMinMaxLimits' is invalid ; it should either be 'ceiling', 'floor' or 'ignore', [${options.overrideMinMaxLimits}] given.`);\r\n        }\r\n\r\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\r\n            throwError(`The maximum possible value option 'maximumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.maximumValue}] given.`);\r\n        }\r\n\r\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\r\n            throwError(`The minimum possible value option 'minimumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.minimumValue}] given.`);\r\n        }\r\n\r\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\r\n            throwError(`The minimum possible value option is greater than the maximum possible value option ; 'minimumValue' [${options.minimumValue}] should be smaller than 'maximumValue' [${options.maximumValue}].`);\r\n        }\r\n\r\n        if (!(isNull(options.decimalPlacesOverride) ||\r\n            (isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0) || // If integer option\r\n            (isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)))  // If string option\r\n        ) {\r\n            throwError(`The maximum number of decimal places option 'decimalPlacesOverride' is invalid ; it should be a positive integer, [${options.decimalPlacesOverride}] given.`);\r\n        }\r\n\r\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\r\n        const vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\r\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\r\n            warning(`Setting 'decimalPlacesOverride' to [${options.decimalPlacesOverride}] will override the decimals declared in 'minimumValue' [${options.minimumValue}] and 'maximumValue' [${options.maximumValue}].`, options.showWarnings);\r\n        }\r\n\r\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\r\n            warning(`Setting 'allowDecimalPadding' to [false] will override the current 'decimalPlacesOverride' setting [${options.decimalPlacesOverride}].`, options.showWarnings);\r\n        }\r\n\r\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\r\n            throwError(`The number of expanded decimal places option 'decimalPlacesShownOnFocus' is invalid ; it should be a positive integer, [${options.decimalPlacesShownOnFocus}] given.`);\r\n        }\r\n\r\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\r\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\r\n            warning(`The extended decimal places 'decimalPlacesShownOnFocus' [${options.decimalPlacesShownOnFocus}] should be greater than the 'decimalPlacesOverride' [${options.decimalPlacesOverride}] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?`, options.showWarnings);\r\n        }\r\n\r\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\r\n            throwError(`The scale divisor option 'scaleDivisor' is invalid ; it should be a positive number, preferably an integer, [${options.scaleDivisor}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\r\n            throwError(`The scale number of decimals option 'scaleDecimalPlaces' is invalid ; it should be a positive integer, [${options.scaleDecimalPlaces}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\r\n            throwError(`The scale symbol option 'scaleSymbol' is invalid ; it should be a string, [${options.scaleSymbol}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\r\n            throwError(`The save to session storage option 'saveValueToSessionStorage' is invalid ; it should be either 'false' or 'true', [${options.saveValueToSessionStorage}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.onInvalidPaste, [\r\n            'error',\r\n            'ignore',\r\n            'clamp',\r\n            'truncate',\r\n            'replace',\r\n        ])) {\r\n            throwError(`The paste behavior option 'onInvalidPaste' is invalid ; it should either be 'error', 'ignore', 'clamp', 'truncate' or 'replace' (cf. documentation), [${options.onInvalidPaste}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.roundingMethod, [\r\n            'S',\r\n            'A',\r\n            's',\r\n            'a',\r\n            'B',\r\n            'U',\r\n            'D',\r\n            'C',\r\n            'F',\r\n            'N05',\r\n            'CHF',\r\n            'U05',\r\n            'D05',\r\n        ])) {\r\n            throwError(`The rounding method option 'roundingMethod' is invalid ; it should either be 'S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05' or 'D05' (cf. documentation), [${options.roundingMethod}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\r\n            throwError(`The control decimal padding option 'allowDecimalPadding' is invalid ; it should be either 'false' or 'true', [${options.allowDecimalPadding}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, [\r\n            '(,)',\r\n            '[,]',\r\n            '<,>',\r\n            '{,}',\r\n            //TODO Add the following brackets :\r\n            // ','\r\n            // ','\r\n            // ','\r\n            // ','\r\n            // ','\r\n            // ','\r\n        ])) {\r\n            throwError(`The brackets for negative values option 'negativeBracketsTypeOnBlur' is invalid ; it should either be '(,)', '[,]', '<,>' or '{,}', [${options.negativeBracketsTypeOnBlur}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\r\n            throwError(`The display on empty string option 'emptyInputBehavior' is invalid ; it should either be 'focus', 'press', 'always' or 'zero', [${options.emptyInputBehavior}] given.`);\r\n        }\r\n\r\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\r\n            throwError(`The leading zero behavior option 'leadingZero' is invalid ; it should either be 'allow', 'deny' or 'keep', [${options.leadingZero}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\r\n            throwError(`The format on initialization option 'formatOnPageLoad' is invalid ; it should be either 'false' or 'true', [${options.formatOnPageLoad}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\r\n            throwError(`The select number only option 'selectNumberOnly' is invalid ; it should be either 'false' or 'true', [${options.selectNumberOnly}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.defaultValueOverride) && (options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride))) {\r\n            throwError(`The unformatted default value option 'defaultValueOverride' is invalid ; it should be a string that represents a positive or negative number, [${options.defaultValueOverride}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\r\n            throwError(`The remove formatting on submit option 'unformatOnSubmit' is invalid ; it should be either 'false' or 'true', [${options.unformatOnSubmit}] given.`);\r\n        }\r\n\r\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, [\r\n            'string',\r\n            'number',\r\n            '.',\r\n            '-.',\r\n            ',',\r\n            '-,',\r\n            '.-',\r\n            ',-',\r\n        ])) {\r\n            throwError(`The custom locale format option 'outputFormat' is invalid ; it should either be null, 'string', 'number', '.', '-.', ',', '-,', '.-' or ',-', [${options.outputFormat}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.isCancellable) && !isBoolean(options.isCancellable)) {\r\n            throwError(`The cancellable behavior option 'isCancellable' is invalid ; it should be either 'false' or 'true', [${options.isCancellable}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.modifyValueOnWheel) && !isBoolean(options.modifyValueOnWheel)) {\r\n            throwError(`The increment/decrement on mouse wheel option 'modifyValueOnWheel' is invalid ; it should be either 'false' or 'true', [${options.modifyValueOnWheel}] given.`);\r\n        }\r\n\r\n        if (!(isString(options.wheelStep) || isNumber(options.wheelStep)) ||\r\n            (options.wheelStep !== 'progressive' && !testPositiveFloatOrInteger.test(options.wheelStep)) ||\r\n            Number(options.wheelStep) === 0) {\r\n            // We do not accept a step equal to '0'\r\n            throwError(`The wheel step value option 'wheelStep' is invalid ; it should either be the string 'progressive', or a number or a string that represents a positive number, [${options.wheelStep}] given.`);\r\n        }\r\n\r\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\r\n            throwError(`The debug option 'failOnUnknownOption' is invalid ; it should be either 'false' or 'true', [${options.failOnUnknownOption}] given.`);\r\n        }\r\n    };\r\n\r\n    $.fn.autoValidate = validate;\r\n\r\n    /**\r\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n     *\r\n     * @param {object} options\r\n     * @returns {boolean}\r\n     */\r\n    areSettingsValid = function(options) {\r\n        let isValid = true;\r\n        try {\r\n            validate(options);\r\n        }\r\n        catch (error) {\r\n            isValid = false;\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    /**\r\n     * Take an arabic number as a string and return a javascript number.\r\n     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\r\n     * This returns `NaN` is the conversion is not possible.\r\n     * Based on http://stackoverflow.com/a/17025392/2834898\r\n     *\r\n     * @param {string} arabicNumbers\r\n     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\r\n     * @param {boolean} parseDecimalCharacter\r\n     * @param {boolean} parseThousandSeparator\r\n     * @returns {string|number|NaN}\r\n     */\r\n    function arabicToLatinNumbers(arabicNumbers, returnANumber = true, parseDecimalCharacter = false, parseThousandSeparator = false) {\r\n        let result = arabicNumbers.toString();\r\n        if (result === '') {\r\n            return arabicNumbers;\r\n        }\r\n\r\n        if (parseDecimalCharacter) {\r\n            result = result.replace(//, '.'); // Decimal character\r\n        }\r\n\r\n        if (parseThousandSeparator) {\r\n            result = result.replace(//g, ''); // Thousand separator\r\n        }\r\n\r\n        // Replace the numbers only\r\n        result = result.replace(/[]/g, d => d.charCodeAt(0) - 1632) // Arabic numbers\r\n                       .replace(/[]/g, d => d.charCodeAt(0) - 1776); // Persian numbers\r\n\r\n        // `NaN` has precedence over the string `'NaN'`\r\n        const resultAsNumber = Number(result);\r\n        if (isNaN(resultAsNumber)) {\r\n            return resultAsNumber;\r\n        }\r\n\r\n        if (returnANumber) {\r\n            result = resultAsNumber;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a custom event and immediately sent it from the given element.\r\n     * By default, if no element is given, the event is thrown from `document`.\r\n     *\r\n     * @param {string} eventName\r\n     * @param {Element} element\r\n     * @param {object} detail\r\n     */\r\n    function triggerEvent(eventName, element = document, detail = null) {\r\n        let event;\r\n        if (window.CustomEvent) {\r\n            event = new CustomEvent(eventName, { detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\r\n        } else {\r\n            event = document.createEvent('CustomEvent');\r\n            event.initCustomEvent(eventName, true, true, { detail });\r\n        }\r\n\r\n        element.dispatchEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n     */\r\n    (function() {\r\n        if (typeof window.CustomEvent === 'function') {\r\n            return false;\r\n        }\r\n\r\n        function CustomEvent(event, params) {\r\n            params = params || { bubbles: false, cancelable: false, detail: void(0) };\r\n            const evt = document.createEvent('CustomEvent');\r\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n            return evt;\r\n        }\r\n\r\n        CustomEvent.prototype = window.Event.prototype;\r\n        window.CustomEvent = CustomEvent;\r\n    })();\r\n}));\r\n\r\n/**\r\n * Temporary class declaration for the AutoNumeric object that will replace the current export\r\n * cf. https://github.com/BobKnothe/autoNumeric/issues/399\r\n */\r\nclass AutoNumeric {\r\n    //\r\n}\r\n\r\n/**\r\n * Enumeration of the options values\r\n */\r\nAutoNumeric.options = {\r\n    digitGroupSeparator          : {\r\n        comma                   : ',',\r\n        dot                     : '.',\r\n        normalSpace             : ' ',\r\n        thinSpace               : '\\u2009',\r\n        narrowNoBreakSpace      : '\\u202f',\r\n        noBreakSpace            : '\\u00a0',\r\n        noSeparator             : '',\r\n        apostrophe              : \"'\",\r\n        arabicThousandsSeparator: '',\r\n        dotAbove                : '',\r\n    },\r\n    noSeparatorOnFocus           : {\r\n        noSeparator  : true,\r\n        withSeparator: false,\r\n    },\r\n    digitalGroupSpacing          : {\r\n        default: '3',\r\n    },\r\n    decimalCharacter             : {\r\n        comma                    : ',',\r\n        dot                      : '.',\r\n        middleDot                : '',\r\n        arabicDecimalSeparator   : '',\r\n        decimalSeparatorKeySymbol: '',\r\n    },\r\n    decimalCharacterAlternative  : {\r\n        none: null,\r\n    },\r\n    // cf. https://en.wikipedia.org/wiki/Currency_symbol\r\n    currencySymbol               : {\r\n        default       : '',\r\n        currencySign  : '',\r\n        austral       : '', // ARA\r\n        australCentavo: '',\r\n        baht          : '', // THB\r\n        cedi          : '', // GHS\r\n        cent          : '',\r\n        colon         : '', // CRC\r\n        cruzeiro      : '', // BRB\r\n        dollar        : '$',\r\n        dong          : '', // VND\r\n        drachma       : '', // GRD (or '.' or '.')\r\n        lepton        : '.', // cents of the Drachma\r\n        dram          : '', // AMD\r\n        european      : '', // XEU (old currency before the Euro)\r\n        euro          : '', // EUR\r\n        florin        : '',\r\n        franc         : '', // FRF\r\n        guarani       : '', // PYG\r\n        hryvnia       : '', // \r\n        kip           : '', // LAK\r\n        att           : '', // cents of the Kip\r\n        lira          : '', // TRY\r\n        liraOld       : '',\r\n        lari          : '', // GEL\r\n        mark          : '',\r\n        pfennig       : '', // cents of the Mark\r\n        mill          : '',\r\n        naira         : '', // NGN\r\n        peseta        : '',\r\n        peso          : '', // PHP\r\n        pound         : '',\r\n        riel          : '', // KHR\r\n        ruble         : '', // RUB\r\n        rupee         : '', // INR\r\n        rupeeOld      : '',\r\n        shekel        : '',\r\n        shekelAlt     : '',\r\n        taka          : '', // BDT\r\n        tenge         : '', // KZT\r\n        togrog        : '', // MNT\r\n        won           : '',\r\n        yen           : '',\r\n    },\r\n    currencySymbolPlacement      : {\r\n        prefix: 'p',\r\n        suffix: 's',\r\n    },\r\n    negativePositiveSignPlacement: {\r\n        prefix: 'p',\r\n        suffix: 's',\r\n        left  : 'l',\r\n        right : 'r',\r\n        none  : null,\r\n    },\r\n    showPositiveSign             : {\r\n        show: true,\r\n        hide: false,\r\n    },\r\n    suffixText                   : {\r\n        default: '',\r\n    },\r\n    overrideMinMaxLimits         : {\r\n        ceiling      : 'ceiling',\r\n        floor        : 'floor',\r\n        ignore       : 'ignore',\r\n        doNotOverride: null,\r\n    },\r\n    maximumValue                 : {\r\n        default: '9999999999999.99',\r\n    },\r\n    minimumValue                 : {\r\n        default: '-9999999999999.99',\r\n    },\r\n    decimalPlacesOverride        : {\r\n        default: null,\r\n    },\r\n    decimalPlacesShownOnFocus    : {\r\n        default: null,\r\n    },\r\n    scaleDivisor                 : {\r\n        default: null,\r\n    },\r\n    scaleDecimalPlaces           : {\r\n        default: null,\r\n    },\r\n    scaleSymbol                  : {\r\n        default: null,\r\n    },\r\n    saveValueToSessionStorage    : {\r\n        save     : true,\r\n        doNotSave: false,\r\n    },\r\n    onInvalidPaste               : {\r\n        error   : 'error',\r\n        ignore  : 'ignore',\r\n        clamp   : 'clamp',\r\n        truncate: 'truncate',\r\n        replace : 'replace',\r\n    },\r\n    roundingMethod               : {\r\n        halfUpSymmetric                : 'S',\r\n        halfUpAsymmetric               : 'A',\r\n        halfDownSymmetric              : 's',\r\n        halfDownAsymmetric             : 'a',\r\n        halfEvenBankersRounding        : 'B',\r\n        upRoundAwayFromZero            : 'U',\r\n        downRoundTowardZero            : 'D',\r\n        toCeilingTowardPositiveInfinity: 'C',\r\n        toFloorTowardNegativeInfinity  : 'F',\r\n        toNearest05                    : 'N05', // also 'CHF'\r\n        upToNext05                     : 'U05',\r\n        downToNext05                   : 'D05',\r\n    },\r\n    allowDecimalPadding          : {\r\n        padding  : true,\r\n        noPadding: false,\r\n    },\r\n    negativeBracketsTypeOnBlur   : {\r\n        parentheses: '(,)',\r\n        brackets   : '[,]',\r\n        chevrons   : '<,>',\r\n        curlyBraces: '{,}',\r\n        none       : null,\r\n    },\r\n    emptyInputBehavior           : {\r\n        focus : 'focus',\r\n        press : 'press',\r\n        always: 'always',\r\n        zero  : 'zero',\r\n    },\r\n    leadingZero                  : {\r\n        allow: 'allow',\r\n        deny : 'deny',\r\n        keep : 'keep',\r\n    },\r\n    formatOnPageLoad             : {\r\n        format     : true,\r\n        doNotFormat: false,\r\n    },\r\n    selectNumberOnly             : {\r\n        selectNumbersOnly: true,\r\n        selectAll        : false,\r\n    },\r\n    defaultValueOverride         : {\r\n        default: null,\r\n    },\r\n    unformatOnSubmit             : {\r\n        unformat        : true,\r\n        keepCurrentValue: false,\r\n    },\r\n    outputFormat                 : {\r\n        string       : 'string',\r\n        number       : 'number',\r\n        dot          : '.',\r\n        negativeDot  : '-.',\r\n        comma        : ',',\r\n        negativeComma: '-,',\r\n        dotNegative  : '.-',\r\n        commaNegative: ',-',\r\n        none         : null,\r\n    },\r\n    isCancellable                : {\r\n        cancellable   : true,\r\n        notCancellable: false,\r\n    },\r\n    modifyValueOnWheel           : {\r\n        modifyValue: true,\r\n        doNothing  : false,\r\n    },\r\n    wheelStep                    : {\r\n        progressive: 'progressive',\r\n    },\r\n    showWarnings                 : {\r\n        show: true,\r\n        hide: false,\r\n    },\r\n    failOnUnknownOption          : {\r\n        fail  : true,\r\n        ignore: false,\r\n    },\r\n};\r\n\r\n/**\r\n * This exports the interface for the autoNumeric object\r\n */\r\nexport default {\r\n    AutoNumeric,\r\n    format  : autoFormat,\r\n    unFormat: autoUnFormat,\r\n    getDefaultConfig,\r\n    getLanguages,\r\n    validate, // an.validate(options) : throws if necessary\r\n    areSettingsValid, // an.areSettingsValid(options) : return true or false //TODO Is this redundant? Should we let the developers wrap each autoNumeric.validate() calls in try/catch block? Or should we just facilitate their life by doing it already?\r\n\r\n    //TODO Complete the interface with functions having the following signatures :\r\n    //init         : an.init(options, input)\r\n    //get          : an.get(input)\r\n    //set          : an.set(value, input)\r\n    //formString   : an.formString(form)\r\n    //formArray    : an.formArray(form)\r\n    //getFormatted : an.getFormatted(input)\r\n    //unset        : an.unset(input) //to rename to 'unformat'? (and merge with autoUnFormat/unFormat?)\r\n    //reformat     : an.reformat(input) // 'reSet' is very to close to 'reset' and therefore should be renamed. We could still expose 'reSet', but add a @deprecated tag on its declaration.\r\n    //settings     : an.settings(input)\r\n    //update       : an.update(options, input)\r\n    //wipe         : an.wipe(input)\r\n    //destroy      : an.destroy(input)\r\n\r\n    //raw          : an.raw(input) // Return the unformatted value as a string\r\n    //number       : an.number(input) // Return the unformatted value as a number (Warning: This can lead to precision problems with big numbers)\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/autoNumeric.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}