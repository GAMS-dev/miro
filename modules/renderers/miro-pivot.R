getIndexLists <- function(setIndices, options = list()){
  unassignedSetIndices <- setIndices
  indices <- list(rows = character(0L),
                  cols = character(0L),
                  filter = character(0L),
                  aggregations = character(0L))
  
  for(id in c("cols", "filter", "aggregations")) {
    indexIds <- match(names(options[[id]]), unassignedSetIndices)
    indexIds <- indexIds[!is.na(indexIds)]
    indices[[id]] <- unassignedSetIndices[indexIds]
    if(length(indexIds))
      unassignedSetIndices <- unassignedSetIndices[-indexIds]
  }
  indices[["rows"]] <- unassignedSetIndices
  return(indices)
}
genIndexList <- function(indexList) {
  return(lapply(seq_along(indexList), function(idx){
    tags$li(class = "drop-index-item", "data-rank-id" = indexList[idx],
            names(indexList)[idx])
  }))
}
createBootstrapDropdownChoices <- function(el, eventId, deleteEventId = NULL){
  tags$li(id = paste0(eventId, "_", el$id), style = "display:flex;position:relative;",
          tags$a(class="dropdown-item", role = "button", el$alias, 
                 style = "width: 100%",
                 onClick = paste0("Shiny.setInputValue('", eventId, "','",
                                  el$id, "',{priority:\'event\'});")),
          if(!is.null(deleteEventId))
            tags$a(role = "button", icon("times"), class = "miro-pivot-delete-view-button",
                   onClick = paste0("Shiny.setInputValue('", deleteEventId, "','",
                                    el$id, "',{priority:\'event\'});")))
}

miroPivotOutput <- function(id, height = NULL, options = NULL, path = NULL){
  ns <- NS(id)
  
  if(is.null(options[["_metadata_"]]$headers)){
    unassignedSetIndices <- c()
  }else{
    unassignedSetIndices <- setNames(names(options[["_metadata_"]]$headers),
                                     vapply(options[["_metadata_"]]$headers, "[[", character(1L),
                                            "alias", USE.NAMES = FALSE))
  }
  
  noNumericCol <- sum(vapply(options[["_metadata_"]]$headers, function(header){
    return(identical(header$type, "numeric"))}, logical(1L)))
  
  if(noNumericCol > 1L){
    # symbol is table and needs to be pivoted
    unassignedSetIndices <- c(unassignedSetIndices[seq_len(length(unassignedSetIndices) - noNumericCol)], 
                              Header = "Hdr")
  }else{
    unassignedSetIndices <- unassignedSetIndices[-length(unassignedSetIndices)]
  }
  
  indices <- getIndexLists(unassignedSetIndices, options)
  
  aggregationFunctions <- if(identical(options[["_metadata_"]]$symtype, "parameter"))
    setNames(c("sum", "count", "mean", "median", "min", "max"), 
             c(lang$renderers$miroPivot$aggregationFunctions$sum,
               lang$renderers$miroPivot$aggregationFunctions$count,
               lang$renderers$miroPivot$aggregationFunctions$mean,
               lang$renderers$miroPivot$aggregationFunctions$median,
               lang$renderers$miroPivot$aggregationFunctions$min,
               lang$renderers$miroPivot$aggregationFunctions$max)) 
  else
    setNames("count", lang$renderers$miroPivot$aggregationFunctions$count)
  
  tags$div(id = ns("container"),
           if(length(options$domainFilter$domains)){
             fluidRow(style = "margin:0",
                      do.call(tabsetPanel, 
                              c(id = ns("domainFilter"), 
                                selected = options$domainFilter$default,
                                lapply(options$domainFilter$domains, function(domain){
                                  domainId <- match(domain, unassignedSetIndices)
                                  return(tabPanel(title = names(unassignedSetIndices)[domainId], 
                                                  value = domain))
                                })))
             )
           },
           fluidRow(style = "margin:0", 
                    column(width = 2L, style = "padding: 1em;",
                           tags$ul(id = ns("filterIndexList"), 
                                   class="drop-index-list filter-index-list",
                                   genIndexList(indices$filter)
                           ),
                           if(!isFALSE(options$enablePersistentViews)){
                             tagList(
                               actionButton(ns("saveView"), label = NULL, icon = icon("plus-square"), 
                                            title = lang$renderers$miroPivot$btNewView),
                               downloadButton(ns("downloadCsv"), label = NULL,
                                              title = lang$renderers$miroPivot$btDownloadCsv),
                               tags$div(class="dropdown", style = "margin-top:10px;",
                                        tags$button(class="btn btn-default dropdown-toggle btn-dropdown",
                                                    type = "button", id = ns("toggleViewButton"),
                                                    `data-toggle`="dropdown", `aria-haspopup`="true",
                                                    `aria-expanded` = "false", style = "width:100%",
                                                    lang$renderers$miroPivot$btLoadView, tags$span(
                                                      class = "caret btn-dropdown-caret")),
                                        tags$ul(id = ns("savedViewsDD"), class = "dropdown-menu btn-dropdown-menu",
                                                `aria-labelledby` = ns("toggleViewButton"),
                                        ))
                             )
                           }else{
                             downloadButton(ns("downloadCsv"), label = lang$renderers$miroPivot$btDownloadCsv)
                           }
                    ),
                    column(width = 4L, style = "padding: 1em;", 
                           tags$div(id = ns("filterDropdowns"), class = "miro-pivot-filter")),
                    column(width = 4L, style = "padding: 1em;", 
                           tags$div(id = ns("aggregateDropdowns"), class = "miro-pivot-filter")),
                    column(width = 2L, style = "padding: 1em;",
                           tags$ul(id = ns("aggregationIndexList"), class="drop-index-list aggregation-index-list",
                                   genIndexList(indices$aggregations)),
                           selectInput(ns("aggregationFunction"), label = NULL, 
                                       choices = aggregationFunctions,
                                       selected = if(length(options$aggregationFunction)) 
                                         options$aggregationFunction else aggregationFunctions[[1]]))),
           fluidRow(style = "margin:0", 
                    column(width = 2L,
                           selectInput(ns("pivotRenderer"), "", 
                                       setNames(c("table", "bar", "stackedbar", "line", "radar"),
                                                c(lang$renderers$miroPivot$renderer$table,
                                                  lang$renderers$miroPivot$renderer$bar,
                                                  lang$renderers$miroPivot$renderer$stackedbar,
                                                  lang$renderers$miroPivot$renderer$line,
                                                  lang$renderers$miroPivot$renderer$radar)),
                                       selected = if(length(options$pivotRenderer))
                                         options$pivotRenderer else "table")),
                    column(width = 6L, style = "padding: 1em;",
                           tags$ul(id = ns("colIndexList"), class="drop-index-list vertical-index-list",
                                   genIndexList(indices$cols))),
                    column(width = 4L, style = "padding: 1em;", 
                           tags$div(id = ns("colDropdowns"), class = "miro-pivot-filter"))),
           fluidRow(style = "margin:0", column(width = 2L, style = "padding: 1em;", 
                                               tags$ul(id = ns("rowIndexList"), class="drop-index-list",
                                                       genIndexList(indices$rows))),
                    column(width = 10L,
                           style = "min-height: 400px;",
                           if(isTRUE(options$input)){
                             tagList(
                               actionButton(ns("btAddRow"), lang$renderers$miroPivot$btAddRow),
                               actionButton(ns("btRemoveRows"), lang$renderers$miroPivot$btRemoveRows, class = "bt-remove"),
                               actionButton(ns("enableEdit"), lang$renderers$miroPivot$btEnableEdit,
                                            style = "display:none")
                             )
                           },
                           tags$div(id = ns("errMsg"), class = "gmsalert gmsalert-error", 
                                    style = "position:static;margin-bottom:5px;"),
                           genSpinner(ns("loadPivotTable"), hidden = TRUE),
                           DTOutput(ns("pivotTable")),
                           chartjsOutput(ns("pivotChart"), height = "40px")
                    )),
           sortable_js(ns("filterIndexList"), 
                       options = sortable_options(group = ns("indices"), supportPointer = FALSE,
                                                  onLoad = sortable_js_capture_input(ns("filterIndexList")),
                                                  onSort = sortable_js_capture_input(ns("filterIndexList")))),
           sortable_js(ns("rowIndexList"), 
                       options = sortable_options(group = ns("indices"), supportPointer = FALSE,
                                                  onLoad = sortable_js_capture_input(ns("rowIndexList")),
                                                  onSort = sortable_js_capture_input(ns("rowIndexList")))),
           sortable_js(ns("colIndexList"), 
                       options = sortable_options(group = ns("indices"), supportPointer = FALSE, direction = "vertical", 
                                                  onLoad = sortable_js_capture_input(ns("colIndexList")),
                                                  onSort = sortable_js_capture_input(ns("colIndexList")))),
           sortable_js(ns("aggregationIndexList"), 
                       options = sortable_options(group = ns("indices"), supportPointer = FALSE,
                                                  onLoad = sortable_js_capture_input(ns("aggregationIndexList")),
                                                  onSort = sortable_js_capture_input(ns("aggregationIndexList"))))
  )
}

renderMiroPivot <- function(id, data, options = NULL, path = NULL, roundPrecision = 2L, rendererEnv = NULL, views = NULL){
  moduleServer(
    id,
    function(input, output, session) {
      
      ns <- session$ns
      
      valueColName <- names(data)[length(data)]
      allPlaceholder <- setNames("", lang$renderers$miroPivot$allPlaceholder)
      
      initFilter <- TRUE
      initData <- TRUE
      initRenderer <- TRUE
      initInterface <- TRUE
      numericCols <- vapply(data, class, character(1L), USE.NAMES = FALSE) %in% c("numeric", "integer")
      if(sum(numericCols) > 1L){
        # data is already pivoted
        flog.warn("MIRO Pivot should not be used to render a symbol that is already pivoted. Please declare your symbol as parameter and not as table.")
        data <- pivot_longer(data, names(data)[numericCols], names_to = "Hdr", 
                             values_to = "value", names_repair = "unique")
        valueColName <- "value"
      }else if(sum(numericCols) == 0L){
        # data is a set -> drop last column and replace with 1
        data[, length(data)] <- 1L
        names(data) <- c(names(data)[-length(data)], "value")
        valueColName <- "value"
      }
      data <- mutate_if(data, is.character, as.factor)
      
      noColDim <- 1L
      setIndices <- names(data)[-length(data)]
      
      noRowDim <- length(data) - 1L
      
      updateFilter <- reactiveVal(1L)
      
      isInput <- isTRUE(options$input)
      isEditable <- FALSE
      bigData <- FALSE
      
      if(isInput){
        dataUpdated <- reactiveVal(1L)
        if(nrow(data) < 5e+05){
          isEditable <- TRUE
          data <- unite(data, "__key__", !!!setIndices,
                        remove = FALSE, sep = "\U2024", na.rm = FALSE)
        }else{
          bigData <- TRUE
          showEl(session, paste0("#", ns("enableEdit")))
          hideEl(session, paste0("#", ns("btAddRow")))
          hideEl(session, paste0("#", ns("btRemoveRows")))
          rendererEnv[[ns("enableEdit")]] <- observe({
            if(length(input$enableEdit) != 1L || input$enableEdit == 0L){
              return()
            }
            showEl(session, "#loading-screen")
            on.exit(hideEl(session, "#loading-screen"))
            data <<- unite(data, "__key__", !!!setIndices,
                           remove = FALSE, sep = "\U2024", na.rm = FALSE)
            isEditable <<- TRUE
            hideEl(session, paste0("#", ns("enableEdit")))
            showEl(session, paste0("#", ns("btAddRow")))
            showEl(session, paste0("#", ns("btRemoveRows")))
          })
        }
      }
      
      noUpdateFilterEl <- logical(length(setIndices))
      names(noUpdateFilterEl) <- setIndices
      
      setIndexAliases <- vapply(options[["_metadata_"]]$headers, "[[", character(1L),
                                "alias", USE.NAMES = FALSE)[seq_along(setIndices)]
      if(sum(numericCols) > 1L){
        setIndexAliases[length(setIndices)] <- "Header"
      }
      
      indices <- character(0L)
      # we need to update aggregation functions in case the symbol type is not available when rendering the UI
      # (e.g. in Configuration Mode)
      aggregationFunctions <- if(identical(options[["_metadata_"]]$symtype, "parameter"))
        setNames(c("sum", "count", "mean", "median", "min", "max"), 
                 c(lang$renderers$miroPivot$aggregationFunctions$sum,
                   lang$renderers$miroPivot$aggregationFunctions$count,
                   lang$renderers$miroPivot$aggregationFunctions$mean,
                   lang$renderers$miroPivot$aggregationFunctions$median,
                   lang$renderers$miroPivot$aggregationFunctions$min,
                   lang$renderers$miroPivot$aggregationFunctions$max)) 
      else
        setNames("count", lang$renderers$miroPivot$aggregationFunctions$count)
      
      customChartColors <- c("#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", 
                             "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", 
                             "#cab2d6", "#6a3d9a", "#ffff99", "#b15928", 
                             "#FCDCDB", "#f9b9b7", "#D5D3DA", "#ada9b7", 
                             "#e2546b", "#66101F", "#E0ABD7", "#c45ab3", 
                             "#8bf2fe", "#1BE7FF", "#a1d1b6", "#4C9F70", 
                             "#F6FAA9", "#f0f757", "#d3b499", "#9E6D42", 
                             "#50caf3", "#086788", "#eee49d", "#E0CA3C", 
                             "#dbcac7", "#BA9790", "#f69e84", "#EB4511", 
                             "#ccadf1", "#9B5DE5", "#A1FB8B", "#47fa1a", 
                             "#8dadd0", "#38618c", "#fcebea", "#fad8d6", 
                             "#a6b474", "#373d20", "#a248ce", "#210b2c", 
                             "#f37ea9", "#d81159", "#68f7f7", "#08bdbd", 
                             "#98feb1", "#35ff69", "#d27193", "#6d213c", 
                             "#edfab1", "#dcf763", "#feb46f", "#e06c00", 
                             "#f3ebaa", "#e9d758", "#c0c7c7", "#829191", 
                             "#f3cac5", "#E8998D", "#c7dac9", "#91b696", 
                             "#BE99A4", "#714955", "#7c7ccf", "#2a2a72", 
                             "#7efee0", "#00ffc5", "#c28eb1", "#6c3a5c", 
                             "#df7192", "#8b1e3f", "#95D86B", "#3E721D")
      
      resetView <- function(options, domainFilterDomains){
        unassignedSetIndices <- setNames(setIndices, 
                                         setIndexAliases)
        
        indices <<- getIndexLists(unassignedSetIndices, options)
        for(indexEl in list(c("filter", "filterIndexList"),
                            c("rows", "rowIndexList"), 
                            c("cols", "colIndexList"),
                            c("aggregations", "aggregationIndexList"))) {
          session$sendCustomMessage("gms-updateSortable", 
                                    list(id = ns(indexEl[[2]]), 
                                         children = lapply(genIndexList(indices[[indexEl[[1]]]]), 
                                                           as.character)))
        }
        
        if(length(options[["pivotRenderer"]]) &&
           options[["pivotRenderer"]] %in% c("table", "line", "bar", "stackedbar", "radar")){
          updateSelectInput(session, "pivotRenderer", selected = options[["pivotRenderer"]])
        }else{
          updateSelectInput(session, "pivotRenderer", selected = "table")
        }
        newView <- list(filter = unname(indices$filter),
                        aggregations = unname(indices$aggregations),
                        cols = unname(indices$cols))
        if(length(domainFilterDomains)){
          if(length(options[["domainFilter"]][["default"]]) &&
             options[["domainFilter"]][["default"]] %in% domainFilterDomains){
            updateTabsetPanel(session, "domainFilter", 
                              selected = options[["domainFilter"]][["default"]])
            newView$domainFilter <- options[["domainFilter"]][["default"]]
          }else{
            updateTabsetPanel(session, "domainFilter", 
                              selected = domainFilterDomains[[1]])
            newView$domainFilter <- domainFilterDomains[[1]]
          }
        }
        if(initInterface){
          # we need to update aggregation functions in case the symbol type is not available when rendering the UI
          # (e.g. in Configuration Mode)
          if(length(options[["aggregationFunction"]]) &&
             options[["aggregationFunction"]] %in% aggregationFunctions){
            updateSelectInput(session, "aggregationFunction", choices = aggregationFunctions, 
                              selected = options[["aggregationFunction"]])
          }else{
            updateSelectInput(session, "aggregationFunction", choices = aggregationFunctions, 
                              selected = aggregationFunctions[[1]])
          }
        }else{
          if(length(options[["aggregationFunction"]]) &&
             options[["aggregationFunction"]] %in% aggregationFunctions){
            updateSelectInput(session, "aggregationFunction",
                              selected = options[["aggregationFunction"]])
          }else{
            updateSelectInput(session, "aggregationFunction",
                              selected = aggregationFunctions[[1]])
          }
          initFilter <<- TRUE
          initData   <<- TRUE
          initRenderer <<- TRUE
          options$resetOnInit <<- TRUE
          noUpdateFilterEl[] <<- FALSE
          isolate({
            if(identical(currentFilters(), newView)){
              newVal <- updateFilter() + 1L
              updateFilter(newVal)
            }
          })
        }
      }
      
      if(isTRUE(options$resetOnInit)){
        resetView(options, options[["domainFilter"]]$domains)
      }
      
      setIndexAliases <- as.list(setIndexAliases)
      names(setIndexAliases) <- setIndices
      currentView <- options
      
      if(!isFALSE(options$enablePersistentViews)){
        updateViewList <- function(){
          removeUI(paste0("#", ns("savedViewsDD"), " li"), multiple = TRUE)
          
          viewChoices <- lapply(views$getIds(session), function(viewId){
            createBootstrapDropdownChoices(list(id = htmlIdEnc(viewId), 
                                                alias = viewId), 
                                           ns("savedViews"), ns("deleteView"))
          })
          insertUI(paste0("#", ns("savedViewsDD")), 
                   c(list(createBootstrapDropdownChoices(list(id = "iZGVmYXVsdA--", 
                                                              alias = "default"), 
                                                         ns("savedViews"))),
                     viewChoices), 
                   where = "beforeEnd")
        }
        updateViewList()
        readonlyViews <- views$isReadonly(session)
        if(readonlyViews){
          disableEl(session, paste0("#", ns("saveView")))
        }else{
          views$registerUpdateCallback(session, updateViewList)
        }
        
        rendererEnv[[ns("saveView")]] <- observe({
          if(is.null(input$saveView) || initData || input$saveView == 0L || readonlyViews){
            return()
          }
          showModal(modalDialog(tags$div(id = ns("errUniqueName"), class = "gmsalert gmsalert-error", 
                                         style = "position:relative",
                                         lang$renderers$miroPivot$errUniqueViewName),
                                textInput(ns("newViewName"),
                                          lang$renderers$miroPivot$newViewLabel), 
                                footer = tagList(
                                  modalButton(lang$renderers$miroPivot$newViewBtCancel),
                                  actionButton(ns("saveViewConfirm"), lang$renderers$miroPivot$newViewBtSave, 
                                               class = "bt-highlight-1 bt-gms-confirm")
                                ),
                                fade = TRUE, easyClose = FALSE, size = "s", 
                                title = lang$renderers$miroPivot$newViewTitle))
        })
        rendererEnv[[ns("saveViewConfirm")]] <- observe({
          if(is.null(input$saveViewConfirm) || initData || 
             input$saveViewConfirm == 0L || readonlyViews){
            return()
          }
          isolate({
            if(identical(input$newViewName, "")){
              return()
            }
            if(input$newViewName %in% c("default", views$getIds(session))){
              showEl(session, paste0("#", ns("errUniqueName")))
              return()
            }
            newViewConfig <- list(aggregationFunction = input$aggregationFunction,
                                  pivotRenderer = input$pivotRenderer,
                                  domainFilter = list(default = input$domainFilter))
            for(indexEl in list(c("rows", "rowIndexList"))){
              indexVal <- input[[indexEl[[2]]]]
              if(length(indexVal)){
                newViewConfig[[indexEl[[1]]]] <- indexVal
              }
            }
            for(indexEl in list(c("aggregations", "aggregationIndexList"), 
                                c("filter", "filterIndexList"),
                                c("cols", "colIndexList"))){
              indexVal <- input[[indexEl[[2]]]]
              if(length(indexVal)){
                filterElList <- lapply(indexVal, function(el){
                  return(input[[paste0("filter_", el)]])
                })
                names(filterElList) <- indexVal
                newViewConfig[[indexEl[[1]]]] <- filterElList
              }
            }
            insertUI(paste0("#", ns("savedViewsDD")), 
                     createBootstrapDropdownChoices(list(id = htmlIdEnc(input$newViewName), 
                                                         alias = input$newViewName), 
                                                    ns("savedViews"), ns("deleteView")), 
                     where = "beforeEnd")
            views$add(session, input$newViewName, newViewConfig)
          })
          removeModal(session)
        })
        rendererEnv[[ns("deleteView")]] <- observe({
          if(is.null(input$deleteView) || initData || readonlyViews){
            return()
          }
          viewId <- htmlIdDec(input$deleteView)
          if(length(viewId) != 1L || 
             !viewId %in% c("default", views$getIds(session))){
            flog.error("Invalid view id: '%s' attempted to be removed This looks like an attempt to tamper with the app!",
                       input$deleteView)
            return()
          }
          views$remove(session, viewId)
          removeUI(paste0("#", ns("savedViews"), "_", stri_replace_all(input$deleteView, "\\.", fixed = ".")))
        })
        rendererEnv[[ns("savedViews")]] <- observe({
          if(is.null(input$savedViews) || initData){
            return()
          }
          viewId <- htmlIdDec(input$savedViews)
          if(length(viewId) != 1L || 
             !viewId %in% c("default", views$getIds(session))){
            flog.error("Invalid view id: '%s' attempted to be loaded. This looks like an attempt to tamper with the app!",
                       input$savedViews)
            return()
          }
          currentView <<- if(identical(viewId, "default")) options else 
            views$get(session, viewId)
          resetView(currentView, options[["domainFilter"]]$domains)
        })
      }
      
      output$downloadCsv <- downloadHandler(filename = paste0(options[["_metadata_"]]$symname, ".csv"),
                                            content = function(file) {
                                              write_csv(dataToRender(), file, na = "")
                                            })
      rendererEnv[[ns("filterDropdowns")]] <- observe({
        filterElements <- filteredData()$filterElements
        if(is.null(filteredData())){
          return()
        }
        initData <- initFilter
        if(initFilter && isTRUE(options$resetOnInit)){
          filterIndexList <- unname(indices[["filter"]])
          aggregationIndexList <- unname(indices[["aggregations"]])
          colIndexList <- unname(indices[["cols"]])
        }else{
          filterIndexList <- isolate(input$filterIndexList)
          aggregationIndexList <- isolate(input$aggregationIndexList)
          colIndexList <- isolate(input$colIndexList)
        }
        getFilterDropdowns <- function(filterIndex, optionId = "filter"){
          allowEmpty <- optionId %in% c("aggregations", "cols")
          if(initData && (allowEmpty || length(currentView[[optionId]][[filterIndex]]))){
            currentFilterVal <- currentView[[optionId]][[filterIndex]]
            if(!identical(isolate(input[[paste0("filter_", filterIndex)]]), currentFilterVal))
              noUpdateFilterEl[[filterIndex]] <<- TRUE
          }else{
            currentFilterVal <- isolate(input[[paste0("filter_", filterIndex)]])
          }
          availableFilterVal <- currentFilterVal %in% filterElements[[filterIndex]]
          if(any(availableFilterVal)) {
            selectedFilterVal <- currentFilterVal[availableFilterVal]
          }else{
            if(allowEmpty){
              selectedFilterVal <- ""
              if(!is.null(isolate(input[[paste0("filter_", filterIndex)]])))
                noUpdateFilterEl[[filterIndex]] <<- TRUE
            }else{
              selectedFilterVal <- filterElements[[filterIndex]][1]
              if(identical(isolate(input[[paste0("filter_", filterIndex)]]), selectedFilterVal)){
                noUpdateFilterEl[[filterIndex]] <<- FALSE
              }else{
                noUpdateFilterEl[[filterIndex]] <<- TRUE
              }
            }
          }
          serverSelectInput(session, ns(paste0("filter_", filterIndex)), setIndexAliases[[filterIndex]], 
                            choices = if(allowEmpty) c(allPlaceholder, as.character(filterElements[[filterIndex]]))
                            else as.character(filterElements[[filterIndex]]), 
                            selected = selectedFilterVal, multiple = TRUE,
                            options = list('plugins' = list('remove_button')))
        }
        initFilter <<- FALSE
        session$
          sendCustomMessage("gms-populateMiroPivotFilters", 
                            list(ns = ns(""),
                                 filter = htmltools::doRenderTags(
                                   lapply(filterIndexList, getFilterDropdowns)),
                                 aggregations = htmltools::doRenderTags(
                                   lapply(aggregationIndexList, getFilterDropdowns, optionId = "aggregations")),
                                 cols = htmltools::doRenderTags(
                                   lapply(colIndexList, getFilterDropdowns, optionId = "cols"))))
      })
      
      
      currentFilters <- reactiveVal(NULL)
      rendererEnv[[ns("currentFilters")]] <- observe({
        newFilters <- list(filter = input$filterIndexList,
                           aggregations = input$aggregationIndexList,
                           cols = input$colIndexList)
        if(sum(vapply(newFilters, length, integer(1L), USE.NAMES = FALSE)) +
           length(input$rowIndexList) != length(setIndices) ||
           any(vapply(newFilters, is.null, logical(1L), USE.NAMES = FALSE))){
          # UI not initialised
          return()
        }
        if(initFilter && isTRUE(options$resetOnInit)){
          newFilters <- list(filter = unname(indices[["filter"]]),
                             aggregations = unname(indices[["aggregations"]]),
                             cols = unname(indices[["cols"]]))
        }
        if(length(options$domainFilter$domains)){
          newFilters$domainFilter <- input$domainFilter
          if(initFilter && length(currentView$domainFilter[["default"]]) &&
             !identical(input$domainFilter, currentView$domainFilter[["default"]])){
            return()
          }
        }
        
        isolate({
          currentFilters(newFilters)
        })
      })
      
      lapply(setIndices, function(filterIndex){
        rendererEnv[[ns(paste0("filter_", filterIndex))]] <- observe({
          if(is.null(input[[paste0("filter_", filterIndex)]])){
            if(!filterIndex %in% isolate(c(input$aggregationIndexList, input$colIndexList))){
              return()
            }
          }
          if(isFALSE(noUpdateFilterEl[[filterIndex]])){
            isolate({
              newVal <- updateFilter() + 1L
              updateFilter(newVal)
            })
          }else{
            noUpdateFilterEl[[filterIndex]] <<- FALSE
          }
        })
      })
      
      filteredData <- reactive({
        updateFilter()
        if(is.null(currentFilters())){
          return()
        }
        filterIndexList <- currentFilters()$filter
        aggFilterIndexList <- currentFilters()$aggregations
        colFilterIndexList <- currentFilters()$cols
        domainFilter <- currentFilters()$domainFilter
        filterIndexList <- c(filterIndexList, aggFilterIndexList, colFilterIndexList)
        if(length(domainFilter)){
          if(identical("__key__", names(data)[1])){
            dataTmp <- data[-1] %>% filter(.data[[domainFilter]] != if(length(options$domainFilter$filterVal)) 
              options$domainFilter$filterVal else "\U00A0")
          }else{
            dataTmp <- data %>% filter(.data[[domainFilter]] != if(length(options$domainFilter$filterVal)) 
              options$domainFilter$filterVal else "\U00A0")
          }
          if(!length(filterIndexList)){
            return(list(data = dataTmp, filterElements = list()))
          }
        }else{
          if(!length(filterIndexList)){
            if(identical("__key__", names(data)[1])){
              return(list(data = data[-1], filterElements = list()))
            }
            return(list(data = data, filterElements = list()))
          }
          if(identical("__key__", names(data)[1])){
            dataTmp <- data[-1]
          }else{
            dataTmp <- data
          }
        }
        
        filterElements <- vector("list", length(filterIndexList))
        names(filterElements) <- filterIndexList
        multiFilterIndices <- c()
        
        for(filterIndex in filterIndexList){
          filterElements[[filterIndex]] <- sort(unique(dataTmp[[filterIndex]]))
          optionId <- "filter"
          if(filterIndex %in% aggFilterIndexList){
            optionId <- "aggregations"
          }else if(filterIndex %in% colFilterIndexList){
            optionId <- "cols"
          }
          if(initFilter && (optionId %in% c("aggregations", "cols") || 
                            length(currentView[[optionId]][[filterIndex]]))){
            filterVal <- currentView[[optionId]][[filterIndex]]
          }else{
            filterVal <- isolate(input[[paste0("filter_", filterIndex)]])
          }
          if(!any(filterVal %in% filterElements[[filterIndex]])){
            if(filterIndex %in% c(aggFilterIndexList, colFilterIndexList)){
              # nothing selected = no filter for aggregations/cols
              next
            }
            filterVal <- filterElements[[filterIndex]][[1]]
          }
          if(any(is.na(match(filterIndex, names(dataTmp))))){
            flog.warn("Attempt to tamper with the app detected! User entered: '%s' as filter index",
                      filterIndex)
            stop("Attempt to tamper with the app detected!", call. = FALSE)
          }
          if(length(filterVal) > 1L){
            multiFilterIndices <- c(multiFilterIndices, filterIndex)
            filterExpression <- paste0(".[[\"", filterIndex, "\"]]%in%c('",
                                       paste(gsub("'", "\\'", filterVal, fixed = TRUE),  collapse = "','"),
                                       "')")
          }else{
            filterExpression <- paste0(".[[\"", filterIndex, "\"]]=='",
                                       gsub("'", "\\'", filterVal, fixed = TRUE),
                                       "'")
          }
          dataTmp <- dataTmp %>% filter(
            !!rlang::parse_expr(filterExpression))
        }
        return(list(data = dataTmp, filterElements = filterElements, 
                    multiFilterIndices = multiFilterIndices))
      })
      
      dataToRender <- reactive({
        dataTmp <- filteredData()$data
        rowIndexList <- input$rowIndexList
        initData   <<- FALSE
        initInterface <<- FALSE
        if(!length(dataTmp)){
          return()
        }
        colIndexList <- isolate(currentFilters()$cols)
        aggIndexList <- isolate(currentFilters()$aggregations)
        multiFilterIndices <- filteredData()$multiFilterIndices
        aggregationFunction <- NULL
        
        if(is.null(rowIndexList)){
          rowIndexList <- setIndices
        }
        if(length(rowIndexList) + length(filteredData()$filterElements) != length(setIndices)){
          return()
        }
        rowIndexList <- c(rowIndexList, 
                          multiFilterIndices[!multiFilterIndices %in% c(aggIndexList, colIndexList)])
        if(length(aggIndexList)){
          if(isInput){
            isEditable <<- FALSE
            disableEl(session, paste0("#", ns("btAddRow")))
            disableEl(session, paste0("#", ns("btRemoveRows")))
          }
          if(identical(options[["_metadata_"]]$symtype, "parameter")){
            aggregationFunctionTmp <- input$aggregationFunction
            if(is.null(aggregationFunction)){
              aggregationFunction <- aggregationFunctionTmp
            }
            if(!aggregationFunction %in% c("sum", "count", "min", "max", "mean", "median")){
              flog.warn("Attempt to tamper with the app detected! User entered: '%s' as aggregation function.",
                        aggregationFunction)
              stop("Attempt to tamper with the app detected!", call. = FALSE)
            }
          }else{
            aggregationFunction <- "count"
          }
          dataTmp <- dataTmp %>% group_by(!!!rlang::syms(c(rowIndexList, colIndexList))) %>% 
            summarise(value = !!rlang::parse_expr(
              if(identical(aggregationFunction, "count")) 
                "sum(!is.na(value))"
              else
                paste0(aggregationFunction, "(value, na.rm = TRUE)")), .groups = "drop_last")
        }else if(isInput){
          isEditable <<- TRUE
          enableEl(session, paste0("#", ns("btAddRow")))
          enableEl(session, paste0("#", ns("btRemoveRows")))
        }
        if(length(rowIndexList)){
          dataTmp <- dataTmp %>% select(!!!c(rowIndexList, colIndexList, valueColName)) %>% 
            arrange(!!!rlang::syms(rowIndexList))
        }else{
          dataTmp <- dataTmp %>% select(!!!c(colIndexList, valueColName))
        }
        if(length(colIndexList)){
          # note that names_sep is not an ASCII full stop, but UNICODE U+2024
          tryCatch({
            dataTmp <- dataTmp %>% 
              pivot_wider(names_from = !!colIndexList, values_from = value, names_sep = "\U2024", 
                          names_sort = TRUE, names_repair = "unique")
          }, warning = function(w){
            if(grepl("list-cols", conditionMessage(w), fixed = TRUE)){
              flog.trace("MIRO pivot: Data contains duplicated keys and can therefore not be pivoted.")
              showErrorMsg(lang$renderers$miroPivot$errorTitle,
                           lang$renderers$miroPivot$errPivotDuplicate)
            }else{
              flog.info("MIRO pivot: Unexpected warning while pivoting data. Error message: %s",
                        conditionMessage(e))
              showErrorMsg(lang$renderers$miroPivot$errorTitle,
                           lang$renderers$miroPivot$errPivot)
            }
          }, error = function(e){
            flog.info("MIRO pivot: Unexpected error while pivoting data. Error message: %s",
                      conditionMessage(e))
            showErrorMsg(lang$renderers$miroPivot$errorTitle,
                         lang$renderers$miroPivot$errPivot)
          })
        }
        attr(dataTmp, "noRowHeaders") <- length(rowIndexList)
        return(dataTmp)
      })
      
      # ===================================================
      #        CHART RENDERER
      # ===================================================
      
      output$pivotChart <- renderChartjs({
        pivotRenderer <- input$pivotRenderer
        if(initRenderer && isTRUE(options$resetOnInit)){
          if(length(currentView[["pivotRenderer"]])){
            pivotRenderer <- currentView[["pivotRenderer"]]
          }else{
            return()
          }
        }
        if(!pivotRenderer %in% c("line", "bar", "stackedbar", "radar")){
          return()
        }
        showEl(session, paste0("#", ns("loadPivotTable")))
        dataTmp <- dataToRender()
        if(!length(dataTmp)){
          return()
        }
        rowHeaderLen <- attr(dataTmp, "noRowHeaders")
        noSeries <- length(dataTmp) - rowHeaderLen
        noError <- TRUE
        if(noSeries > 40L){
          showElReplaceTxt(session, paste0("#", ns("errMsg")), sprintf(lang$renderers$miroPivot$colTruncationWarning, "40"))
          noError <- FALSE
        }
        if(nrow(dataTmp) > 500L){
          showElReplaceTxt(session, paste0("#", ns("errMsg")), sprintf(lang$renderers$miroPivot$rowTruncationWarning, "500"))
          dataTmp <- slice(dataTmp, 1:500L)
          noError <- FALSE
        }
        if(noError){
          hideEl(session, paste0("#", ns("errMsg")))
        }
        labels <- do.call(paste, c(dataTmp[seq_len(rowHeaderLen)], list(sep = ".")))
        if(!length(labels)){
          labels <- "value"
        }
        if(identical(pivotRenderer, "line")){
          chartJsObj <- chartjs(customColors = customChartColors) %>% 
            cjsLine(labels = labels)
        }else if(identical(pivotRenderer, "stackedbar")){
          chartJsObj <- chartjs(customColors = customChartColors) %>% 
            cjsBar(labels = labels, stacked = TRUE)
        }else if(identical(pivotRenderer, "radar")){
          chartJsObj <- chartjs(customColors = customChartColors) %>% 
            cjsRadar(labels = labels)
        }else{
          chartJsObj <- chartjs(customColors = customChartColors) %>% 
            cjsBar(labels = labels)
        }
        for(i in seq_len(min(noSeries, 40L))){
          chartJsObj <- cjsSeries(chartJsObj, dataTmp[[rowHeaderLen + i]], 
                                  label = names(dataTmp)[rowHeaderLen + i])
        }
        hideEl(session, paste0("#", ns("loadPivotTable")))
        
        return(chartJsObj %>% cjsLegend())
      })
      
      # ===================================================
      #        TABLE RENDERER
      # ===================================================
      
      output$pivotTable <- renderDT({
        pivotRenderer <- input$pivotRenderer
        if(initRenderer && isTRUE(options$resetOnInit)){
          if(length(currentView[["pivotRenderer"]])){
            pivotRenderer <- currentView[["pivotRenderer"]]
          }else{
            pivotRenderer <- "table"
          }
          initRenderer <<- FALSE
        }
        if(!identical(pivotRenderer, "table")){
          return()
        }
        changeHeightEl(session, paste0("#", ns("pivotChart")), 1, 500)
        showEl(session, paste0("#", ns("loadPivotTable")))
        dataTmp <- dataToRender()
        if(!length(dataTmp)){
          return()
        }
        if(length(dataTmp) > 500){
          showElReplaceTxt(session, paste0("#", ns("errMsg")), sprintf(lang$renderers$miroPivot$colTruncationWarning, "500"))
          dataTmp <- dataTmp[, 1:500]
        }else{
          hideEl(session, paste0("#", ns("errMsg")))
        }
        noRowHeaders <- attr(dataTmp, "noRowHeaders")
        hideEl(session, paste0("#", ns("loadPivotTable")))
        
        datatable(dataTmp, extensions = c("Scroller", "FixedColumns"), 
                  selection = if(isEditable) "multiple" else "none", editable = isEditable,
                  container = DTbuildColHeaderContainer(names(dataTmp), 
                                                        noRowHeaders, 
                                                        unlist(setIndexAliases[names(dataTmp)[seq_len(noRowHeaders)]], 
                                                               use.names = FALSE)),
                  options = list(fnDrawCallback = if(noRowHeaders > 1) JS(paste0("function ( settings ) {
    var api = this.api();
    var cols = api.columns([", paste(seq_len(noRowHeaders - 1L) - 1L, collapse = ","), "], {page:'current'} ).nodes();
    api.columns([", paste(seq_len(noRowHeaders - 1L) - 1L, collapse = ","), "], 
      {page:'current'} ).data().each( function ( colData, i ) {
       var last = null;
       $.each(colData, function ( j, group ) {
          if ( last !== group || (i > 0 && $(cols[i - 1]).eq( j ).text() !== '')) {
              last = group;
              $(cols[i]).eq( j ).css({
                position: '-webkit-sticky',
                position: 'sticky',
                top: 0
              });
              $(cols[i]).eq( j ).addClass('tableScrollCell');
          } else {
            $(cols[i]).eq( j ).css(
                    'border-top', 'none'
                ).text(
                  ''
              );
          }
      } );
    });
}")),
                                 scrollY = 400, scrollX = TRUE, scrollCollapse = TRUE,
                                 scroller = list(loadingIndicator = FALSE),
                                 fixedColumns = list(leftColumns = noRowHeaders)), rownames = FALSE) %>%
          formatRound(seq(noRowHeaders + 1, length(dataTmp)), 
                      digits = roundPrecision)
      })
      
      if(isInput){
        dtProxy <- dataTableProxy(ns("pivotTable"))
        
        rendererEnv[[ns("editTableAdd")]] <- observe({
          if(length(input[["btAddRow"]]) != 1L ||
             input[["btAddRow"]] == 0L || !isEditable){
            return()
          }
          isolate({
            if(!length(dataToRender())){
              flog.warn("MIRO Pivot: Add row button was clicked but dataToRender has no length.")
              return()
            }
            colHeaders <- names(dataToRender())
            noRowHeaders <- attr(dataToRender(), "noRowHeaders")
            colHeaders[seq_len(noRowHeaders)] <- unlist(setIndexAliases[colHeaders[seq_len(noRowHeaders)]], 
                                                        use.names = FALSE)
            showModal(
              modalDialog(
                title = lang$renderers$miroPivot$dialogAddRow$title,
                tags$div(id = ns("newRowError"), class = "gmsalert gmsalert-error"),
                tags$div(class = "table-responsive", style = "margin-top:30px",
                         tags$table(class = "table",
                                    tags$tr(
                                      lapply(colHeaders, tags$th)
                                    ),
                                    tags$tr(lapply(seq_along(colHeaders), function(i){
                                      tags$td(style = "min-width:100px;",
                                              if(i <= noRowHeaders)
                                                serverSelectInput(session, ns(paste0("newRow_", i)), NULL,
                                                                  levels(dataToRender()[[i]]), multiple = TRUE,
                                                                  width = "100%",
                                                                  options = list(create = TRUE, maxItems = 1L,
                                                                                 dropdownParent = "body"))
                                              else
                                                textInput(ns(paste0("newRow_", i)), NULL, NA, width = "100%"))
                                    }))
                         )
                ),
                footer = tagList(
                  modalButton(lang$renderers$miroPivot$dialogAddRow$btCancel),
                  actionButton(ns("btAddRowConfirm"),
                               label = lang$renderers$miroPivot$btAddRow, 
                               class = "bt-highlight-1 bt-gms-confirm")),
                fade = TRUE, easyClose = FALSE, size = "l"
              ))
          })
        })
        rendererEnv[[ns("editTableAddConfirm")]] <- observe({
          if(length(input[["btAddRowConfirm"]]) != 1L ||
             input[["btAddRowConfirm"]] == 0L || !isEditable){
            return()
          }
          isolate({
            if(!length(dataToRender())){
              flog.warn("MIRO Pivot: Add row button was clicked but dataToRender has no length.")
              return()
            }
            if(bigData){
              showEl(session, "#loading-screen")
              on.exit(hideEl(session, "#loading-screen"))
            }
            flog.trace("MIRO pivot: Received request to add new row(s).")
            colHeaders <- names(dataToRender())
            noRowHeaders <- attr(dataToRender(), "noRowHeaders")
            newKeys <- vapply(seq_len(noRowHeaders), function(i){
              editedKey <- tryCatch(trimws(input[[paste0("newRow_", i)]]),
                                    error = function(e){NA_character_})
              if(isValidUEL(editedKey))
                return(editedKey)
              return(NA_character_)
            }, character(1L), USE.NAMES = FALSE)
            if(any(is.na(newKeys))){
              return(showHideEl(session, paste0("#", ns("newRowError")), 5000L,
                                lang$renderers$miroPivot$dialogAddRow$invalidKeysError))
            }
            
            newValues <- vapply(seq(noRowHeaders + 1L, length(colHeaders)), function(i){
              newVal <- tryCatch(suppressWarnings(as.numeric(input[[paste0("newRow_", i)]])),
                                 error = function(e){NA_real_})
              if(length(newVal) != 1L){
                return(NA_real_)
              }
              return(newVal)
            }, numeric(1L), USE.NAMES = FALSE)
            newColIds <- which(!is.na(newValues))
            if(!length(newColIds)){
              return(showHideEl(session, paste0("#", ns("newRowError")), 5000L,
                                lang$renderers$miroPivot$dialogAddRow$invalidValuesError))
            }
            newValues <- newValues[newColIds]
            # in case new values are non-integer and value column was integer before,
            # we have to convert it
            mustConvertValCol <- FALSE
            if(is.integer(data[[length(data)]])){
              if(all(is_wholenumber(newValues))){
                newValues <- as.integer(newValues)
              }else{
                mustConvertValCol <- TRUE
              }
            }
            
            valueColName <- names(data)[length(data)]
            
            rowIndices <- colHeaders[seq_len(noRowHeaders)]
            colIndices <- currentFilters()$cols
            colIndices <- colIndices[colIndices != valueColName]
            filterIndices <- currentFilters()$filter
            filterIndices <- filterIndices[!filterIndices %in% c(filteredData()$multiFilterIndices, valueColName)]
            
            colElements <- vector("list", length(newColIds))
            if(length(colIndices)){
              colElements <- strsplit(colHeaders[newColIds], "\U2024", fixed = TRUE)
            }else if(length(newColIds) > 1L){
              flog.error("MIRO pivot: Column dimensions of current filters and dataToRender don't match. Please contact GAMS!")
              return(showHideEl(session, paste0("#", ns("newRowError")), 5000L,
                                lang$renderers$miroPivot$dialogAddRow$unknownError))
            }
            indexOrder <- match(setIndices, c(rowIndices,
                                              colIndices,
                                              filterIndices))
            if(any(is.na(indexOrder)) || length(indexOrder) != length(setIndices)){
              flog.error("MIRO pivot: Could not determine index order.")
              return(showHideEl(session, paste0("#", ns("newRowError")), 5000L,
                                lang$renderers$miroPivot$dialogAddRow$unknownError))
            }
            if(tryCatch({
              filterElements <- vapply(filterIndices, function(filterIndex){
                return(input[[paste0("filter_", filterIndex)]])
              }, character(1L), USE.NAMES = FALSE)
              FALSE
            }, error = function(e){
              flog.warn("Could not determine filter elements. Error message: %s",
                        conditionMessage(e))
              return(TRUE)
            })){
              return(showHideEl(session, paste0("#", ns("newRowError")), 5000L,
                                lang$renderers$miroPivot$dialogAddRow$unknownError))
            }
            newKeysColIds <- match(rowIndices, setIndices) + 1L
            # we might have to extend factor if there are new keys
            hasNewUELs <- FALSE
            for(i in seq_along(newKeys)){
              if(!newKeys[i] %in% levels(data[[newKeysColIds[i]]])){
                hasNewUELs <- TRUE
                data[[newKeysColIds[i]]] <<- factor(data[[newKeysColIds[i]]],
                                                    levels = unique(sort(c(levels(data[[newKeysColIds[i]]]),
                                                                           newKeys[i]))))
              }
            }
            # now that factors are extended, we can safely add new rows
            newRow <- vector("list", length(newValues))
            newKey <- vector("list", length(newValues))
            for(i in seq_along(newValues)){
              newRowTmp <- c(newKeys, colElements[[i]], filterElements)[indexOrder]
              newKey[[i]] <- paste(newRowTmp, collapse = "\U2024")
              newRow[[i]] <- c(list(newKey[[i]]), as.list(newRowTmp),
                               list(newValues[i]))
              if(!hasNewUELs && newKey[[i]] %in% data[["__key__"]]){
                flog.debug("Key: '%s' already exists.", newKey[[i]])
                return(showHideEl(session, paste0("#", ns("newRowError")), 5000L,
                                  sprintf(lang$renderers$miroPivot$duplicateRecordError, newKey[[i]])))
              }
            }
            if(mustConvertValCol){
              data[[length(data)]] <<- as.numeric(data[[length(data)]])
            }
            for(i in seq_along(newValues)){
              flog.debug("MIRO pivot: adding new data record: %s", newKey[[i]])
              data[nrow(data) + 1L, ] <<- newRow[[i]]
            }
            removeModal()
            newUpdateFilterVal <- updateFilter() + 1L
            updateFilter(newUpdateFilterVal)
          })
        })
        
        rendererEnv[[ns("editTableRemove")]] <- observe({
          if(length(input[["btRemoveRows"]]) != 1L ||
             input[["btRemoveRows"]] == 0L || !isEditable){
            return()
          }
          isolate({
            idsToRemove <- input[["pivotTable_rows_selected"]]
            if(!length(idsToRemove)){
              return()
            }
            if(!length(dataToRender())){
              flog.warn("MIRO Pivot: Remove rows button was clicked but dataToRender has no length.")
              return()
            }
            if(bigData){
              showEl(session, "#loading-screen")
              on.exit(hideEl(session, "#loading-screen"))
            }
            flog.trace("MIRO pivot: Received request to remove row(s).")
            colHeaders <- names(dataToRender())
            noRowHeaders <- attr(dataToRender(), "noRowHeaders")
            rowIndices <- colHeaders[seq_len(noRowHeaders)]
            colIndices <- currentFilters()$cols
            colIndices <- colIndices[colIndices != valueColName]
            filterIndices <- currentFilters()$filter
            filterIndices <- filterIndices[!filterIndices %in% c(filteredData()$multiFilterIndices, valueColName)]
            
            indexOrder <- match(setIndices, c(rowIndices,
                                              colIndices,
                                              filterIndices))
            rowsToRemove <- mutate(slice(dataToRender(), idsToRemove)[seq_len(noRowHeaders)],
                                   across(where(is.factor), as.character))
            if(tryCatch({
              filterElements <- vapply(filterIndices, function(filterIndex){
                return(input[[paste0("filter_", filterIndex)]])
              }, character(1L), USE.NAMES = FALSE)
              FALSE
            }, error = function(e){
              flog.error("Could not determine filter elements. Error message: %s",
                         conditionMessage(e))
              return(TRUE)
            })){
              return()
            }
            if(length(colIndices)){
              if(noRowHeaders > 0L){
                colHeadersTmp <- colHeaders[-seq_len(noRowHeaders)]
              }else{
                colHeadersTmp <- colHeaders
              }
              colElementsList <- strsplit(colHeadersTmp, "\U2024", fixed = TRUE)
            }else{
              colElementsList <- list(character())
            }
            keysToRemove <- unlist(lapply(seq_along(idsToRemove), function(i){
              vapply(colElementsList, function(colElements){
                paste(c(as.character(rowsToRemove[i, ]),
                        colElements,
                        filterElements)[indexOrder], collapse = "\U2024")
              }, character(1L), USE.NAMES = FALSE)
            }))
            rowIdsToRemove <- match(keysToRemove, data[["__key__"]])
            if(any(is.na(rowIdsToRemove))){
              flog.error("MIRO pivot: Key(s): %s could not be removed as they don't exist in the data!",
                         paste(keysToRemove[is.na(rowIdsToRemove)]))
              return()
            }
            if(length(rowIdsToRemove) > 0L){
              data <<- data[-rowIdsToRemove, ]
              flog.trace("MIRO pivot: %s row(s) removed.", length(rowIdsToRemove))
              
              newUpdateFilterVal <- updateFilter() + 1L
              updateFilter(newUpdateFilterVal)
            }
          })
        })
        
        rendererEnv[[ns("editTable")]] <- observe({
          if(!isEditable){
            return()
          }
          info <- input[["pivotTable_cell_edit"]]
          if(is.null(info)){
            return()
          }
          flog.trace("MIRO pivot: Received request to edit table data.")
          if(bigData){
            if(!identical("__key__", names(data)[1])){
              flog.error("User edited input table even though it was readonly. This seems like an attempt to tamper with the app!")
              return()
            }
            showEl(session, "#loading-screen")
            on.exit(hideEl(session, "#loading-screen"))
          }
          isolate({
            editedCol <- suppressWarnings(as.integer(info$col)) + 1L
            newUpdateFilterVal <- updateFilter() + 1L
            
            if(is.na(editedCol) || length(editedCol) != 1L){
              flog.error("MIRO pivot: Could not determine edited column.")
              updateFilter(newUpdateFilterVal)
              return()
            }
            if(tryCatch({
              valueColName <- names(data)[length(data)]
              dataHeaders   <- names(dataToRender())
              noRowHeaders <- attr(dataToRender(), "noRowHeaders")
              
              rowIndices <- dataHeaders[seq_len(noRowHeaders)]
              colIndices <- currentFilters()$cols
              colIndices <- colIndices[colIndices != valueColName]
              filterIndices <- currentFilters()$filter
              filterIndices <- filterIndices[!filterIndices %in% c(filteredData()$multiFilterIndices, valueColName)]
              
              keyToReplace <- NULL
              indexOrder <- match(setIndices, c(rowIndices,
                                                colIndices,
                                                filterIndices))
              
              rowToReplace <- slice(dataToRender(), info$row[1])
              rowElements <- vapply(rowIndices, function(rowIndex){
                as.character(rowToReplace[[rowIndex]][1])
              }, character(1L), USE.NAMES = FALSE)
              filterElements <- vapply(filterIndices, function(filterIndex){
                return(input[[paste0("filter_", filterIndex)]])
              }, character(1L), USE.NAMES = FALSE)
              
              if(length(colIndices)){
                if(noRowHeaders > 0L){
                  colHeaders <- dataHeaders[-seq_len(noRowHeaders)]
                }else{
                  colHeaders <- dataHeaders
                }
                if(editedCol > noRowHeaders){
                  colElements <- strsplit(dataHeaders[editedCol], "\U2024", fixed = TRUE)[[1]]
                }else if(length(colHeaders) == 1L){
                  colElements <- strsplit(colHeaders, "\U2024", fixed = TRUE)[[1]]
                }else{
                  # key was edited while columns are pivoted -> need to (potentially) change multiple keys
                  colElementsList <- strsplit(colHeaders, "\U2024", fixed = TRUE)
                  keyToReplace <- vapply(colElementsList, function(colElements){
                    paste(c(rowElements,
                            colElements,
                            filterElements)[indexOrder],
                          collapse = "\U2024")
                  }, character(1L), USE.NAMES = FALSE)
                  rowId <- match(keyToReplace, data[["__key__"]])
                }
              }else{
                colElements <- character()
              }
              
              if(is.null(keyToReplace)){
                keyVector <- c(rowElements,
                               colElements,
                               filterElements)
                if(length(keyVector) < length(setIndices)){
                  stop("MIRO pivot: Could not determine row ID!", call. = FALSE)
                }
                keyVector <- keyVector[indexOrder]
                keyToReplace <- paste(keyVector,
                                      collapse = "\U2024")
                rowId <- which(keyToReplace == data[["__key__"]])
              }
              if(!length(rowId)){
                if(editedCol <= noRowHeaders || length(colElements) != 1L){
                  stop(sprintf("MIRO pivot: Could not find row with ID: '%s' in original data.",
                               paste(keyToReplace, collapse = ", ")), call. = FALSE)
                }
                # value was added in a pivoted column that was empty/NA before
              }
              FALSE
            }, error = function(e){
              flog.error("MIRO pivot: Problems getting row to replace. Error message: %s",
                         conditionMessage(e))
              TRUE
            })){
              return()
            }
            if(editedCol > noRowHeaders){
              # edited column is value column
              editedVal <- suppressWarnings(as.numeric(info$value))
              if(is.na(editedVal) || length(editedVal) != 1L){
                if(identical(info$value, "")){
                  # delete row
                  if(!length(rowId)){
                    flog.debug("MIRO pivot: Edited value is not numeric!.")
                    return()
                  }
                  data <<- data[-c(rowId), ]
                  editedVal <- NA_real_
                  if(length(colElements) == 1L){
                    updateFilter(newUpdateFilterVal)
                    return()
                  }
                }else{
                  flog.debug("MIRO pivot: Edited value is not numeric!.")
                  return()
                }
              }else{
                if(length(rowId)){
                  data[rowId, length(data)] <<- editedVal
                }else{
                  # need to add new row
                  
                  # in case new values are non-integer and value column was integer before,
                  # we have to convert it
                  mustConvertValCol <- FALSE
                  if(is.integer(data[[length(data)]])){
                    if(all(is_wholenumber(newValues))){
                      editedVal <- as.integer(editedVal)
                    }else{
                      data[[length(data)]] <<- as.numeric(data[[length(data)]])
                    }
                  }
                  data[nrow(data) + 1L, ] <<- c(list(keyToReplace),
                                                as.list(keyVector),
                                                list(editedVal))
                }
              }
              newData <- dataToRender()
              newData[info$row, editedCol] <- editedVal
              replaceData(dtProxy, newData, resetPaging = FALSE)
              
              newVal <- dataUpdated() + 1L
              dataUpdated(newVal)
              return()
            }
            # edited column is key column
            editedKey <- tryCatch(trimws(info$value), error = function(e){""})
            if(!isValidUEL(editedKey)){
              flog.info("MIRO pivot: Edited key is invalid!.")
              updateFilter(newUpdateFilterVal)
              return()
            }
            colId <- match(dataHeaders[editedCol], setIndices)
            if(length(rowId) == 1L){
              keyVector[colId] <- editedKey
              newKey <- paste(keyVector,
                              collapse = "\U2024")
            }else{
              validRowIds <- !is.na(rowId)
              rowId <- rowId[validRowIds]
              colElementsList <- colElementsList[validRowIds]
              rowElements[editedCol] <- editedKey
              newKey <- vapply(colElementsList, function(colElements){
                paste(c(rowElements,
                        colElements,
                        filterElements)[indexOrder],
                      collapse = "\U2024")
              }, character(1L), USE.NAMES = FALSE)
            }
            if(editedKey %in% levels(data[[colId + 1L]])){
              if(any(newKey %in% data[["__key__"]])){
                flog.debug("The record: %s already exists.", newKey)
                return(showErrorMsg(lang$renderers$miroPivot$duplicateRecordTitle,
                                    lang$renderers$miroPivot$duplicateRecordDesc))
              }
              data[rowId, colId + 1L] <<- editedKey
            }else{
              levels(data[[colId + 1L]]) <<- c(levels(data[[colId + 1L]]), editedKey)
              data[rowId, colId + 1L] <<- editedKey
              # reorder factor column
              data[[colId + 1L]] <<- factor(data[[colId + 1L]],
                                            levels = unique(sort(levels(data[[colId + 1L]]))))
            }
            data[rowId, 1L] <<- newKey
            updateFilter(newUpdateFilterVal)
          })
        })
        return(reactive({
          dataUpdated()
          if(sum(numericCols) == 0L){
            # data is a set -> add empty text column back
            if(identical(names(data)[1], "__key__")){
              dataRet <- data[-1]
            }else{
              dataRet <- data
            }
            dataRet[length(dataRed)] <- NA_character_
            
            return(dataRet)
          }else if(identical(names(data)[1], "__key__")){
            return(data[-1])
          }
          return(data)
        }))
      }
    })
}
