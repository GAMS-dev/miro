<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=""> <![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" lang=""> <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" lang=""> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="">
  <!--<![endif]-->

  <head>
    <title>GAMS MIRO Walkthrough</title>
    <!-- Meta -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="GAMS MIRO documentation" />
    <meta name="author" content="GAMS Development Corp." />
    <!-- FontAwesome JS -->
    <script
      defer
      type="text/javascript"
      src="assets/js/fontawesome.js"
    ></script>
    <!-- Global CSS -->
    <link
      rel="stylesheet"
      href="assets/plugins/bootstrap/css/bootstrap.min.css"
    />
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="assets/plugins/prism/prism.css" />
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css" />
    <link
      rel="stylesheet"
      href="assets/plugins/lightbox/dist/ekko-lightbox.css"
    />
    <!-- KaTeX -->
    <link rel="stylesheet" href="assets/plugins/katex/katex.min.css" />
    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css" />
    <!--#include virtual="/wheader.html" -->
  </head>

  <body class="body-orange">
    <!--#include virtual="/navbar_full.html" -->
    <div class="page-wrapper">
      <!--#include virtual="/mirover.html" -->

      <!-- ******Header****** -->
      <header id="header" class="sub-header">
        <div class="container">
          <div class="branding">
            <h1 class="logo">
              <a href="index.html">
                <img
                  class="img-fluid"
                  style="height: 75px"
                  src="assets/images/logo.svg"
                  onerror="this.onerror=null; this.src='assets/images/logo.png'"
                  alt="GAMS MIRO"
                />
              </a>
            </h1>
          </div>
          <!--//branding-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item"><a href="index.html">Home</a></li>
            <li class="breadcrumb-item active">MIRO Walkthrough</li>
          </ol>
        </div>
        <!--//container-->
      </header>
      <!--//header-->
      <div class="doc-wrapper">
        <div class="container">
          <div class="row justify-content-end search-box-wrapper">
            <div class="float-right">
              <input
                class="form-control search-box"
                id="miroSearch"
                type="text"
                placeholder="Search"
                aria-label="Search"
              />
              <ul id="miroSearchResults" class="list-group"></ul>
            </div>
          </div>
          <div id="doc-header" class="doc-header text-center">
            <h1 class="doc-title">
              <i class="icon fa fa-book-open"></i> GAMS MIRO Walkthrough
            </h1>
          </div>
          <!--//doc-header-->
          <div class="doc-body row">
            <div class="doc-content col-md-9 col-12 order-1">
              <div class="content-inner">
                <section id="introduction-section" class="doc-section">
                  <h2 class="section-title">
                    From GAMSPy Model to GAMS MIRO App
                  </h2>
                  <div class="section-block">
                    <p>
                      In this tutorial, we will explore the powerful features
                      of GAMS MIRO to generate an application tailored to your
                      optimization problem. Step by step, we will build the
                      MIRO application for this
                      <a
                        href="https://miro.gams.com/gallery/app_direct/bess/"
                        target="_blank"
                        >gallery</a
                      >
                      example.
                    </p>
                    <p>
                      To be able to follow this tutorial, we assume that you
                      have already worked with GAMS or GAMSPy, as we will start
                      with a given GAMSPy model. The content of the first
                      section is GAMSPy specific, everything after that applies
                      to both GAMS and GAMSPy. So if you are working with a
                      GAMS model, you can check the
                      <a
                        href="https://www.gams.com/miro/model.html#model-adjustments"
                        target="_blank"
                        >documentation</a
                      >
                      for the syntax, still it might be helpful to follow the
                      tutorial for additional explanations. Otherwise, you just
                      need to have
                      <a
                        href="https://www.gams.com/miro/download.html"
                        target="_blank"
                        >MIRO</a
                      >
                      installed (this tutorial is based on version 2.12.0, if
                      you are using an older version, some of the features we
                      will go through may be missing), and some R knowledge
                      might help in the last part of the tutorial, but is not
                      required. All necessary R functions will be explained, so
                      if you have worked with a similar language before, you
                      are good to go!
                    </p>
                    <p>
                      As already mentioned, you can start with either a GAMS or
                      a GAMSPy implementation; we’ll be working with a GAMSPy
                      model. Our first step will be to define the application’s
                      inputs and outputs - this is the only part of the process
                      that differs depending on whether you are using GAMS or
                      GAMSPy. After that, the configuration process is the same
                      for both.
                    </p>
                    <p>
                      We’ll start by showing you how to specify inputs and
                      outputs in your GAMSPy model. Then we will see how to
                      visualize data in MIRO using only these definitions. This
                      step can be extremely helpful during model development:
                      it allows you to quickly plot and inspect the output data
                      to make sure your results make sense. If something
                      doesn’t look right, you have a clear starting point for
                      investigating potential errors in you model
                      implementation.
                    </p>
                    <p>
                      After we’ve covered the basics of visualization, in the
                      second part of this tutorial we’ll move on to the
                      Configuration Mode. Here you can configure many default
                      settings without editing any code, making it easy to
                      customize your application for different needs. Since
                      built-in options are sometimes not enough, the third part
                      of this tutorial will show you how to add custom
                      renderers and widgets to give you maximum control over
                      the user interface. Finally, we’ll examine advanced
                      customization tips and tricks that can make your MIRO
                      application even more powerful and tailored to your
                      needs.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="implement-the-model" class="section-block">
                    <h3 class="block-title">Implement the Model</h3>
                    <p>
                      The starting point for building your MIRO application is
                      the implementation of your model using either GAMS or
                      GAMSPy. As mentioned, we will be using a GAMSPy model
                      here. If you would like to see how the necessary code
                      modifications would look in GAMS, please refer to the
                      <a
                        href="https://www.gams.com/miro/model.html#model-adjustments"
                        target="_blank"
                        >documentation</a
                      >.
                    </p>
                    <p>
                      Our example model is a “Battery Energy Storage System
                      (BESS) sizing problem,” based on an example from
                      <a href="https://nag.com/" target="_blank">NAG</a>,
                      available on their GitHub (<a
                        href="https://github.com/numericalalgorithmsgroup/NAGPythonExamples/blob/master/local_optimization/MILP/BESS_MILP.ipynb"
                        target="_blank"
                        >BESS.ipynb</a
                      >). The goal is to optimize a city’s hourly energy
                      schedule by identifying the most cost-effective
                      combination of energy sources, which includes leveraging
                      a BESS to store low-cost energy during off-peak hours and
                      release it when demand is high. By assessing different
                      storage capacities and discharge rates, the model
                      pinpoints the configuration that minimizes overall energy
                      costs while ensuring demand is consistently met.
                    </p>
                    <p>
                      Before diving in, we recommend that you review the
                      mathematical description in the introduction to the
                      finished application provided in the
                      <a
                        href="https://miro.gams.com/gallery/app_direct/bess/"
                        target="_blank"
                        >gallery</a
                      >. We will be referring directly to the variable names
                      introduced there.
                    </p>
                    <details>
                      <summary>GAMSPy model code</summary>
                      <pre><code class="language-python">import pandas as pd
import sys

from gamspy import (
    Container,
    Alias,
    Equation,
    Model,
    Parameter,
    Sense,
    Set,
    Sum,
    Variable,
    Ord,
    Options,
    ModelStatus,
    SolveStatus,
)


def main():
    m = Container()

    # Generator parameters
    generator_specifications_input = pd.DataFrame(
        [
            [&quot;gen0&quot;, 1.1, 220, 50, 100, 4, 2],
            [&quot;gen1&quot;, 1.3, 290, 80, 190, 4, 2],
            [&quot;gen2&quot;, 0.9, 200, 10, 70, 4, 2],
        ],
        columns=[
            &quot;i&quot;,
            &quot;cost_per_unit&quot;,
            &quot;fixed_cost&quot;,
            &quot;min_power_output&quot;,
            &quot;max_power_output&quot;,
            &quot;min_up_time&quot;,
            &quot;min_down_time&quot;,
        ],
    )

    # Load demand to be fulfilled by the energy management system
    # combine with cost external grid, to have one source of truth for the hours (Set j)
    timewise_load_demand_and_cost_external_grid_input = pd.DataFrame(
        [
            [&quot;hour00&quot;, 200, 1.5],
            [&quot;hour01&quot;, 180, 1.0],
            [&quot;hour02&quot;, 170, 1.0],
            [&quot;hour03&quot;, 160, 1.0],
            [&quot;hour04&quot;, 150, 1.0],
            [&quot;hour05&quot;, 170, 1.0],
            [&quot;hour06&quot;, 190, 1.2],
            [&quot;hour07&quot;, 210, 1.8],
            [&quot;hour08&quot;, 290, 2.1],
            [&quot;hour09&quot;, 360, 1.9],
            [&quot;hour10&quot;, 370, 1.8],
            [&quot;hour11&quot;, 350, 1.6],
            [&quot;hour12&quot;, 310, 1.6],
            [&quot;hour13&quot;, 340, 1.6],
            [&quot;hour14&quot;, 390, 1.8],
            [&quot;hour15&quot;, 400, 1.9],
            [&quot;hour16&quot;, 420, 2.1],
            [&quot;hour17&quot;, 500, 3.0],
            [&quot;hour18&quot;, 440, 2.1],
            [&quot;hour19&quot;, 430, 1.9],
            [&quot;hour20&quot;, 420, 1.8],
            [&quot;hour21&quot;, 380, 1.6],
            [&quot;hour22&quot;, 340, 1.2],
            [&quot;hour23&quot;, 320, 1.2],
        ],
        columns=[&quot;j&quot;, &quot;load_demand&quot;, &quot;cost_external_grid&quot;],
    )

    # Set
    i = Set(
        m,
        name=&quot;i&quot;,
        records=generator_specifications_input[&quot;i&quot;],
        description=&quot;generators&quot;,
    )
    j = Set(
        m,
        name=&quot;j&quot;,
        records=timewise_load_demand_and_cost_external_grid_input[&quot;j&quot;],
        description=&quot;hours&quot;,
    )
    t = Alias(m, name=&quot;t&quot;, alias_with=j)

    # Data
    # Generator parameters
    gen_cost_per_unit = Parameter(
        m,
        name=&quot;gen_cost_per_unit&quot;,
        domain=[i],
        records=generator_specifications_input[[&quot;i&quot;, &quot;cost_per_unit&quot;]],
        description=&quot;cost per unit of generator i&quot;,
    )

    gen_fixed_cost = Parameter(
        m,
        name=&quot;gen_fixed_cost&quot;,
        domain=[i],
        records=generator_specifications_input[[&quot;i&quot;, &quot;fixed_cost&quot;]],
        description=&quot;fixed cost of generator i&quot;,
    )

    gen_min_power_output = Parameter(
        m,
        name=&quot;gen_min_power_output&quot;,
        domain=[i],
        records=generator_specifications_input[[&quot;i&quot;, &quot;min_power_output&quot;]],
        description=&quot;minimal power output of generator i&quot;,
    )

    gen_max_power_output = Parameter(
        m,
        name=&quot;gen_max_power_output&quot;,
        domain=[i],
        records=generator_specifications_input[[&quot;i&quot;, &quot;max_power_output&quot;]],
        description=&quot;maximal power output of generator i&quot;,
    )

    gen_min_up_time = Parameter(
        m,
        name=&quot;gen_min_up_time&quot;,
        domain=[i],
        records=generator_specifications_input[[&quot;i&quot;, &quot;min_up_time&quot;]],
        description=&quot;minimal up time of generator i&quot;,
    )

    gen_min_down_time = Parameter(
        m,
        name=&quot;gen_min_down_time&quot;,
        domain=[i],
        records=generator_specifications_input[[&quot;i&quot;, &quot;min_down_time&quot;]],
        description=&quot;minimal down time of generator i&quot;,
    )

    # Battery parameters
    cost_bat_power = Parameter(m, &quot;cost_bat_power&quot;, records=1, is_miro_input=True)
    cost_bat_energy = Parameter(m, &quot;cost_bat_energy&quot;, records=2, is_miro_input=True)

    # Load demand and external grid
    load_demand = Parameter(
        m, name=&quot;load_demand&quot;, domain=[j], description=&quot;load demand at hour j&quot;
    )

    cost_external_grid = Parameter(
        m,
        name=&quot;cost_external_grid&quot;,
        domain=[j],
        description=&quot;cost of the external grid at hour j&quot;,
    )

    max_input_external_grid = Parameter(
        m,
        name=&quot;max_input_external_grid&quot;,
        records=10,
        description=&quot;maximal power that can be imported from the external grid every hour&quot;,
    )

    # Variable
    # Generator
    gen_power = Variable(
        m,
        name=&quot;gen_power&quot;,
        type=&quot;positive&quot;,
        domain=[i, j],
        description=&quot;Dispatched power from generator i at hour j&quot;,
    )

    gen_active = Variable(
        m,
        name=&quot;gen_active&quot;,
        type=&quot;binary&quot;,
        domain=[i, j],
        description=&quot;is generator i active at hour j&quot;,
    )

    # Battery
    battery_power = Variable(
        m,
        name=&quot;battery_power&quot;,
        domain=[j],
        description=&quot;power charged or discharged from the battery at hour j&quot;,
    )

    battery_delivery_rate = Variable(
        m,
        name=&quot;battery_delivery_rate&quot;,
        description=&quot;power (delivery) rate of the battery energy system&quot;,
    )

    battery_storage = Variable(
        m,
        name=&quot;battery_storage&quot;,
        description=&quot;energy (storage) rate of the battery energy system&quot;,
    )

    # External grid
    external_grid_power = Variable(
        m,
        name=&quot;external_grid_power&quot;,
        type=&quot;positive&quot;,
        domain=[j],
        description=&quot;power imported from the external grid at hour j&quot;,
    )

    # Equation
    fulfill_load = Equation(
        m,
        name=&quot;fulfill_load&quot;,
        domain=[j],
        description=&quot;load balance needs to be met very hour j&quot;,
    )

    gen_above_min_power = Equation(
        m,
        name=&quot;gen_above_min_power&quot;,
        domain=[i, j],
        description=&quot;generators power should be above the minimal output&quot;,
    )

    gen_below_max_power = Equation(
        m,
        name=&quot;gen_below_max_power&quot;,
        domain=[i, j],
        description=&quot;generators power should be below the maximal output&quot;,
    )

    gen_above_min_down_time = Equation(
        m,
        name=&quot;gen_above_min_down_time&quot;,
        domain=[i, j],
        description=&quot;generators down time should be above the minimal down time&quot;,
    )

    gen_above_min_up_time = Equation(
        m,
        name=&quot;gen_above_min_up_time&quot;,
        domain=[i, j],
        description=&quot;generators up time should be above the minimal up time&quot;,
    )

    battery_above_min_delivery = Equation(
        m,
        name=&quot;battery_above_min_delivery&quot;,
        domain=[j],
        description=&quot;battery delivery rate (charge rate) above min power rate&quot;,
    )

    battery_below_max_delivery = Equation(
        m,
        name=&quot;battery_below_max_delivery&quot;,
        domain=[j],
        description=&quot;battery delivery rate below max power rate&quot;,
    )

    battery_above_min_storage = Equation(
        m,
        name=&quot;battery_above_min_storage&quot;,
        domain=[t],
        description=&quot;battery storage above negative energy rate (since negative power charges the battery)&quot;,
    )

    battery_below_max_storage = Equation(
        m,
        name=&quot;battery_below_max_storage&quot;,
        domain=[t],
        description=&quot;sum over battery delivery below zero (cant deliver energy that is not stored)&quot;,
    )

    external_power_upper_limit = Equation(
        m,
        name=&quot;external_power_upper_limit&quot;,
        domain=[j],
        description=&quot; input from the external grid is limited&quot;,
    )

    fulfill_load[j] = (
        Sum(i, gen_power[i, j]) + battery_power[j] + external_grid_power[j]
        == load_demand[j]
    )

    gen_above_min_power[i, j] = (
        gen_min_power_output[i] * gen_active[i, j] &lt;= gen_power[i, j]
    )

    gen_below_max_power[i, j] = (
        gen_power[i, j] &lt;= gen_max_power_output[i] * gen_active[i, j]
    )

    # if j=0 -&gt; j.lag(1) = 0 which doesn&#39;t brake the equation,
    # since generator is of at start, resulting in negative right side, therefore the sum is always above
    gen_above_min_down_time[i, j] = Sum(
        t.where[(Ord(t) &gt;= Ord(j)) &amp; (Ord(t) &lt;= (Ord(j) + gen_min_down_time[i] - 1))],
        1 - gen_active[i, t],
    ) &gt;= gen_min_down_time[i] * (gen_active[i, j.lag(1)] - gen_active[i, j])

    # and for up it correctly starts the check that if its turned on in the first step
    # it has to stay on for the min up time
    gen_above_min_up_time[i, j] = Sum(
        t.where[(Ord(t) &gt;= Ord(j)) &amp; (Ord(t) &lt;= (Ord(j) + gen_min_up_time[i] - 1))],
        gen_active[i, t],
    ) &gt;= gen_min_up_time[i] * (gen_active[i, j] - gen_active[i, j.lag(1)])

    battery_above_min_delivery[j] = -battery_delivery_rate &lt;= battery_power[j]

    battery_below_max_delivery[j] = battery_power[j] &lt;= battery_delivery_rate

    battery_above_min_storage[t] = -battery_storage &lt;= Sum(
        j.where[Ord(j) &lt;= Ord(t)], battery_power[j]
    )

    battery_below_max_storage[t] = Sum(j.where[Ord(j) &lt;= Ord(t)], battery_power[j]) &lt;= 0

    external_power_upper_limit[j] = external_grid_power[j] &lt;= max_input_external_grid

    obj = (
        Sum(
            j,
            Sum(i, gen_cost_per_unit[i] * gen_power[i, j] + gen_fixed_cost[i])
            + cost_external_grid[j] * external_grid_power[j],
        )
        + cost_bat_power * battery_delivery_rate
        + cost_bat_energy * battery_storage
    )

    # Solve
    bess = Model(
        m,
        name=&quot;bess&quot;,
        equations=m.getEquations(),
        problem=&quot;MIP&quot;,
        sense=Sense.MIN,
        objective=obj,
    )

    bess.solve(
        solver=&quot;CPLEX&quot;,
        output=sys.stdout,
        options=Options(equation_listing_limit=1, relative_optimality_gap=0),
    )

    if bess.solve_status not in [
        SolveStatus.NormalCompletion,
        SolveStatus.TerminatedBySolver,
    ] or bess.status not in [ModelStatus.OptimalGlobal, ModelStatus.Integer]:
        print(&quot;No solution exists for your input data.\n&quot;)
        raise Exception(&quot;Infeasible.&quot;)

if __name__ == &quot;__main__&quot;:
    main()
                    </code></pre>
                    </details>
                  </div>
                  <!--//section-block-->
                  <div id="model-input" class="section-block">
                    <h3 class="block-title">Model Input</h3>
                    <p>
                      Let’s start by defining some basic inputs. You can see
                      that we begin with three scalar parameters, each of which
                      has the additional
                      <code class="language-python">is_miro_input=True</code>
                      option in the definition:
                    </p>
                    <pre><code class="language-python"># Battery parameters
cost_bat_power = Parameter(m, &quot;cost_bat_power&quot;, records=1, is_miro_input=True)
cost_bat_energy = Parameter(m, &quot;cost_bat_energy&quot;, records=2, is_miro_input=True)

# Load demand and external grid
max_input_external_grid = Parameter(
    m,
    name=&quot;max_input_external_grid&quot;,
    records=10,
    is_miro_input=True,
    description=&quot;maximal power that can be imported from the external grid every hour&quot;,
)
                  </code></pre>
                    <p>
                      For the generator specifications and schedule inputs,
                      there are a few extra steps. The model relies on two
                      sets: one for possible generators and another for hours
                      in which load demand must be met. Since these sets are
                      not fixed but should be part of the input, we use
                      <a
                        href="https://gamspy.readthedocs.io/en/latest/user/basics/set.html#implicit-set-definition-via-domain-forwarding"
                        target="_blank"
                        >Domain Forwarding</a
                      >—an approach where the set is implicitly defined by one
                      parameter.
                    </p>
                    <p>
                      Because multiple parameters rely on these sets and we
                      want a single source of truth, we need to combine them
                      into a single table in our MIRO application (one for
                      generator specifications, another for the schedule). To
                      achieve this, we define an additional set for the column
                      headers:
                    </p>
                    <pre><code class="language-python">
generator_spec_header = Set(
    m,
    name=&quot;generator_spec_header&quot;,
    records=[
        &quot;cost_per_unit&quot;,
        &quot;fixed_cost&quot;,
        &quot;min_power_output&quot;,
        &quot;max_power_output&quot;,
        &quot;min_up_time&quot;,
        &quot;min_down_time&quot;,
    ],
)</code></pre>
                    <p>
                      We then create a parameter to hold all the relevant
                      information:
                    </p>
                    <pre><code class="language-python">generator_specifications = Parameter(
    m,
    name=&quot;generator_specifications&quot;,
    domain=[i, generator_spec_header],
    domain_forwarding=[True, False],
    records=generator_specifications_input.melt(
        id_vars=&quot;i&quot;, var_name=&quot;generator_spec_header&quot;
    ),
    is_miro_input=True,
    is_miro_table=True,
    description=&quot;specifications of each generator&quot;,
)</code></pre>
                    <p>
                      Notice that
                      <code class="language-python">is_miro_input=True</code>
                      makes the parameter an input to the MIRO application,
                      while
                      <code class="language-python">is_miro_table=True</code>
                      displays the data in
                      <a
                        href="https://www.gams.com/miro/model.html#display-tables"
                        target="_blank"
                        >table format</a
                      >. The key detail is
                      <code class="language-python"
                        >domain_forwarding=[True, False]</code
                      >, which ensures that set elements for generators come
                      from the MIRO application (the header names remain fixed,
                      hence <code class="language-python">False</code>). We
                      still use our initial data to populate these
                      specifications, but we transform it using
                      <a
                        href="https://pandas.pydata.org/docs/reference/api/pandas.melt.html"
                        target="_blank"
                        ><code class="language-python">melt()</code></a
                      >
                      so that it matches the new format of only two columns:
                      <code class="language-python">"i"</code> and
                      <code class="language-python"
                        >"generator_spec_header"</code
                      >.
                    </p>
                    <p>
                      Since we are now forwarding the domain of set
                      <code class="language-python">i</code> through this
                      table, we no longer specify its records. The same goes
                      for any parameters that rely on
                      <code class="language-python">i</code> (e.g.,
                      <code class="language-python">gen_cost_per_unit</code>).
                      Instead, we assign them by referencing the new combined
                      parameter:
                    </p>
                    <pre><code class="language-diff">i = Set(
    m,
    name=&quot;i&quot;,
-   records=generator_specifications_input[&quot;i&quot;],
    description=&quot;generators&quot;,
)

gen_cost_per_unit = Parameter(
      m,
      name=&quot;gen_cost_per_unit&quot;,
      domain=[i],
-     records=generator_specifications_input[[&quot;i&quot;, &quot;cost_per_unit&quot;]],
      description=&quot;cost per unit of generator i&quot;,
  )

+ gen_cost_per_unit[i] = generator_specifications[i, &quot;cost_per_unit&quot;]
                  </code></pre>
                    <p>
                      We apply the same pattern to other parameters that depend
                      on <code class="language-python">i</code>. Likewise, for
                      hour-dependent parameters (like
                      <code class="language-python">load_demand</code> and
                      <code class="language-python">cost_external_grid</code>),
                      we create a single source of truth for the hour set by
                      combining them into one parameter and making the same
                      modifications.
                    </p>
                    <p>Given the input, we move on to the output.</p>
                  </div>
                  <!--//section-block-->
                  <div id="model-output" class="section-block">
                    <h3 class="block-title">Model Output</h3>
                    <p>
                      When implementing the model, it can be helpful to flag
                      variables as outputs by adding
                      <code class="language-python">is_miro_output=True</code>.
                      After solving, we can then view the calculated variable
                      values right away, making it easier to spot any remaining
                      model errors.
                    </p>
                    <pre><code class="language-python">gen_power = Variable(
    m,
    name=&quot;gen_power&quot;,
    type=&quot;positive&quot;,
    domain=[i, j],
    description=&quot;dispatched power from generator i at hour j&quot;,
    is_miro_output=True,
)
                  </code></pre>
                    <p>
                      In general, we can designate any variable or parameter as
                      an MIRO output. When implementing the model, it makes
                      sense to simply define all variables as output, so you
                      can easily visualize the results. Sometimes it makes
                      sense to define parameters as outputs that depend on the
                      variables. A straightforward example in our model is to
                      create dedicated parameters for the three cost
                      components, allowing us to display these values directly
                      in the MIRO application:
                    </p>
                    <pre><code class="language-python">total_cost_gen = Parameter(
    m,
    &quot;total_cost_gen&quot;,
    is_miro_output=True,
    description=&quot;total cost of the generators&quot;,
)

total_cost_gen[...] = Sum(
    j, Sum(i, gen_cost_per_unit[i] * gen_power.l[i, j] + gen_fixed_cost[i])
)</code></pre>
                    <p>
                      We apply this same approach for the other power sources
                      and combine them:
                    </p>
                    <details>
                      <summary>Costs for the other power sources</summary>
                      <pre><code class="language-python">total_cost_battery = Parameter(
    m,
    &quot;total_cost_battery&quot;,
    is_miro_output=True,
    description=&quot;total cost of the BESS&quot;,
)

total_cost_battery[...] = (
    cost_bat_power * battery_delivery_rate.l + cost_bat_energy * battery_storage.l
)

total_cost_extern = Parameter(
    m,
    &quot;total_cost_extern&quot;,
    is_miro_output=True,
    description=&quot;total cost for the imported power&quot;,
)

total_cost_extern[...] = Sum(
    j,
    cost_external_grid[j] * external_grid_power.l[j],
)

total_cost = Parameter(
    m,
    &quot;total_cost&quot;,
    is_miro_output=True,
    description=&quot;total cost to fulfill the load demand&quot;,
)

total_cost[...] = total_cost_gen + total_cost_battery + total_cost_extern</code></pre>
                    </details>
                    <p>
                      We also combine our power variables with the load demand
                      input into a single output parameter to later show how
                      the sum of all power flows meets the load demand:
                    </p>
                    <pre><code class="language-python"># Power output
power_output_header = Set(
    m,
    name=&quot;power_output_header&quot;,
    records=[&quot;battery&quot;, &quot;external_grid&quot;, &quot;generators&quot;, &quot;load_demand&quot;],
)

report_output = Parameter(
    m,
    name=&quot;report_output&quot;,
    domain=[j, power_output_header],
    description=&quot;optimal combination of incoming power flows&quot;,
    is_miro_output=True,
)

report_output[j, &quot;generators&quot;] = Sum(i, gen_power.l[i, j])
report_output[j, &quot;battery&quot;] = battery_power.l[j]
report_output[j, &quot;external_grid&quot;] = external_grid_power.l[j]
report_output[j, &quot;load_demand&quot;] = load_demand[j]</code></pre>
                    <p>
                      Now, we can launch MIRO to see our first fully
                      interactive modeling application!
                    </p>
                    <pre><code class="language-bash">gamspy run miro --path &lt;path_to_your_MIRO_installation&gt; --model &lt;path_to_your_model&gt;</code></pre>
                    <p>
                      After starting MIRO, the application should look like
                      this:
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/first_start.png"
                        alt="Result of first MIRO start"
                      />
                    </div>
                  </div>
                  <!--//section-block-->
                  <div
                    id="effective-data-validation-using-log-files"
                    class="section-block"
                  >
                    <h3 class="block-title">
                      Effective Data Validation Using Log Files
                    </h3>
                    <p>
                      Finally, we will briefly discuss data validation. This is
                      critical to ensuring the accuracy and reliability of
                      optimization models. Log files are key to checking the
                      consistency of input data, and generating reports on
                      inconsistencies helps prevent errors and user
                      frustration. Here we will only verify that our input
                      values are all non-negative. While finding effective
                      validation checks can be challenging, clearly identifying
                      the constraints or values causing infeasibility can
                      significantly improve the user experience.
                    </p>
                    <p>
                      In MIRO, you have the option to create a custom log file.
                      However, since we are using GAMSPy, we can also directly
                      write to stdout for logging. If we follow the specified
                      <a
                        href="https://www.gams.com/miro/configuration_general.html#miro-log-syntax"
                        target="_blank"
                        >MIRO log syntax</a
                      >
                      here, any invalid data will be highlighted directly above
                      the corresponding input data sheet in MIRO.
                    </p>
                    <p>
                      The syntax that must be used for MIRO to jump directly to
                      the table with the incorrect data is as follows:
                    </p>
                    <pre><code class="language-plaintext">symbolname:: Error message</code></pre>
                    <p>
                      Try for yourself how a simple verification of the sign of
                      the input values might look. Keep in mind that you should
                      validate the data before attempting to solve the model.
                      If the validation fails, specify which value caused the
                      failure and raise an exception, as there’s no need to
                      solve the model in this case.
                    </p>
                    <details>
                      <summary>A possible data validation</summary>
                      <pre><code class="language-python">no_negative_gen_spec = generator_specifications.records[generator_specifications.records[&quot;value&quot;] &lt; 0]
no_negative_load = load_demand.records[load_demand.records[&quot;value&quot;] &lt; 0]
no_negative_cost = cost_external_grid.records[
    cost_external_grid.records[&quot;value&quot;] &lt; 0
]

print(
    &quot;&quot;&quot;------------------------------------\n       Validating data\n------------------------------------\n&quot;&quot;&quot;
)
errors = False

if not no_negative_gen_spec.empty:
    print(
        &quot;generator_specifications:: No negative values for the generator specifications allowed!\n&quot;
    )
    for _, row in no_negative_gen_spec.iterrows():
        print(f&#39;{row[&quot;i&quot;]} has a negative value.\n&#39;)
    errors = True

if not no_negative_load.empty:
    print(
        &quot;timewise_load_demand_and_cost_external_grid_data:: No negative load demand allowed!\n&quot;
    )
    for _, row in no_negative_load.iterrows():
        print(f&#39;{row[&quot;j&quot;]} has negative load demand.\n&#39;)
    errors = True

if not no_negative_cost.empty:
    print(
        &quot;timewise_load_demand_and_cost_external_grid_data:: No negative cost allowed!\n&quot;
    )
    for _, row in no_negative_cost.iterrows():
        print(f&#39;{row[&quot;j&quot;]} has negative external grid cost.\n&#39;)
    errors = True

if errors:
    raise Exception(&quot;Data errors detected&quot;)
print(&quot;Data ok\n&quot;)</code></pre>
                    </details>
                    <div class="section-block">
                      <div
                        style="
                          display: flex;
                          justify-content: center;
                          align-items: center;
                        "
                      >
                        <div>
                          <img
                            src="assets/images/step_by_step_tutorial/log.png"
                            alt="input section"
                            style="max-width: 100%"
                          />
                        </div>
                        <div>
                          <img
                            src="assets/images/step_by_step_tutorial/data_validation.png"
                            alt="input section"
                            style="max-width: 100%"
                          />
                        </div>
                      </div>
                    </div>
                    <details>
                      <summary>Full updated GAMSPy model</summary>
                      <pre><code class="language-python">import pandas as pd
import sys

from gamspy import (
    Container,
    Alias,
    Equation,
    Model,
    Parameter,
    Sense,
    Set,
    Sum,
    Variable,
    Ord,
    Options,
    ModelStatus,
    SolveStatus,
)


def main():
    m = Container()

    # Generator parameters
    generator_specifications_input = pd.DataFrame(
        [
            [&quot;gen0&quot;, 1.1, 220, 50, 100, 4, 2],
            [&quot;gen1&quot;, 1.3, 290, 80, 190, 4, 2],
            [&quot;gen2&quot;, 0.9, 200, 10, 70, 4, 2],
        ],
        columns=[
            &quot;i&quot;,
            &quot;cost_per_unit&quot;,
            &quot;fixed_cost&quot;,
            &quot;min_power_output&quot;,
            &quot;max_power_output&quot;,
            &quot;min_up_time&quot;,
            &quot;min_down_time&quot;,
        ],
    )

    # Load demand to be fulfilled by the energy management system
    # combine with cost external grid, to have one source of truth for the hours (Set j)
    timewise_load_demand_and_cost_external_grid_input = pd.DataFrame(
        [
            [&quot;hour00&quot;, 200, 1.5],
            [&quot;hour01&quot;, 180, 1.0],
            [&quot;hour02&quot;, 170, 1.0],
            [&quot;hour03&quot;, 160, 1.0],
            [&quot;hour04&quot;, 150, 1.0],
            [&quot;hour05&quot;, 170, 1.0],
            [&quot;hour06&quot;, 190, 1.2],
            [&quot;hour07&quot;, 210, 1.8],
            [&quot;hour08&quot;, 290, 2.1],
            [&quot;hour09&quot;, 360, 1.9],
            [&quot;hour10&quot;, 370, 1.8],
            [&quot;hour11&quot;, 350, 1.6],
            [&quot;hour12&quot;, 310, 1.6],
            [&quot;hour13&quot;, 340, 1.6],
            [&quot;hour14&quot;, 390, 1.8],
            [&quot;hour15&quot;, 400, 1.9],
            [&quot;hour16&quot;, 420, 2.1],
            [&quot;hour17&quot;, 500, 3.0],
            [&quot;hour18&quot;, 440, 2.1],
            [&quot;hour19&quot;, 430, 1.9],
            [&quot;hour20&quot;, 420, 1.8],
            [&quot;hour21&quot;, 380, 1.6],
            [&quot;hour22&quot;, 340, 1.2],
            [&quot;hour23&quot;, 320, 1.2],
        ],
        columns=[&quot;j&quot;, &quot;load_demand&quot;, &quot;cost_external_grid&quot;],
    )

    # Set
    i = Set(
        m,
        name=&quot;i&quot;,
        description=&quot;generators&quot;,
    )
    j = Set(
        m,
        name=&quot;j&quot;,
        description=&quot;hours&quot;,
    )
    t = Alias(m, name=&quot;t&quot;, alias_with=j)

    generator_spec_header = Set(
        m,
        name=&quot;generator_spec_header&quot;,
        records=[
            &quot;cost_per_unit&quot;,
            &quot;fixed_cost&quot;,
            &quot;min_power_output&quot;,
            &quot;max_power_output&quot;,
            &quot;min_up_time&quot;,
            &quot;min_down_time&quot;,
        ],
    )

    timewise_header = Set(
        m, name=&quot;timewise_header&quot;, records=[&quot;load_demand&quot;, &quot;cost_external_grid&quot;]
    )

    # Data
    # Generator parameters
    generator_specifications = Parameter(
        m,
        name=&quot;generator_specifications&quot;,
        domain=[i, generator_spec_header],
        domain_forwarding=[True, False],
        records=generator_specifications_input.melt(
            id_vars=&quot;i&quot;, var_name=&quot;generator_spec_header&quot;
        ),
        is_miro_input=True,
        is_miro_table=True,
        description=&quot;Specifications of each generator&quot;,
    )

    # To improve readability of the equations we extract the individual columns.
    # Since we want a single source of truth we combine them for MIRO.
    gen_cost_per_unit = Parameter(
        m,
        name=&quot;gen_cost_per_unit&quot;,
        domain=[i],
        description=&quot;cost per unit of generator i&quot;,
    )

    gen_fixed_cost = Parameter(
        m, name=&quot;gen_fixed_cost&quot;, domain=[i], description=&quot;fixed cost of generator i&quot;
    )

    gen_min_power_output = Parameter(
        m,
        name=&quot;gen_min_power_output&quot;,
        domain=[i],
        description=&quot;minimal power output of generator i&quot;,
    )

    gen_max_power_output = Parameter(
        m,
        name=&quot;gen_max_power_output&quot;,
        domain=[i],
        description=&quot;maximal power output of generator i&quot;,
    )

    gen_min_up_time = Parameter(
        m,
        name=&quot;gen_min_up_time&quot;,
        domain=[i],
        description=&quot;minimal up time of generator i&quot;,
    )

    gen_min_down_time = Parameter(
        m,
        name=&quot;gen_min_down_time&quot;,
        domain=[i],
        description=&quot;minimal down time of generator i&quot;,
    )

    gen_cost_per_unit[i] = generator_specifications[i, &quot;cost_per_unit&quot;]
    gen_fixed_cost[i] = generator_specifications[i, &quot;fixed_cost&quot;]
    gen_min_power_output[i] = generator_specifications[i, &quot;min_power_output&quot;]
    gen_max_power_output[i] = generator_specifications[i, &quot;max_power_output&quot;]
    gen_min_up_time[i] = generator_specifications[i, &quot;min_up_time&quot;]
    gen_min_down_time[i] = generator_specifications[i, &quot;min_down_time&quot;]

    # Battery parameters
    cost_bat_power = Parameter(m, &quot;cost_bat_power&quot;, records=1, is_miro_input=True)
    cost_bat_energy = Parameter(m, &quot;cost_bat_energy&quot;, records=2, is_miro_input=True)

    # Load demand and external grid
    timewise_load_demand_and_cost_external_grid_data = Parameter(
        m,
        name=&quot;timewise_load_demand_and_cost_external_grid_data&quot;,
        domain=[j, timewise_header],
        domain_forwarding=[True, False],
        records=timewise_load_demand_and_cost_external_grid_input.melt(
            id_vars=&quot;j&quot;, var_name=&quot;timewise_header&quot;
        ),
        is_miro_input=True,
        is_miro_table=True,
        description=&quot;Timeline for load demand and cost of the external grid.&quot;,
    )

    load_demand = Parameter(
        m, name=&quot;load_demand&quot;, domain=[j], description=&quot;load demand at hour j&quot;
    )

    cost_external_grid = Parameter(
        m,
        name=&quot;cost_external_grid&quot;,
        domain=[j],
        description=&quot;cost of the external grid at hour j&quot;,
    )

    load_demand[j] = timewise_load_demand_and_cost_external_grid_data[j, &quot;load_demand&quot;]
    cost_external_grid[j] = timewise_load_demand_and_cost_external_grid_data[
        j, &quot;cost_external_grid&quot;
    ]

    max_input_external_grid = Parameter(
        m,
        name=&quot;max_input_external_grid&quot;,
        records=10,
        is_miro_input=True,
        description=&quot;maximal power that can be imported from the external grid every hour&quot;,
    )

    no_negative_gen_spec = generator_specifications.records[
        generator_specifications.records[&quot;value&quot;] &lt; 0
    ]
    no_negative_load = load_demand.records[load_demand.records[&quot;value&quot;] &lt; 0]
    no_negative_cost = cost_external_grid.records[
        cost_external_grid.records[&quot;value&quot;] &lt; 0
    ]

    print(
        &quot;&quot;&quot;------------------------------------\n       Validating data\n------------------------------------\n&quot;&quot;&quot;
    )
    errors = False

    if not no_negative_gen_spec.empty:
        print(
            &quot;generator_specifications:: No negative values for the generator specifications allowed!\n&quot;
        )
        for _, row in no_negative_gen_spec.iterrows():
            print(f&#39;{row[&quot;i&quot;]} has a negative value.\n&#39;)
        errors = True

    if not no_negative_load.empty:
        print(
            &quot;timewise_load_demand_and_cost_external_grid_data:: No negative load demand allowed!\n&quot;
        )
        for _, row in no_negative_load.iterrows():
            print(f&#39;{row[&quot;j&quot;]} has negative load demand.\n&#39;)
        errors = True

    if not no_negative_cost.empty:
        print(
            &quot;timewise_load_demand_and_cost_external_grid_data:: No negative cost allowed!\n&quot;
        )
        for _, row in no_negative_cost.iterrows():
            print(f&#39;{row[&quot;j&quot;]} has negative external grid cost.\n&#39;)
        errors = True

    if errors:
        raise Exception(&quot;Data errors detected&quot;)
    print(&quot;Data ok\n&quot;)

    # Variable
    # Generator
    gen_power = Variable(
        m,
        name=&quot;gen_power&quot;,
        type=&quot;positive&quot;,
        domain=[i, j],
        description=&quot;Dispatched power from generator i at hour j&quot;,
        is_miro_output=True,
    )

    gen_active = Variable(
        m,
        name=&quot;gen_active&quot;,
        type=&quot;binary&quot;,
        domain=[i, j],
        description=&quot;is generator i active at hour j&quot;,
    )

    # Battery
    battery_power = Variable(
        m,
        name=&quot;battery_power&quot;,
        domain=[j],
        description=&quot;power charged or discharged from the battery at hour j&quot;,
        is_miro_output=True,
    )

    battery_delivery_rate = Variable(
        m,
        name=&quot;battery_delivery_rate&quot;,
        description=&quot;power (delivery) rate of the battery energy system&quot;,
        is_miro_output=True,
    )

    battery_storage = Variable(
        m,
        name=&quot;battery_storage&quot;,
        description=&quot;energy (storage) rate of the battery energy system&quot;,
        is_miro_output=True,
    )

    # External grid
    external_grid_power = Variable(
        m,
        name=&quot;external_grid_power&quot;,
        type=&quot;positive&quot;,
        domain=[j],
        description=&quot;power imported from the external grid at hour j&quot;,
        is_miro_output=True,
    )

    # Equation
    fulfill_load = Equation(
        m,
        name=&quot;fulfill_load&quot;,
        domain=[j],
        description=&quot;load balance needs to be met very hour j&quot;,
    )

    gen_above_min_power = Equation(
        m,
        name=&quot;gen_above_min_power&quot;,
        domain=[i, j],
        description=&quot;generators power should be above the minimal output&quot;,
    )

    gen_below_max_power = Equation(
        m,
        name=&quot;gen_below_max_power&quot;,
        domain=[i, j],
        description=&quot;generators power should be below the maximal output&quot;,
    )

    gen_above_min_down_time = Equation(
        m,
        name=&quot;gen_above_min_down_time&quot;,
        domain=[i, j],
        description=&quot;generators down time should be above the minimal down time&quot;,
    )

    gen_above_min_up_time = Equation(
        m,
        name=&quot;gen_above_min_up_time&quot;,
        domain=[i, j],
        description=&quot;generators up time should be above the minimal up time&quot;,
    )

    battery_above_min_delivery = Equation(
        m,
        name=&quot;battery_above_min_delivery&quot;,
        domain=[j],
        description=&quot;battery delivery rate (charge rate) above min power rate&quot;,
    )

    battery_below_max_delivery = Equation(
        m,
        name=&quot;battery_below_max_delivery&quot;,
        domain=[j],
        description=&quot;battery delivery rate below max power rate&quot;,
    )

    battery_above_min_storage = Equation(
        m,
        name=&quot;battery_above_min_storage&quot;,
        domain=[t],
        description=&quot;battery storage above negative energy rate (since negative power charges the battery)&quot;,
    )

    battery_below_max_storage = Equation(
        m,
        name=&quot;battery_below_max_storage&quot;,
        domain=[t],
        description=&quot;sum over battery delivery below zero (cant deliver energy that is not stored)&quot;,
    )

    external_power_upper_limit = Equation(
        m,
        name=&quot;external_power_upper_limit&quot;,
        domain=[j],
        description=&quot; input from the external grid is limited&quot;,
    )

    fulfill_load[j] = (
        Sum(i, gen_power[i, j]) + battery_power[j] + external_grid_power[j]
        == load_demand[j]
    )

    gen_above_min_power[i, j] = (
        gen_min_power_output[i] * gen_active[i, j] &lt;= gen_power[i, j]
    )

    gen_below_max_power[i, j] = (
        gen_power[i, j] &lt;= gen_max_power_output[i] * gen_active[i, j]
    )

    # if j=0 -&gt; j.lag(1) = 0 which doesn&#39;t brake the equation,
    # since generator is of at start, resulting in negative right side, therefore the sum is always above
    gen_above_min_down_time[i, j] = Sum(
        t.where[(Ord(t) &gt;= Ord(j)) &amp; (Ord(t) &lt;= (Ord(j) + gen_min_down_time[i] - 1))],
        1 - gen_active[i, t],
    ) &gt;= gen_min_down_time[i] * (gen_active[i, j.lag(1)] - gen_active[i, j])

    # and for up it correctly starts the check that if its turned on in the first step
    # it has to stay on for the min up time
    gen_above_min_up_time[i, j] = Sum(
        t.where[(Ord(t) &gt;= Ord(j)) &amp; (Ord(t) &lt;= (Ord(j) + gen_min_up_time[i] - 1))],
        gen_active[i, t],
    ) &gt;= gen_min_up_time[i] * (gen_active[i, j] - gen_active[i, j.lag(1)])

    battery_above_min_delivery[j] = -battery_delivery_rate &lt;= battery_power[j]

    battery_below_max_delivery[j] = battery_power[j] &lt;= battery_delivery_rate

    battery_above_min_storage[t] = -battery_storage &lt;= Sum(
        j.where[Ord(j) &lt;= Ord(t)], battery_power[j]
    )

    battery_below_max_storage[t] = Sum(j.where[Ord(j) &lt;= Ord(t)], battery_power[j]) &lt;= 0

    external_power_upper_limit[j] = external_grid_power[j] &lt;= max_input_external_grid

    obj = (
        Sum(
            j,
            Sum(i, gen_cost_per_unit[i] * gen_power[i, j] + gen_fixed_cost[i])
            + cost_external_grid[j] * external_grid_power[j],
        )
        + cost_bat_power * battery_delivery_rate
        + cost_bat_energy * battery_storage
    )

    # Solve
    bess = Model(
        m,
        name=&quot;bess&quot;,
        equations=m.getEquations(),
        problem=&quot;MIP&quot;,
        sense=Sense.MIN,
        objective=obj,
    )

    bess.solve(
        solver=&quot;CPLEX&quot;,
        output=sys.stdout,
        options=Options(equation_listing_limit=1, relative_optimality_gap=0),
    )

    if bess.solve_status not in [
        SolveStatus.NormalCompletion,
        SolveStatus.TerminatedBySolver,
    ] or bess.status not in [ModelStatus.OptimalGlobal, ModelStatus.Integer]:
        print(&quot;No solution exists for your input data.\n&quot;)
        raise Exception(&quot;Infeasible.&quot;)

    # Extract the output data

    # Power output
    power_output_header = Set(
        m,
        name=&quot;power_output_header&quot;,
        records=[&quot;battery&quot;, &quot;external_grid&quot;, &quot;generators&quot;, &quot;load_demand&quot;],
    )

    report_output = Parameter(
        m,
        name=&quot;report_output&quot;,
        domain=[j, power_output_header],
        description=&quot;Optimal combination of incoming power flows&quot;,
        is_miro_output=True,
    )

    report_output[j, &quot;generators&quot;] = Sum(i, gen_power.l[i, j])
    report_output[j, &quot;battery&quot;] = battery_power.l[j]
    report_output[j, &quot;external_grid&quot;] = external_grid_power.l[j]
    report_output[j, &quot;load_demand&quot;] = load_demand[j]

    # Costs
    total_cost_gen = Parameter(
        m,
        &quot;total_cost_gen&quot;,
        is_miro_output=True,
        description=&quot;Total cost of the generators&quot;,
    )

    total_cost_gen[...] = Sum(
        j, Sum(i, gen_cost_per_unit[i] * gen_power.l[i, j] + gen_fixed_cost[i])
    )

    total_cost_battery = Parameter(
        m,
        &quot;total_cost_battery&quot;,
        is_miro_output=True,
        description=&quot;Total cost of the BESS&quot;,
    )

    total_cost_battery[...] = (
        cost_bat_power * battery_delivery_rate.l + cost_bat_energy * battery_storage.l
    )

    total_cost_extern = Parameter(
        m,
        &quot;total_cost_extern&quot;,
        is_miro_output=True,
        description=&quot;Total cost for the imported power&quot;,
    )

    total_cost_extern[...] = Sum(
        j,
        cost_external_grid[j] * external_grid_power.l[j],
    )

    total_cost = Parameter(
        m,
        &quot;total_cost&quot;,
        is_miro_output=True,
        description=&quot;Total cost to fulfill the load demand&quot;,
    )

    total_cost[...] = total_cost_gen + total_cost_battery + total_cost_extern

if __name__ == &quot;__main__&quot;:
    main()
                    </code></pre>
                    </details>
                  </div>
                  <!--//section-block-->
                  <div id="key-takeaways-1" class="section-block">
                    <h3 class="block-title">Key Takeaways</h3>
                    <ul>
                      <li>
                        <strong>Interactive Inputs and Outputs</strong>:
                        Marking parameters as
                        <code class="language-python">is_miro_input</code> or
                        <code class="language-python">is_miro_output</code>
                        enables dynamic fields for data input and real-time
                        feedback, enhancing flexibility and debugging.
                      </li>
                      <li>
                        <strong>Rapid Prototyping</strong>: Define output
                        parameters based on variables to summarize important
                        information such as cost. Then visually inspect the
                        output to catch problems early!
                      </li>
                      <li>
                        <strong>Data Validation and Error Reporting</strong>:
                        Ensuring input consistency through log files and custom
                        error messages (via MIRO syntax) helps catch errors
                        early and improves user experience by highlighting
                        inconsistencies directly in the input data sheets.
                      </li>
                    </ul>
                  </div>
                </section>
                <!--//section-block-->
                <section
                  id="basic-application---rapid-prototyping"
                  class="doc-section"
                >
                  <h2 class="section-title">
                    Basic Application - Rapid Prototyping
                  </h2>
                  <p>
                    Now that we have our first MIRO application, let’s explore
                    the types of interaction we get right out of the box.
                  </p>
                  <!--//section-block-->
                  <div id="input" class="section-block">
                    <h3 class="block-title">Input</h3>
                    <p>
                      At first the input parameters are empty. By clicking on
                      <em>Load data</em>, we can load the default values
                      defined by the records option in our GAMSPy code.
                    </p>
                    <p>
                      If our input parameters are correctly set up, we can
                      modify them and then click <em>Solve model</em> to
                      compute solutions for new input values.
                    </p>
                    <p>
                      Even before solving, it can sometimes be useful to
                      visualize the data to catch inconsistencies—such as
                      negative load demand (which shouldn’t happen) or cost
                      values that don’t align with expectations throughout the
                      day. To view this data graphically, we can toggle the
                      chart view in the top-right corner by clicking the
                      <img
                        src="https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/svgs/solid/chart-bar.svg"
                        width="15"
                        height="15"
                      />
                      icon. Here, we can filter, aggregate, and pivot the data.
                      We can also use different chart types directly through
                      the
                      <a
                        href="https://www.gams.com/miro/charts.html#pivot-chart"
                        target="_blank"
                        >Pivot Table</a
                      >.
                    </p>
                    <p>
                      In our example, we pivoted the headers and selected line
                      graphs. Because the dimensions of
                      <code class="language-python">load_demand</code> and
                      <code class="language-python">cost_external_grid</code>
                      differ, it initially looks as though
                      <code class="language-python">cost_external_grid</code>
                      is zero, even though it isn’t. To clarify this, we add a
                      second y-axis with a different scale:
                    </p>
                    <ol type="1">
                      <li>Switch the display type to <em>Line Chart</em>.</li>
                      <li>
                        Click the
                        <img
                          src="https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/svgs/solid/square-plus.svg"
                          width="15"
                          height="15"
                        />
                        icon to add a new view.
                      </li>
                      <li>
                        In the <em>Second Axis</em> tab, pick which series
                        should use the additional y-axis.
                      </li>
                      <li>(Optional) Add a title and label for the axis.</li>
                      <li>Save the view.</li>
                      <li>
                        Press the
                        <img
                          src="https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/svgs/solid/table.svg"
                          width="15"
                          height="15"
                        />
                        icon to enable
                        <a
                          href="https://www.gams.com/miro/charts.html#presentation-mode"
                          target="_blank"
                          >Presentation Mode</a
                        >.
                      </li>
                    </ol>
                    <p>You should end up with something like this:</p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/timeline_plot_input.png"
                        alt="Result of pivot tool for the Timeline"
                      />
                    </div>
                  </div>
                  <!--//section-block-->
                  <div id="output" class="section-block">
                    <h3 class="block-title">Output</h3>
                    <p>
                      When implementing the model, the output is often more
                      interesting than the input, so let’s see what we can do
                      here.
                    </p>
                    <p>
                      MIRO separates scalar outputs into scalar parameters and
                      scalar variables/equations:
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/output_scalars.png"
                        alt="Output Scalars"
                      />
                    </div>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/output_scalars_ve.png"
                        alt="Output Scalars for variables and equations"
                      />
                    </div>
                    <p>
                      As you can see, for scalar variables it contains not only
                      the value of the scalar (<code class="language-python"
                        >level</code
                      >), but also
                      <code class="language-python">marginal</code>,
                      <code class="language-python">lower</code>,
                      <code class="language-python">upper</code> and
                      <code class="language-python">scale</code>. And since
                      scalar parameters don’t have these attributes, they are
                      treated separately.
                    </p>
                    <p>
                      For multi-dimensional output variables, we can again use
                      the Pivot tool. For example, suppose we want to see how
                      much power each generator is supplying at any given time.
                      We can open the output variable containing the power
                      values of the generators, pivot by generator, and filter
                      by the `level’ value. Next, we select the
                      <em>Stacked Bar Chart</em> option, which gives us this
                      view:
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/output_generators_stacked_bar.png"
                        alt="Result of pivot tool for Generators"
                      />
                    </div>
                    <p>
                      We can see that <em>gen1</em> is the most expensive
                      generator. It is used a bit at the beginning, then it is
                      turned off after its minimum up time of four hours. And
                      after another four hours it is turned on again, which
                      also fulfills the minimum down time. As you can see,
                      <em>gen0</em> is the cheapest in both unit and fixed
                      costs, so it is always at full power. All in all, we see
                      that the minimum uptime and downtime constraints are met,
                      and that each active generator stays within its power
                      limits. If any of these constraints were violated, we
                      would know exactly which part of the model to revisit.
                    </p>
                    <p>
                      Let’s look at another example. Recall that we combined
                      all power values with the given load demand into a single
                      parameter so we could verify if the load demand is indeed
                      met and how each source contributes at each hour. If we
                      chose a <em>Stacked Bar Chart</em>, we can not easily
                      compare the load demand with the sum of the power
                      sources. Instead, we:
                    </p>
                    <ol type="1">
                      <li>Select <em>Stacked Bar Chart</em>.</li>
                      <li>
                        Click the
                        <img
                          src="https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/svgs/solid/square-plus.svg"
                          width="15"
                          height="15"
                        />
                        icon to add a new view.
                      </li>
                      <li>
                        In the <em>Combo Chart</em> tab, specify that the load
                        demand should be shown as a <em>Line</em> and excluded
                        from the stacked bars.
                      </li>
                      <li>Save the view.</li>
                    </ol>
                    <p>The result should look like this:</p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/output_load_balance.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                    <p>
                      Here, we can immediately confirm that the load demand is
                      always satisfied—except when the BESS is being charged,
                      which is shown by the negative part of the blue bar. This
                      is another good indication that our constraints are
                      working correctly.
                    </p>
                    <p>
                      We can create similar visualizations for battery power or
                      external grid power to ensure their constraints are also
                      satisfied. By now, you should have a better grasp of the
                      powerful pivot tool in MIRO and how to use it to check
                      your model implementation on the fly.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="key-takeaways-2" class="section-block">
                    <h3 class="block-title">Key Takeaways</h3>
                    <ul>
                      <li>
                        <strong>Visual Validation</strong>: Pivot tables and
                        charts in MIRO allow you to quickly verify your
                        constraints.
                      </li>
                      <li>
                        <strong>Logical Insights</strong>: For example, use
                        stacked bar or line graphs to show whether demand is
                        being met, or which generator combination is the
                        cheapest.
                      </li>
                    </ul>
                    <p>
                      Now that we have our first MIRO application and a better
                      understanding of our optimization model, in the next part
                      we will look at the Configuration Mode, where you can
                      customize your application without writing any code!
                    </p>
                  </div>
                </section>
                <!--//section-block-->
                <section id="configuration-mode" class="doc-section">
                  <h2 class="section-title">Configuration Mode</h2>
                  <div class="section-block">
                    <p>
                      In the last part we went from a GAMSPy model to a first
                      basic GAMS MIRO application for this
                      <a href="https://miro.gams.com/gallery/app_direct/bess/"
                        >gallery</a
                      >
                      example. Now that we have a better understanding of our
                      model and are confident that it satisfies the given
                      constraints while providing a reasonable solution, we can
                      begin to configure our application.
                    </p>
                    <p>
                      To do this, we will start our MIRO application in
                      <a
                        href="https://www.gams.com/miro/customize.html"
                        target="_blank"
                        >Configuration Mode</a
                      >.
                    </p>
                    <pre><code class="language-bash">gamspy run miro --mode=&quot;config&quot; --path &lt;path_to_your_MIRO_installation&gt; --model &lt;path_to_your_model&gt;</code></pre>
                    <p>You should see the following:</p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/start_config_mode.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                    <p>
                      The
                      <a
                        href="https://www.gams.com/miro/customize.html"
                        target="_blank"
                        >Configuration Mode</a
                      >
                      gives us access to a wealth of out-of-the-box
                      customization options, so we don’t need to write any code
                      for now.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="general-settings" class="section-block">
                    <h3 class="block-title">General Settings</h3>
                    <p>
                      Let’s start by adjusting some general settings. We can
                      give our application a title, add a logo, include a
                      README, and enable loading the default scenario at
                      startup. These are just a few of the available options.
                      If your company has a specific CSS style, you could
                      include it here as well. For the complete list of
                      settings, see the
                      <a
                        href="https://www.gams.com/miro/configuration_general.html"
                        >General settings</a
                      >
                      documentation.
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/logo_read_me.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                  </div>
                  <!--//section-block-->
                  <div id="symbols" class="section-block">
                    <h3 class="block-title">Symbols</h3>
                    <p>
                      Next, we move to the
                      <a
                        href="https://www.gams.com/miro/configuration_symbols.html"
                        target="_blank"
                        >Symbols</a
                      >
                      section. First, we change our symbol aliases to something
                      more intuitive. Then, assuming we might want to tweak
                      scalar inputs often, we change the order in which the
                      input symbols appear. Finally, in some cases, we need to
                      mark variables or parameters as outputs only so we can
                      use them in a custom renderer (we’ll introduce custom
                      renderers in the next part). If such outputs are solely
                      for backend use, we might hide them to avoid cluttering
                      the output section.
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/gen_input.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                  </div>
                  <!--//section-block-->
                  <div id="tables" class="section-block">
                    <h3 class="block-title">Tables</h3>
                    <p>
                      In the
                      <a
                        href="https://www.gams.com/miro/configuration_tables.html"
                        target="_blank"
                        >Tables</a
                      >
                      section, we can customize the general configuration of
                      input and output tables. In our example, this is
                      optional—our current settings work well enough.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="input-widgets" class="section-block">
                    <h3 class="block-title">Input Widgets</h3>
                    <p>
                      Input widgets are all items that communicate input data
                      with the model. We have several inputs and we will
                      customize them in the
                      <a
                        href="https://www.gams.com/miro/widgets.html"
                        target="_blank"
                        >Input Widgets</a
                      >
                      section. Let’s take a look at our scalar inputs first. We
                      can choose between sliders, drop down menus, checkboxes,
                      or numeric inputs. Here, we’ll set them to sliders. If we
                      don’t want to impose any restrictions on the value
                      (minimum, maximum and increment), we would stay with
                      numeric inputs. The best choice depends on the nature of
                      the input data.
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/input.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                    <p>
                      For our multidimensional inputs, tables are the only
                      direct option in Configuration Mode. We can pick from
                      three table types. Because our current datasets are
                      relatively small and we don’t plan significant editing,
                      we’ll stick with the default table. If we anticipate
                      working with massive datasets, switching to the
                      performance-optimized <em>Big Data Table</em> is wise. If
                      you know you will be doing a lot of data slicing in your
                      table, you should choose the <em>Pivot Table</em>. For
                      more details on table types, see the
                      <a
                        href="https://www.gams.com/miro/widgets.html#widget-table"
                        target="_blank"
                        >documentation</a
                      >.
                    </p>
                    <p>
                      If these three table types aren’t sufficient for your
                      needs, you can build a custom widget—a process we’ll see
                      in the next part.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="graphs" class="section-block">
                    <h3 class="block-title">Graphs</h3>
                    <p>
                      Finally, let’s explore the
                      <a
                        href="https://www.gams.com/miro/charts.html"
                        target="_blank"
                        >Graphs</a
                      >. This is where we can experiment with data
                      visualization. For every multidimensional symbol (input
                      or output), we can define a default visualization. We can
                      choose from the most common plot types or use the Pivot
                      Table again, which we used during rapid prototyping. If
                      we’ve already created useful views, we can now set them
                      as defaults so that anyone opening the application
                      immediately sees the relevant charts.
                    </p>
                    <p>
                      We won’t cover every possibility here because we looked
                      at the Pivot tool in detail earlier. However, let’s check
                      out a small example using <em>value boxes</em> for our
                      output. First, we select a scenario (currently, only the
                      default scenario is available). Then we pick the GAMS
                      symbol *_scalars_out: Output Scalars* and choose the
                      charting type <em>Valuebox for scalar values</em>. From
                      there, we can specify the order of the value boxes, their
                      colors, and units. After clicking <em>Save</em>, we
                      launch the application in Base Mode and see something
                      like this:
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/output_value_boxes.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                    <p>
                      We can also add the views we set up in the previous
                      section.
                    </p>
                    <p>
                      If you are looking for something specific, check out the
                      <a
                        href="https://www.gams.com/miro/charts.html"
                        target="_blank"
                        >documentation</a
                      >, which provides an extensive guide to all available
                      plot types.
                    </p>
                    <p>
                      Each change we make in the Configuration Mode is
                      automatically saved to
                      <span class="code">&lt;model_name&gt;.json</span>. In the
                      documentation you will find the corresponding json
                      snippets you would need to add, but don't worry, this is
                      exactly what the Configuration Mode does when you save a
                      graph!
                    </p>
                    <p>
                      Finally, in the <em>Charting Type</em> drop down menu you
                      will also find the <em>Custom Renderer</em> option, which
                      we will talk about in the next part.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="scenario-analysis" class="section-block">
                    <h3 class="block-title">Scenario analysis</h3>
                    <p>
                      MIRO has several build-in
                      <a
                        href="https://www.gams.com/miro/start.html#scenario-comparison"
                        target="_blank"
                        >scenario comparison modes</a
                      >
                      that allow to compare the input and/or output data of
                      different model runs. While most compare modes are
                      available out of the box, you can enable a dashboard for
                      scenario data comparison with some app-specific
                      configuration. We will introduce the
                      <a
                        href="https://www.gams.com/miro/configuration_json_only.html#dashboard-compare"
                        target="_blank"
                        >dashboard compare</a
                      >
                      in the next section. The process for setting this up will
                      be explained after the regular dashboard renderer is
                      <a href="#dashboard-comparison">introduced</a>.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="database-management" class="section-block">
                    <h3 class="block-title">Database management</h3>
                    <p>
                      Finally the Configuration Mode also allows you to backup,
                      remove or restore a
                      <a
                        href="https://www.gams.com/miro/configuration_database.html"
                        target="_blank"
                        >database</a
                      >.
                    </p>
                    <p>
                      Since all these configurations do not take much time,
                      this could be your first draft for your management. Now
                      they can get an idea of what the final product might look
                      like, and you can go deeper and add any further
                      customizations you need. How to do this is explained in
                      the next part.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="key-takeaways-3" class="section-block">
                    <h3 class="block-title">Key Takeaways</h3>
                    <ul>
                      <li>
                        <strong>Simple Customization</strong>: Change chart
                        defaults, rename symbols, and customize input widgets
                        all from a single interface.
                      </li>
                      <li>
                        <strong>Presentation-Ready</strong>: Save preferred
                        views so end users see the best visualizations right
                        away.
                      </li>
                    </ul>
                  </div>
                </section>
                <!--//section-block-->
                <section id="dashboard" class="doc-section">
                  <h2 class="section-title">Dashboard</h2>
                  <div class="section-block">
                    <p>
                      You may have already noticed the
                      <em>Dashboard</em> option in the <em>Graphs</em> section
                      of the MIRO documentation. If we have several saved
                      <a href="#output">views</a> - perhaps some combined with
                      Key Performance Indicators (KPIs) - a dashboard can
                      provide an organized overview of our application output.
                    </p>
                    <p>
                      Creating a dashboard is not directly possible from
                      Configuration Mode. Instead, we need to edit our
                      <span class="code">&lt;model_name&gt;.json</span> file.
                      To add a dashboard, we will follow the explanation in the
                      <a
                        href="https://www.gams.com/miro/charts.html#dashboard"
                        target="_blank"
                        >documentation</a
                      >. Here we will only discuss the parts we use, for more
                      information check the documentation.
                    </p>
                    <p>
                      Before we modify the JSON file, we need to decide how we
                      want the final dashboard to look. Specifically, we should
                      choose: 1. <em>Value Boxes (Tiles)</em>: Which scalar
                      values we want to highlight, and whether they serve as
                      KPIs. 2. <em>Associated Views</em>: Which views will be
                      linked to each value box. Most likely, we can reuse the
                      views we created earlier.
                    </p>
                    <p>
                      We find our
                      <span class="code">&lt;model_name&gt;.json</span> file in
                      the
                      <span class="code">conf_ &lt;model_name&gt;</span>
                      directory. Here, we look for the
                      <code class="language-json">dataRendering</code> key—or
                      define it if it doesn’t exist (it won’t, if you followed
                      this tutorial). We need to pick an output symbol to serve
                      as our main parameter, but the choice isn’t critical—we
                      can add other symbols later as needed. We just can’t have
                      another renderer for this specific symbol if we choose to
                      have more output tabs than just the dashboard.
                    </p>
                    <p>
                      For this example, we’ll choose
                      <code class="language-json">"_scalarsve_out"</code>. This
                      symbol contains all scalar output values of variables and
                      equations. Because we probably won’t create an individual
                      renderer for them, it’s a convenient symbol choice for
                      our dashboard.
                    </p>
                    <p>
                      Getting more specific, in
                      <span class="code">bess.json</span> we now need to
                      configure three things:
                    </p>
                    <ol type="1">
                      <li>
                        The value boxes and whether they should display a
                        scalar value (KPI).
                      </li>
                      <li>
                        Which data view corresponds to which value box and
                        which charts/tables it will contain.
                      </li>
                      <li>The individual charts/tables.</li>
                    </ol>
                    <p>
                      Here’s the basic layout of our dashboard configuration
                      for the symbol
                      <code class="language-json">"_scalarsve_out"</code>:
                    </p>
                    <pre><code class="language-json">{
  &quot;dataRendering&quot;: {
    &quot;_scalarsve_out&quot;: {
      &quot;outType&quot;: &quot;dashboard&quot;,
      &quot;additionalData&quot;: [],
      &quot;options&quot;: {
        &quot;valueBoxesTitle&quot;: &quot;&quot;,
        &quot;valueBoxes&quot;: {
            ...
        },
        &quot;dataViews&quot;: {
            ...
        },
        &quot;dataViewsConfig&quot;: {
            ...
        }
      }
    }
  },
}</code></pre>
                    <p>
                      If we already had other renderers, they would appear
                      under <code class="language-json">dataRendering</code> as
                      well, we’ll add ours in the next section.
                    </p>
                    <p>
                      To keep the code snippets concise, we will only look at
                      the options we changed and have the full json at the end.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="adding-additional-data" class="section-block">
                    <h3 class="block-title">Adding Additional Data</h3>
                    <p>
                      Usually, we don’t immediately know every dataset we need.
                      In this tutorial, however, we already plan to use
                      <code class="language-json">"report_output"</code>,
                      <code class="language-json">"gen_power"</code>,
                      <code class="language-json">"battery_power"</code>
                      and
                      <code class="language-json">"external_grid_power"</code>
                      since we already have an idea of which views we want to
                      display. But of course you can add or remove symbols at
                      any time. Further we will add the input symbol
                      <code class="language-json"
                        >"generator_specifications"</code
                      >
                      to easily check if the generator characteristic are
                      fulfilled. All needed symbols are added to
                      <code class="language-json">"additionalData"</code>:
                    </p>
                    <pre><code class="language-json">&quot;additionalData&quot;: [&quot;report_output&quot;, &quot;gen_power&quot;, &quot;battery_power&quot;, &quot;external_grid_power&quot;, &quot;generator_specifications&quot;]

                  </code></pre>
                  </div>
                  <!--//section-block-->
                  <div id="value-boxes" class="section-block">
                    <h3 class="block-title">Value Boxes</h3>
                    <p>
                      In the options we can first add a title for the value
                      boxes.
                    </p>
                    <pre><code class="language-json">&quot;valueBoxesTitle&quot;: &quot;Summary indicators&quot;,</code></pre>
                    <p>
                      Let’s create six value boxes in total, but we’ll only
                      discuss the first two in detail. Try adding the others
                      for the ids:
                      <code class="language-python">"battery_power"</code>,
                      <code class="language-python">"external_grid_power"</code
                      >,
                      <code class="language-python"
                        >"battery_delivery_rate"</code
                      >
                      and
                      <code class="language-python">"battery_storage"</code>.
                      Each value box needs:
                    </p>
                    <ul>
                      <li>
                        A unique id (to link it to a corresponding data view,
                        if any).
                      </li>
                      <li>
                        An optional scalar parameter as KPI. If you don’t have
                        a matching KPI, but still want to have the view in the
                        dashboard, just set it to
                        <code class="language-json">null</code>.
                      </li>
                      <li>
                        Style parameters (see the
                        <a
                          href="https://www.gams.com/miro/charts.html#dashboard-valueboxes"
                          target="_blank"
                          >value box documentation</a
                        >
                        for more information).
                      </li>
                    </ul>
                    <pre><code class="language-json">&quot;valueBoxes&quot;: {
    &quot;color&quot;: [&quot;black&quot;, &quot;olive&quot;],
    &quot;decimals&quot;: [2, 2],
    &quot;icon&quot;: [&quot;chart-simple&quot;, &quot;chart-simple&quot;],
    &quot;id&quot;: [&quot;total_cost&quot;, &quot;gen_power&quot;],
    &quot;noColor&quot;: [true, true],
    &quot;postfix&quot;: [&quot;$&quot;, &quot;$&quot;],
    &quot;prefix&quot;: [&quot;&quot;, &quot;&quot;],
    &quot;redPositive&quot;: [false, false],
    &quot;title&quot;: [&quot;Total Cost&quot;, &quot;Generators&quot;],
    &quot;valueScalar&quot;: [&quot;total_cost&quot;, &quot;total_cost_gen&quot;]
}</code></pre>
                    <details>
                      <summary>
                        Click to see the code for all six boxes
                      </summary>
                      <pre><code class="language-json">&quot;valueBoxes&quot;: {
    &quot;color&quot;: [&quot;black&quot;, &quot;olive&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;blue&quot;],
    &quot;decimals&quot;: [2, 2, 2, 2, 2, 2],
    &quot;icon&quot;: [&quot;chart-simple&quot;, &quot;chart-simple&quot;, &quot;chart-line&quot;, &quot;chart-line&quot;, &quot;bolt&quot;, &quot;battery-full&quot;],
    &quot;id&quot;: [&quot;total_cost&quot;, &quot;gen_power&quot;, &quot;battery_power&quot;, &quot;external_grid_power&quot;, &quot;battery_delivery_rate&quot;, &quot;battery_storage&quot;],
    &quot;noColor&quot;: [true, true, true, true, true, true],
    &quot;postfix&quot;: [ &quot;$&quot;, &quot;$&quot;, &quot;$&quot;, &quot;$&quot;, &quot;kW&quot;, &quot;kWh&quot;],
    &quot;prefix&quot;: [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,  &quot;&quot;],
    &quot;redPositive&quot;: [ false, false, false, false, false, false],
    &quot;title&quot;: [&quot;Total Cost&quot;, &quot;Generators&quot;, &quot;BESS&quot;, &quot;External Grid&quot;, &quot;Power Capacity&quot;, &quot;Energy Capacity&quot;],
    &quot;valueScalar&quot;: [&quot;total_cost&quot;, &quot;total_cost_gen&quot;, &quot;total_cost_battery&quot;, &quot;total_cost_extern&quot;, &quot;battery_delivery_rate&quot;, &quot;battery_storage&quot;]
}</code></pre>
                    </details>
                  </div>
                  <!--//section-block-->
                  <div id="data-views" class="section-block">
                    <h3 class="block-title">Data Views</h3>
                    <p>
                      Next, under
                      <code class="language-json">"dataViews"</code>, we define
                      which charts or tables belong to each value box. A data
                      view is displayed when the corresponding value box is
                      clicked on in the dashboard. Multiple charts and tables
                      can be displayed. We only connect data views to the first
                      four value boxes, leaving the last two without any
                      dedicated view. This is done by simply not specifying a
                      data view for those id’s.
                    </p>
                    <p>
                      The key of a data view (e.g. <code class="language-json"
                        >"battery_power"</code
                      >) must match the id of a value box in
                      <code class="language-json">"valueBoxes"</code>. We start
                      each data view with the
                      <code class="language-json">id</code> from the
                      corresponding value box, then we assign a list of objects
                      to it. Each object within the list has a key (e.g.,
                      <code class="language-json">"BatteryTimeline"</code>)
                      that references a chart or table we will define next in
                      <code class="language-json">"dataViewsConfig"</code>, and
                      as value we assign the optional title that will be
                      displayed above the view in the dashboard. If you want to
                      have more than one chart/table in a view, just add a
                      second element to the object, as is done for
                      <code class="language-json">"gen_power"</code>.
                    </p>
                    <pre><code class="language-json">&quot;dataViews&quot;: {
    &quot;battery_power&quot;: [
        {&quot;BatteryTimeline&quot;: &quot;Charge/Discharge of the BESS&quot;}
    ],
    &quot;external_grid_power&quot;: [
        {&quot;ExternalTimeline&quot;: &quot;Power taken from the external grid&quot;}
    ],
    &quot;gen_power&quot;: [
        {&quot;GeneratorTimeline&quot;: &quot;Generators Timeline&quot;},
        {&quot;GeneratorSpec&quot;: &quot;&quot;}
    ],
    &quot;total_cost&quot;: [
        {&quot;Balance&quot;: &quot;Load demand fulfillment over time&quot;}
    ]
}</code></pre>
                  </div>
                  <!--//section-block-->
                  <div
                    id="configuring-charts-and-tables"
                    class="section-block"
                  >
                    <h3 class="block-title">Configuring Charts and Tables</h3>
                    <p>
                      The only thing left to do is to specify the actual
                      charts/tables to be displayed. This is also explained in
                      detail in the
                      <a
                        href="https://www.gams.com/miro/charts.html#dashboard-dataviewsconfig"
                        target="_blank"
                        >documentation</a
                      >. The easiest way to add charts/tables is: 1. Create
                      views in the application via the pivot tool. 2. Save
                      these views. 3. Download the JSON configuration for the
                      views (via <em>Scenario</em> (top right corner of the
                      application) -&gt; <em>Edit metadata</em> -&gt;
                      <em>View</em>). 4. Copy the JSON configuration to the
                      <code class="language-json">"dataViewsConfig"</code>
                      section. Most of the configuration can be copied
                      directly. We just need to change the way we define which
                      symbol the view is based on. It is no longer defined
                      outside, but we will add
                      <code class="language-json">"data: "report_output"</code>
                      to specify the symbol, otherwise MIRO will base the view
                      on
                      <code class="language-json">"_scalarsve_out"</code> since
                      that is the variable the renderer is based on.
                    </p>
                    <pre><code class="language-diff">{
-  &quot;report_output&quot;: {
    &quot;Balance&quot;: {
      ...
+     &quot;data&quot;: &quot;report_output&quot;,
      ...
    }
-  }
}
</code></pre>
                    <p>
                      The complete configuration in
                      <code class="language-json">"dataViewsConfig"</code>
                      looks like this:
                    </p>
                    <details>
                      <summary>
                        Click to see the code for all four views
                      </summary>
                      <pre><code class="language-json">&quot;dataViewsConfig&quot;: {
    &quot;Balance&quot;: {
        &quot;aggregationFunction&quot;: &quot;sum&quot;,
        &quot;chartOptions&quot;: {
            &quot;multiChartOptions&quot;: {
                &quot;multiChartRenderer&quot;: &quot;line&quot;,
                &quot;multiChartStepPlot&quot;: false,
                &quot;showMultiChartDataMarkers&quot;: false,
                &quot;stackMultiChartSeries&quot;: &quot;no&quot;
            },
            &quot;multiChartSeries&quot;: &quot;load_demand&quot;,
            &quot;showXGrid&quot;: true,
            &quot;showYGrid&quot;: true,
            &quot;singleStack&quot;: false,
            &quot;yLogScale&quot;: false,
            &quot;yTitle&quot;: &quot;power&quot;
        },
        &quot;cols&quot;: {
            &quot;power_output_header&quot;: null
        },
        &quot;data&quot;: &quot;report_output&quot;,
        &quot;domainFilter&quot;: {
            &quot;default&quot;: null
        },
        &quot;pivotRenderer&quot;: &quot;stackedbar&quot;,
        &quot;rows&quot;: &quot;j&quot;,
        &quot;tableSummarySettings&quot;: {
            &quot;colSummaryFunction&quot;: &quot;sum&quot;,
            &quot;enabled&quot;: false,
            &quot;rowSummaryFunction&quot;: &quot;sum&quot;
        }
    },
    &quot;BatteryTimeline&quot;: {
        &quot;aggregationFunction&quot;: &quot;sum&quot;,
        &quot;chartOptions&quot;: {
            &quot;showDataMarkers&quot;: true,
            &quot;showXGrid&quot;: true,
            &quot;showYGrid&quot;: true,
            &quot;stepPlot&quot;: false,
            &quot;yLogScale&quot;: false,
            &quot;yTitle&quot;: &quot;power&quot;
        },
        &quot;data&quot;: &quot;battery_power&quot;,
        &quot;domainFilter&quot;: {
            &quot;default&quot;: null
        },
        &quot;filter&quot;: {
            &quot;Hdr&quot;: &quot;level&quot;
        },
        &quot;pivotRenderer&quot;: &quot;line&quot;,
        &quot;rows&quot;: &quot;j&quot;,
        &quot;tableSummarySettings&quot;: {
            &quot;colEnabled&quot;: false,
            &quot;colSummaryFunction&quot;: &quot;sum&quot;,
            &quot;rowEnabled&quot;: false,
            &quot;rowSummaryFunction&quot;: &quot;sum&quot;
        }
    },
    &quot;ExternalTimeline&quot;: {
        &quot;aggregationFunction&quot;: &quot;sum&quot;,
        &quot;chartOptions&quot;: {
            &quot;showDataMarkers&quot;: true,
            &quot;showXGrid&quot;: true,
            &quot;showYGrid&quot;: true,
            &quot;stepPlot&quot;: false,
            &quot;yLogScale&quot;: false,
            &quot;yTitle&quot;: &quot;power&quot;
        },
        &quot;data&quot;: &quot;external_grid_power&quot;,
        &quot;domainFilter&quot;: {
            &quot;default&quot;: null
        },
        &quot;filter&quot;: {
            &quot;Hdr&quot;: &quot;level&quot;
        },
        &quot;pivotRenderer&quot;: &quot;line&quot;,
        &quot;rows&quot;: &quot;j&quot;,
        &quot;tableSummarySettings&quot;: {
            &quot;colEnabled&quot;: false,
            &quot;colSummaryFunction&quot;: &quot;sum&quot;,
            &quot;rowEnabled&quot;: false,
            &quot;rowSummaryFunction&quot;: &quot;sum&quot;
        }
    },
    &quot;GeneratorSpec&quot;: {
      &quot;aggregationFunction&quot;: &quot;sum&quot;,
      &quot;pivotRenderer&quot;: &quot;table&quot;,
      &quot;domainFilter&quot;: {
          &quot;default&quot;: null
      },
      &quot;tableSummarySettings&quot;: {
          &quot;rowEnabled&quot;: false,
          &quot;rowSummaryFunction&quot;: &quot;sum&quot;,
          &quot;colEnabled&quot;: false,
          &quot;colSummaryFunction&quot;: &quot;sum&quot;
      },
      &quot;data&quot;: &quot;generator_specifications&quot;,
      &quot;rows&quot;:&quot;i&quot;,
      &quot;cols&quot;: {&quot;Hdr&quot;: null}
    },
    &quot;GeneratorTimeline&quot;: {
        &quot;aggregationFunction&quot;: &quot;sum&quot;,
        &quot;chartOptions&quot;: {
            &quot;showXGrid&quot;: true,
            &quot;showYGrid&quot;: true,
            &quot;singleStack&quot;: false,
            &quot;yLogScale&quot;: false,
            &quot;yTitle&quot;: &quot;power&quot;
        },
        &quot;cols&quot;: {
            &quot;i&quot;: null
        },
        &quot;data&quot;: &quot;gen_power&quot;,
        &quot;domainFilter&quot;: {
            &quot;default&quot;: null
        },
        &quot;filter&quot;: {
            &quot;Hdr&quot;: &quot;level&quot;
        },
        &quot;pivotRenderer&quot;: &quot;stackedbar&quot;,
        &quot;rows&quot;: &quot;j&quot;,
        &quot;tableSummarySettings&quot;: {
            &quot;colEnabled&quot;: false,
            &quot;colSummaryFunction&quot;: &quot;sum&quot;,
            &quot;rowEnabled&quot;: false,
            &quot;rowSummaryFunction&quot;: &quot;sum&quot;
        }
    }
}</code></pre>
                    </details>
                    <p>Finally, we end up with this dashboard:</p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/dashboard_animation.gif"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                    <p>
                      Now that we've combined multiple outputs into a single
                      dashboard, it makes sense to hide the tabs for the
                      individual output symbols and rename the dashboard tab
                      for clarity (in the config mode). Just a heads up, you
                      should keep
                      <code class="language-python">"report_output"</code>, we
                      will add a custom renderer for it in the next part.
                    </p>
                    <p>
                      It is also possible to add custom code to the dashboard.
                      However, since this requires a bit more effort and you
                      need to know how to create a custom renderer in the first
                      place, we will leave this for the next part.
                    </p>
                  </div>
                  <!--//section-block-->
                  <div id="dashboard-comparison" class="section-block">
                    <h3 class="block-title">Dashboard Comparison</h3>
                    <p>
                      As mentioned before, MIRO provides three built-in
                      <a
                        href="https://www.gams.com/miro/start.html#scenario-comparison"
                        target="_blank"
                        >scenario comparison</a
                      >
                      modes, accessible under the
                      <em>Compare scenarios</em> tab. The
                      <em>Split view</em> comparison mode displays two
                      scenarios side by side, showing all configured renderers
                      for both input and output symbols—this includes the
                      previously created dashboard. As an example, we will
                      compare our default setting with a scenario where we set
                      the cost of BESS to zero:
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/compare_dashboards.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                    <p>
                      If you need to compare more than two scenarios, you can
                      use the <em>Tab view</em> comparison mode, which
                      organizes any number of scenarios (and their renderers)
                      into separate tabs. Finally, the
                      <em>Pivot view</em> comparison mode merges all scenario
                      data into one pivot table for each symbol. It is the same
                      pivot tool with its many possibilities that we have
                      already used so much.
                    </p>
                    <p>
                      In addition to these ready-to-use comparison modes and
                      <a
                        href="https://www.gams.com/miro/configuration_json_only.html#custom-compare-mode"
                        target="_blank"
                        >custom compare modules</a
                      >, there is another one,
                      <a
                        href="https://www.gams.com/miro/configuration_json_only.html#dashboard-compare"
                        target="_blank"
                        >dashboard comparison mode</a
                      >, which must be configured specifically for the app
                      before it can be used. We will do this in the following.
                    </p>
                    <p>
                      The configuration of our regular dashboard renderer can
                      be largely adopted, we just need to make some small
                      adjustments:
                    </p>
                    <ol type="1">
                      <li>
                        <p>
                          We just configured the dashboard in the
                          <code class="language-json">dataRendering</code>
                          section of the
                          <span class="code">&lt;model_name&gt;.json</span>
                          file. For scenario comparison, the configuration
                          should be placed in a separate section called
                          <code class="language-json">compareModules</code>.
                        </p>
                      </li>
                      <li>
                        <p>
                          While a regular dashboard configuration applies to a
                          single symbol, a scenario comparison is
                          symbol-unspecific. This means that the scenario
                          comparison has access to all input and output symbol
                          data by default. As a result, you don’t need to
                          manually list each symbol under
                          <code class="language-json">additionalData</code>.
                          This also means that the symbol data to be used for a
                          chart/table must be specified in each view in
                          <code class="language-json">"dataViewsConfig"</code>
                          (<code class="language-json">"data"</code>
                          property). However, if you have followed the
                          tutorial, this was already done for all views.
                        </p>
                      </li>
                      <li>
                        <p>
                          Instead of the
                          <code class="language-json">"outType"</code> in the
                          dashboard configuration, here we have a
                          <code class="language-json">"type": "dashboard"</code
                          >.
                        </p>
                      </li>
                      <li>
                        <p>
                          We also need to assign a
                          <code class="language-json">label</code> that will be
                          displayed when the scenario comparison mode is
                          selected. This label appears next to the options
                          <em>Split view</em>, <em>Tab view</em> and
                          <em>Pivot view</em>.
                        </p>
                      </li>
                    </ol>
                    <pre><code class="language-diff">{
  &quot;dataRendering&quot;: {
    &quot;&lt;lowercase_symbolname&gt;&quot;: {
-       &quot;outType&quot;: &quot;dashboard&quot;,
-       &quot;additionalData&quot;: [],
      &quot;options&quot;: {
        &quot;valueBoxesTitle&quot;: &quot;&quot;,
        &quot;valueBoxes&quot;: {
            ...
        },
        &quot;dataViews&quot;: {
            ...
        },
        &quot;dataViewsConfig&quot;: {
            ...
        }
      }
    }
  },
  &quot;compareModules&quot;: [
    {
+     &quot;type&quot;: &quot;dashboard&quot;,
+     &quot;label&quot;: &quot;&quot;,
      &quot;options&quot;: {
        &quot;valueBoxesTitle&quot;: &quot;&quot;,
        &quot;valueBoxes&quot;: {
            ...
        },
        &quot;dataViews&quot;: {
            ...
        },
        &quot;dataViewsConfig&quot;: {
            ...
        }
      }
    }
  ]
}</code></pre>
                    <p>
                      While we can copy
                      <code class="language-json">"valueBoxes"</code> and
                      <code class="language-json">"dataViews"</code> directly,
                      we need to take a closer look at
                      <code class="language-json">"dataViewsConfig"</code>! As
                      mentioned above, we need to specify what
                      <code class="language-json">"data"</code> the view is
                      based on. Also, your data displayed in tables and graphs
                      now has an additional dimension, the scenario dimension,
                      where the scenarios to be compared are identified by
                      name. This additional
                      <code class="language-json">"_scenName"</code> dimension
                      must be added in the views under
                      <code class="language-json">"dataViewsConfig"</code>. If
                      you put that dimension into the
                      <code class="language-json">"cols"</code> section and do
                      not want to pre-select a scenario (but show all selected
                      scenarios instead), leave the value at
                      <code class="language-json">null</code>.
                    </p>
                    <pre><code class="language-json">&quot;dataViewsConfig&quot;: {
  &quot;SomeView&quot; : {
    ...
    &quot;cols&quot;: {
      &quot;_scenName&quot;: null
    },
    ...
  }
}</code></pre>
                    <p>
                      The additional scenario dimension also changes the
                      appearance of the graphs. Some visualizations that were
                      suitable for normal output may no longer be suitable for
                      displaying multiple scenarios. In such cases, the view
                      configuration (distribution of dimensions in
                      rows/cols/aggregation, etc.) can be adjusted as needed.
                      The <em>Pivot view</em> comparison mode can help prepare
                      the views, just as we prepared the views for the
                      dashboard. In the dashboard, we used stacked bar charts.
                      If you start <em>Compare scenarios</em> in the
                      <em>Pivot view</em> for the
                      <code class="language-python">"report_output"</code>
                      symbol, it will look like this:
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/scenario_pivot_compare.png"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                    <p>
                      As you can see, the values for both scenarios are stacked
                      on top of each other, so it's no longer easy to see if
                      the load is fulfilled. Comparing the scenarios becomes
                      difficult. To fix this, click the
                      <img
                        src="https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/svgs/solid/square-plus.svg"
                        width="15"
                        height="15"
                      />
                      icon to add a new view (or the <em>edit</em> button to
                      edit an existing one). In the view settings dialog that
                      opens, find "Group stacks by dimension" and add the
                      scenario dimension. This will group the stacked bars by
                      scenario.
                    </p>
                    <p>
                      We can also adjust the coloring so that the value for,
                      e.g.,
                      <code class="language-python">"generators"</code>, is the
                      same across all scenarios. The "Series Styling" tab in
                      the view menu allows to assign custom colors to
                      individual series. So you could assign the same color to
                      each series containing
                      <code class="language-python">"generators"</code>. Keep
                      in mind that this approach is not generic as the scenario
                      name is part of the dimensions. A generic,
                      scenario-independent approach is to define a color
                      pattern for all series that contain
                      <code class="language-python">"generators"</code>. This
                      can be done in the JSON file itself (read more about this
                      <a
                        href="https://www.gams.com/miro/charts.html#series-patterns"
                        target="_blank"
                        >here</a
                      >).
                    </p>
                    <p>
                      The <code class="language-json">"Balance"</code> view
                      could look like this:
                    </p>
                    <pre><code class="language-json">"Balance": {
  "aggregationFunction": "sum",
  "chartOptions": {
    "customChartColors": {
      "battery": [
        "#a6cee3",
        "#558FA8"
      ],
      "external_grid": [
        "#b2df8a",
        "#699C26"
      ],
      "generators": [
        "#fb9a99",
        "#D64A47"
      ],
      "load_demand": [
        "#fdbf6f",
        "#B77E06"
      ]
    },
    "groupDimension": "_scenName",
    "multiChartOptions": {
      "multiChartRenderer": "line",
      "multiChartStepPlot": false,
      "showMultiChartDataMarkers": false,
      "stackMultiChartSeries": "no"
    },
    "multiChartSeries": "load_demand",
    "showXGrid": true,
    "showYGrid": true,
    "singleStack": false,
    "yLogScale": false,
    "yTitle": "power"
  },
  "cols": {
    "_scenName": null,
    "power_output_header": null
  },
  "data": "report_output",
  "domainFilter": {
    "default": null
  },
  "pivotRenderer": "stackedbar",
  "rows": "j",
  "tableSummarySettings": {
    "colSummaryFunction": "sum",
    "enabled": false,
    "rowSummaryFunction": "sum"
  },
  "userFilter": "_scenName"
}</code></pre>
                    <p>
                      The scenario comparison dashboard is ready! It now
                      displays the data of all selected scenarios in the
                      dashboard we are familiar with. The value boxes are empty
                      by default. You can use a drop down menu above them to
                      select a scenario from which the corresponding values are
                      displayed. Now you can see directly how the costs of the
                      BESS affect the use of the generators etc.
                    </p>
                    <div class="section-block">
                      <img
                        class="img-fluid"
                        style="max-width: 100%"
                        src="assets/images/step_by_step_tutorial/dashboard_compare.gif"
                        alt="Result of pivot tool for Balance"
                      />
                    </div>
                  </div>
                  <!--//section-block-->
                  <div id="key-takeaways-4" class="section-block">
                    <h3 class="block-title">Key Takeaways</h3>
                    <ul>
                      <li>
                        <strong>Comprehensive Overview</strong>: Although
                        configuring the dashboard requires some effort, it
                        provides a unified view of all scenarios.
                      </li>
                      <li>
                        <strong>Easy Comparison</strong>: Quickly compare
                        multiple scenarios within a single dashboard for better
                        insights.
                      </li>
                    </ul>
                    <p>
                      After exploring all the out-of-the-box customizations for
                      our application, the next step is to dive into the custom
                      code extensions that MIRO offers. This will be the focus
                      of our third and final part, where we will demonstrate
                      how to write custom renderers, widgets, and
                      importer/exporter functions in R. Don’t worry if you’ve
                      never worked with R before-we’ll introduce you to all the
                      necessary R functions.
                    </p>
                  </div>
                </section>
                <!--//section-block-->
                <section id="fine-tuning-with-custom-code" class="doc-section">
                  <h2 class="section-title">Fine Tuning with Custom Code</h2>
                  <div class="section-block">
                    <p>
                      In the first part of this tutorial we went from a GAMSPy
                      model to a first basic GAMS MIRO application for this
                      <a
                        href="https://miro.gams.com/gallery/app_direct/bess/"
                        target="_blank"
                        >gallery</a
                      >
                      example. In the second part we got familiar with the
                      Configuration Mode. Nevertheless, sometimes we want to
                      customize our MIRO application even more. MIRO supports
                      this via custom code, specifically in R, which allows us
                      to go beyond the standard visualizations.
                    </p>
                    <!--//section-block-->
                    <div id="custom-renderer" class="section-block">
                      <h3 class="block-title">Custom Renderer</h3>
                      <p>
                        We will start by creating a simple renderer that shows
                        the BESS storage level at each hour. Up to this point,
                        we only see how much power is charged or discharged
                        (<code class="language-r">battery_power</code>). The
                        storage level itself can be computed by taking the
                        cumulative sum of
                        <code class="language-r">battery_power</code>. In R,
                        this is easily done with
                        <a
                          href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cumsum"
                          target="_blank"
                          ><code class="language-r">cumsum()</code></a
                        >.
                      </p>
                      <p>
                        Note that if your data transformation is a simple
                        function (e.g., a single cumulative sum), you could
                        (and should!) do it directly in Python by creating a
                        new output parameter, eliminating the need for a custom
                        renderer, and directly use the pivot tool again for
                        visualization. Here we use this example mainly to
                        introduce custom renderers in MIRO.
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="renderer-structure" class="section-block">
                      <h4 class="block-title">Renderer Structure</h4>
                      <p>
                        First, we need to understand what the general structure
                        of a custom renderer is in MIRO. For this we will
                        closely follow the
                        <a
                          href="https://www.gams.com/miro/configuration_advanced.html#custom-renderers"
                          target="_blank"
                          >documentation</a
                        >. MIRO leverages R Shiny under the hood, which follows
                        a two-function approach: 1. Placeholder function
                        (server output): Where we specify the UI elements
                        (plots, tables, etc.) and where they will be rendered.
                        2. Rendering function: Where we do the data
                        manipulation, define the reactive logic, and produce
                        the final display.
                      </p>
                      <p>
                        For more background on Shiny, see
                        <a href="https://shiny.posit.co/" target="_blank"
                          >R Shiny’s official website</a
                        >.
                      </p>
                      <p>
                        A typical MIRO custom renderer follows this template
                        (using <code class="language-r">battery_power</code> as
                        an example):
                      </p>
                      <pre><code class="language-R"># Placeholder function must end with &quot;Output&quot;
mirorenderer_&lt;lowercaseSymbolName&gt;Output &lt;- function(id, height = NULL, options = NULL, path = NULL){
  ns &lt;- NS(id)
}

# The actual rendering must be prefixed with the keyword &quot;render&quot;
renderMirorenderer_&lt;lowercaseSymbolName&gt; &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...){

}</code></pre>
                      <p>
                        If you are not using the Configuration Mode, you must
                        save these functions in a file named
                        <span class="code"
                          >mirorenderer_&lt;lowercaseSymbolName&gt;.R</span
                        >
                        inside the
                        <span class="code">renderer_&lt;model_name&gt;</span>
                        directory. However, if you are using the Configuration
                        Mode, you can add the custom renderer directly under
                        the
                        <em>Graphs</em> by setting its
                        <em>charting type</em> to <em>Custom renderer</em>. The
                        Configuration Mode will automatically create the folder
                        structure and place your R code in the correct location
                        when you save.
                      </p>
                      <div class="section-block">
                        <img
                          class="img-fluid"
                          style="max-width: 100%"
                          src="assets/images/step_by_step_tutorial/empty_config_mode.png"
                          alt="Result of pivot tool for Balance"
                        />
                      </div>
                    </div>
                    <!--//section-block-->
                    <div id="placeholder-function" class="section-block">
                      <h4 class="block-title">Placeholder Function</h4>
                      <p>
                        The placeholder function creates the UI elements Shiny
                        will render. Shiny requires each element to have a
                        unique ID, managed via the
                        <a
                          href="https://shiny.posit.co/r/reference/shiny/0.13.1/ns"
                          target="_blank"
                          ><code class="language-r">NS()</code></a
                        >
                        function, which appends a prefix to avoid naming
                        conflicts.
                      </p>
                      <p>Here’s how it works in practice:</p>
                      <ul>
                        <li>
                          Define the prefix function: First, call
                          <code class="language-r">NS()</code> with the
                          renderer’s ID to create a function that we will store
                          in a variable <code class="language-r">ns</code>.
                        </li>
                        <li>
                          Use the prefix function on elements: Whenever you
                          define a new input or output element, prefix its ID
                          with <code class="language-r">ns()</code>. This will
                          give each element a unique prefixed ID.
                        </li>
                      </ul>
                      <p>
                        In our first example, we only want to draw a single
                        plot of the BESS storage level. Hence, we define one UI
                        element:
                      </p>
                      <pre><code class="language-R"># Placeholder function
mirorenderer_battery_powerOutput &lt;- function(id, height = NULL, options = NULL, path = NULL) {
    ns &lt;- NS(id)
    plotOutput(ns(&quot;cumsumPlot&quot;))
}</code></pre>
                      <p>
                        Note that instead of writing
                        <code class="language-r"
                          >plotOutput("cumsumPlot", ...)</code
                        >, we use
                        <code class="language-r"
                          >plotOutput(ns("cumsumPlot"), ...)</code
                        >
                        to ensure that the
                        <code class="language-r">cumsumPlot</code> is uniquely
                        identified throughout the application.
                      </p>
                      <p>
                        We only have one plot here, but you can create as many
                        UI elements as you need. To get a better overview what
                        is possible check the R Shiny documentation, e.g. their
                        section on
                        <a
                          href="https://shiny.posit.co/r/layouts/arrange/"
                          target="_blank"
                          >Arrange Elements</a
                        >.
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="rendering-function" class="section-block">
                      <h4 class="block-title">Rendering Function</h4>
                      <p>
                        Next, we implement the actual renderer, which handles
                        data manipulation and visualization. We have defined an
                        output with the output function
                        <a
                          href="https://shiny.posit.co/r/reference/shiny/latest/plotoutput"
                          target="_blank"
                          ><code class="language-r">plotOutput()</code></a
                        >. Now we need something to render inside. For this, we
                        assign
                        <a
                          href="https://shiny.posit.co/r/reference/shiny/latest/renderplot"
                          target="_blank"
                          ><code class="language-r">renderPlot()</code></a
                        >
                        to an output object inside the rendering function,
                        which is responsible for generating the plot. Here’s an
                        overview:
                      </p>
                      <ul>
                        <li>
                          Output functions: These functions determine how the
                          data is displayed, such as
                          <code class="language-r">plotOutput()</code>.
                        </li>
                        <li>
                          Rendering functions: These are functions in Shiny
                          that transform your data into visual elements, such
                          as plots, tables, or maps. For example,
                          <code class="language-r">renderPlot()</code> is a
                          reactive plot suitable for assignment to an output
                          slot.
                        </li>
                      </ul>
                      <p>
                        Now we need a connection between our placeholder and
                        the renderer. To do this, we look at the arguments the
                        rendering function gets
                      </p>
                      <ul>
                        <li>
                          <code class="language-r">input</code>: Access to
                          Shiny inputs, i.e. elements that generate data, such
                          as sliders, text input,… (<code class="language-r"
                            >input$hour</code
                          >).
                        </li>
                        <li>
                          <code class="language-r">output</code>: Controls
                          elements that visualize data, such as plots, maps, or
                          tables (<code class="language-r"
                            >output$cumsumPlot</code
                          >).
                        </li>
                        <li>
                          <code class="language-r">session</code>: Contains
                          user-specific information.
                        </li>
                        <li>
                          <code class="language-r">data</code>: The data for
                          the visualization is specified as an R
                          <a
                            href="https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html"
                            target="_blank"
                            >tibble</a
                          >. If you’ve specified multiple datasets in your MIRO
                          application, the data will be a named list of
                          tibbles. Each element in this list corresponds to a
                          GAMS symbol (<code class="language-r"
                            >data$battery_power</code
                          >).
                        </li>
                      </ul>
                      <p>
                        For more information about the other options, see the
                        <a
                          href="https://www.gams.com/miro/configuration_advanced.html#custom-renderers"
                          target="_blank"
                          >documentation</a
                        >.
                      </p>
                      <p>
                        We will now return to the Configuration Mode and start
                        building our first renderer. Hopefully you have already
                        added
                        <code class="language-r"
                          >plotOutput(ns("cumsumPlot"))</code
                        >
                        to the placeholder function. To get a general idea of
                        what we are working with, let us first take a look at
                        the
                        <code class="language-r">data</code> by simply printing
                        it (<code class="language-r">print(data)</code>) inside
                        the renderer. If we now press <em>Update</em>, we still
                        won’t see anything, because no rendering has been done
                        yet, but if we look at the console, we will see:
                      </p>
                      <pre><code class="language-plaintext"># A tibble: 24 x 6
    j      level marginal lower upper scale
    &lt;chr&gt;  &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 hour00   -50        0  -Inf   Inf     1
2 hour01   -80        0  -Inf   Inf     1
3 hour02   -90        0  -Inf   Inf     1
4 hour03  -100        0  -Inf   Inf     1
5 hour04   -30        0  -Inf   Inf     1
6 hour05   -10        0  -Inf   Inf     1
7 hour06    10        0  -Inf   Inf     1
8 hour07    40        0  -Inf   Inf     1
9 hour08   -40        0  -Inf   Inf     1
10 hour09     0        0  -Inf   Inf     1
# i 14 more rows</code></pre>
                      <p>
                        Since we have not specified any additional data sets so
                        far, <code class="language-r">data</code> directly
                        contains the variable
                        <code class="language-r">battery_power</code>, which is
                        the GAMS symbol we put in the mirorender name. For our
                        plot of the storage levels we now need the values from
                        the <code class="language-r">level</code> column, which
                        we can access in R with
                        <code class="language-r">data$level</code>. More on
                        subsetting tibbles can be found
                        <a
                          href="https://tibble.tidyverse.org/reference/subsetting.html"
                          target="_blank"
                          >here</a
                        >.
                      </p>
                      <p>
                        Let’s now finally make our first plot! First we need to
                        calculate the data we want to plot, which we store in
                        <code class="language-r">storage_level</code>. The
                        values in
                        <code class="language-r">battery_power</code> are from
                        the city’s perspective; negative means charging the
                        BESS, positive means discharging. We negate the
                        cumulative sum to get the actual storage level. We use
                        the standard R
                        <a
                          href="https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/barplot"
                          target="_blank"
                          ><code class="language-r">barplot()</code></a
                        >
                        for visualization, but any plotting library can be
                        used. Finally, we just need to pass this reactive plot
                        to a render function and assign it to the appropriate
                        output variable. The code should look like this:
                      </p>
                      <pre><code class="language-R">storage_level &lt;- -cumsum(data$level)
output$cumsumPlot &lt;- renderPlot({
    barplot(storage_level)
})</code></pre>
                      <p>
                        If you press <em>Update</em> again, you should get
                        this:
                      </p>
                      <div class="section-block">
                        <img
                          class="img-fluid"
                          style="max-width: 100%"
                          src="assets/images/step_by_step_tutorial/cumsum_first_draft.png"
                          alt="Result of pivot tool for Balance"
                        />
                      </div>
                      <p>
                        Now let’s make this graph prettier. Aside from adding a
                        title, labels, etc., take a look at the y-axis. As you
                        can see, it doesn’t go all the way to the top. To
                        change this, we can set it to the maximum value of our
                        data. But what might be more interesting is to see the
                        current storage value compared to the maximum possible.
                        As you may remember, this maximum storage level is also
                        part of our optimization. So now we need to add data
                        from other model symbols to our renderer. First go to
                        <em>Advanced options</em> and then by clicking on
                        <em
                          >Additional datasets to communicate with the custom
                          renderer</em
                        >
                        we will see all the symbols we can add to the renderer.
                        Since we need the data from the scalar variable
                        <code class="language-r">battery_storage</code>, we add
                        <code class="language-r">"_scalarsve_out"</code>. Going
                        back to the <em>Main</em> tab, we now need to change
                        how we access the data, since
                        <code class="language-r">data</code> is no longer a
                        single tibble, but a named list of tibbles. In the
                        example below we use
                        <a
                          href="https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter"
                          target="_blank"
                          ><code class="language-r">filter()</code></a
                        >
                        and
                        <a
                          href="https://www.rdocumentation.org/packages/lplyr/versions/0.1.6/topics/pull"
                          target="_blank"
                          ><code class="language-r">pull()</code></a
                        >
                        to extract the desired data. Note that
                        <code class="language-r">%&gt;%</code> is the pipe
                        operator, which is used to pass the result of an
                        expression or function as the input to the next
                        function in a sequence, improving the readability and
                        flow of your code.
                      </p>
                      <pre><code class="language-R">max_storage &lt;- data[[&quot;_scalarsve_out&quot;]] %&gt;%
  filter(scalar == &quot;battery_storage&quot;) %&gt;%
  pull(level)</code></pre>
                      <p>
                        We will use the
                        <code class="language-r">"battery_storage"</code> for
                        adding a horizontal line with
                        <a
                          href="https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/abline"
                          target="_blank"
                          ><code class="language-r">abline()</code></a
                        >. Adding some more layout settings leads us to:
                      </p>
                      <div class="section-block">
                        <img
                          class="img-fluid"
                          style="max-width: 100%"
                          src="assets/images/step_by_step_tutorial/cumsum_final_conifg_mode.png"
                          alt="Result of pivot tool for Balance"
                        />
                      </div>
                      <details>
                        <summary>
                          Click to see the full code of the renderer
                        </summary>
                        <pre><code class="language-R">mirorenderer_battery_powerOutput &lt;- function(id, height = NULL, options = NULL, path = NULL) {
    ns &lt;- NS(id)
    plotOutput(ns(&quot;cumsumPlot&quot;))
}

renderMirorenderer_battery_power &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {
    battery_power &lt;- data$battery_power$level
    storage_level &lt;- -cumsum(battery_power)

    max_storage &lt;- data[[&quot;_scalarsve_out&quot;]] %&gt;%
        filter(scalar == &quot;battery_storage&quot;) %&gt;%
        pull(level)

    output$cumsumPlot &lt;- renderPlot({
        barplot(storage_level,
            col = &quot;lightblue&quot;, ylab = &quot;Energy Capacity in kWh&quot;,
            names.arg = data$battery_power$j, las = 2,
            main = &quot;Storage level of the BESS&quot;
        )
        grid()
        abline(h = max_storage, col = &quot;red&quot;, lwd = 2, lty = 2)
    })
}</code></pre>
                      </details>
                      <p>
                        By clicking <em>Save</em>, the Configuration Mode
                        generates the file structure and JSON configuration
                        automatically. Again, if you are not using the
                        Configuration Mode, you will need to add this manually.
                        The template can be found in the
                        <a
                          href="https://www.gams.com/miro/configuration_advanced.html#custom-renderers"
                          target="_blank"
                          >documentation</a
                        >.
                      </p>
                      <p>Congratulations you created your first renderer!</p>
                      <p>
                        Now that we have created our first small custom
                        renderer, we can start working on some more complex
                        renderers.
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="a-more-complex-renderer" class="section-block">
                      <h4 class="block-title">A more complex renderer</h4>
                      <p>
                        We are going to make a simple Sankey diagram for our
                        power flow. We will base this renderer on our
                        <code class="language-r">report_output</code> variable
                        which contains the three power variables and the load
                        demand. It will show the current power flow at a given
                        hour. To change the hour we will add a slider. This
                        results in the following placeholder function:
                      </p>
                      <pre><code class="language-R">mirorenderer_report_outputOutput &lt;- function(id, height = NULL, options = NULL, path = NULL) {
  ns &lt;- NS(id)
  tagList(
    sliderInput(ns(&quot;hour&quot;), &quot;Hour:&quot;,
      min = 0, max = 23,
      value = 0, step = 1,
    ),
    plotly::plotlyOutput(ns(&quot;sankey&quot;), height = &quot;100%&quot;)
  )
}</code></pre>
                      <p>
                        Since we just want both elements on top of each other,
                        we use a
                        <a
                          href="https://www.rdocumentation.org/packages/shiny/versions/0.9.1/topics/tagList"
                          target="_blank"
                          ><code class="language-r">tagList()</code></a
                        >. First we have our slider, which we give an id, again
                        using the <code class="language-r">ns()</code> function
                        to prefix it. We set
                        <code class="language-r">min</code>,
                        <code class="language-r">max</code>, initial
                        <code class="language-r">value</code> and
                        <code class="language-r">step</code>size. Second, we
                        have a plot for which we use
                        <a
                          href="https://www.rdocumentation.org/packages/plotly/versions/4.10.4/topics/plotly-shiny"
                          target="_blank"
                          ><code class="language-r">plotlyOutput()</code></a
                        >, since we will be using the <em>plotly</em> library
                        to generate the Sankey plot. Because plotly is not part
                        of MIRO’s core, we must add the package to our
                        environment. This can be done in the same way as the
                        additional data in the <em>Advanced options</em> menu.
                        This also means that we need to specify the package
                        name explicitly using the
                        <em>double colon operator</em>. Again, if you are not
                        using the Configuration Mode, follow the
                        <a
                          href="https://www.gams.com/miro/configuration_advanced.html#additional-r-packages"
                          target="_blank"
                          >documentation</a
                        >.
                      </p>
                      <p>
                        Now that we have some placeholders, we need to fill
                        them. Let us begin to set up our Sankey diagram. First,
                        we need to decide which nodes we need. We will add one
                        for the BESS, the generators, the external grid, and
                        the city. You need to remember the order so that you
                        can assign the links correctly later.
                      </p>
                      <pre><code class="language-R">node = list(
  label = c(&quot;BESS&quot;, &quot;Generators&quot;, &quot;External Grid&quot;, &quot;City&quot;),
  color = c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;, &quot;black&quot;),
  pad = 15,
  thickness = 20,
  line = list(
    color = &quot;black&quot;,
    width = 0.5
  )
)</code></pre>
                      <p>
                        With the nodes defined we need to set the links. Each
                        link has a source, a target and a value. The possible
                        sources and targets are defined by our given nodes. We
                        will define lists for all three and fill them based on
                        our data.
                      </p>
                      <pre><code  class="language-r">link = list(
    source = sankey_source,
    target = sankey_target,
    value =  sankey_value
)</code></pre>
                      <p>
                        To be able to display the power value of the correct
                        time point we need to get the hour from our slider,
                        which we get from our
                        <code class="language-r">input</code> parameter.
                      </p>
                      <pre><code class="language-R">hour_to_display &lt;- sprintf(&quot;hour%02d&quot;, input$hour)</code></pre>
                      <p>
                        Note that we use
                        <a
                          href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/sprintf"
                          target="_blank"
                          ><code class="language-r">sprintf()</code></a
                        >
                        to get the same string we use to represent the hour in
                        our GAMS symbols, so that we can filter the data for
                        the correct hour.
                      </p>
                      <p>
                        Here we need to be careful:
                        <code class="language-r">input</code> is a reactive
                        variable, it automatically updates the diagram when the
                        slider is updated. This means we need to put it in a
                        reactive context. For example, in R you can use
                        <a
                          href="https://www.rdocumentation.org/packages/shiny/versions/1.9.1/topics/observe"
                          target="_blank"
                          ><code class="language-r">observe()</code></a
                        >. However, since our rendering depends on only one
                        input and only one output, we keep it simple and place
                        all our calculations inside
                        <code class="language-r">renderPlotly()</code>. We can
                        do this because rendering functions are also observers.
                        If you want to learn more about R Shiny’s reactive
                        expressions, you can find a more detailed tutorial
                        <a
                          href="https://shiny.posit.co/r/getstarted/shiny-basics/lesson6/"
                          target="_blank"
                          >here</a
                        >.
                      </p>
                      <p>
                        With that figured out, we need to extract the correct
                        power values. First we need to select the correct power
                        type, then the current hour and add it to the links if
                        it is not zero. Because GAMS doesn’t store zeros, we
                        need to check if a row exists for each hour-power
                        combination. Here you see how to do it for the
                        <code class="language-r">battery_power</code>:
                      </p>
                      <pre><code class="language-R">battery_to_display &lt;- filter(data, power_output_header == &quot;battery&quot;) %&gt;%
  filter(j == hour_to_display)</code></pre>
                      <details>
                        <summary>
                          Click to see the other two power sources
                        </summary>
                        <pre><code class="language-R">gen_to_display &lt;- filter(data, power_output_header == &quot;generators&quot;) %&gt;%
  filter(j == hour_to_display)
extern_to_display &lt;- filter(data, power_output_header == &quot;external_grid&quot;) %&gt;%
  filter(j == hour_to_display)</code></pre>
                      </details>
                      <p>
                        Now that we have our values, we need to add them to our
                        link list. But remember to make sure that the value
                        exists (here using
                        <a
                          href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/dim"
                          target="_blank"
                          ><code class="language-r">dim()</code></a
                        >), and for the BESS we need to keep in mind that we
                        can have positive and negative power flows, either from
                        the city to the BESS or the other way around! Here is a
                        way to add the BESS links:
                      </p>
                      <pre><code class="language-R"># go over each source and check if they exist and if so add the corresponding link
if (dim(battery_to_display)[1] != 0) {
  # for the battery need to check if is charged, or discharged
  if (battery_to_display[[&quot;value&quot;]] &gt; 0) {
    sankey_source &lt;- c(sankey_source, 0)
    sankey_target &lt;- c(sankey_target, 3)
    sankey_value &lt;- c(sankey_value, battery_to_display[[&quot;value&quot;]])
  } else {
    sankey_source &lt;- c(sankey_source, 3)
    sankey_target &lt;- c(sankey_target, 0)
    sankey_value &lt;- c(sankey_value, -battery_to_display[[&quot;value&quot;]])
  }
}</code></pre>
                      <p>
                        Add similar code snippets for the remaining two power
                        sources.
                      </p>
                      <details>
                        <summary>
                          Click to see the other two power sources
                        </summary>
                        <pre><code class="language-R">if (dim(gen_to_display)[1] != 0) {
  sankey_source &lt;- c(sankey_source, 1)
  sankey_target &lt;- c(sankey_target, 3)
  sankey_value &lt;- c(sankey_value, gen_to_display[[&quot;value&quot;]])
}

if (dim(extern_to_display)[1] != 0) {
  sankey_source &lt;- c(sankey_source, 2)
  sankey_target &lt;- c(sankey_target, 3)
  sankey_value &lt;- c(sankey_value, extern_to_display[[&quot;value&quot;]])
}</code></pre>
                      </details>
                      <p>
                        With this, we have all the necessary components to
                        render the Sankey diagram. We add one more small
                        feature. Sliders can be animated quite easily in R
                        Shiny. All you need to do is add an animate option to
                        the
                        <code class="language-r">sliderInput()</code> function:
                      </p>
                      <pre><code class="language-R">animate = animationOptions(
  interval = 1000, loop = FALSE,
  playButton = actionButton(&quot;play&quot;, &quot;Play&quot;, icon = icon(&quot;play&quot;), style = &quot;margin-top: 10px;&quot;),
  pauseButton = actionButton(&quot;pause&quot;, &quot;Pause&quot;, icon = icon(&quot;pause&quot;), style = &quot;margin-top: 10px;&quot;)
)</code></pre>
                      <p>
                        Now we can inspect the hourly power flow between
                        generators, the external grid, BESS, and the city. The
                        slider animates this flow over time.
                      </p>
                      <details>
                        <summary>
                          Click to see the code of the full renderer
                        </summary>
                        <pre><code class="language-R">mirorenderer_report_outputOutput &lt;- function(id, height = NULL, options = NULL, path = NULL) {
  ns &lt;- NS(id)
  tagList(
    sliderInput(ns(&quot;hour&quot;), &quot;Hour:&quot;,
      min = 0, max = 23,
      value = 0, step = 1,
      animate = animationOptions(
        interval = 1000, loop = FALSE,
        playButton = actionButton(&quot;play&quot;, &quot;Play&quot;, icon = icon(&quot;play&quot;), style = &quot;margin-top: 10px;&quot;),
        pauseButton = actionButton(&quot;pause&quot;, &quot;Pause&quot;, icon = icon(&quot;pause&quot;), style = &quot;margin-top: 10px;&quot;)
      )
    ),
    # since plotly is a custom package, it is not attached by MIRO to avoid name collisions
    # Thus, we have to prefix functions exported by plotly via the &quot;double colon operator&quot;:
    # plotly::renderPlotly
    plotly::plotlyOutput(ns(&quot;sankey&quot;), height = &quot;100%&quot;)
  )
}

renderMirorenderer_report_output &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {
  # since renderPlotly (or any other render function) is also an observer we are already in an reactive context
  output$sankey &lt;- plotly::renderPlotly({
    hour_to_display &lt;- sprintf(&quot;hour%02d&quot;, input$hour)

    # start with empty lists for the sankey links
    sankey_source &lt;- list()
    sankey_target &lt;- list()
    sankey_value &lt;- list()

    # since the GAMS output is melted, first need to extract the different power sources
    battery_to_display &lt;- filter(data, power_output_header == &quot;battery&quot;) %&gt;%
      filter(j == hour_to_display)
    gen_to_display &lt;- filter(data, power_output_header == &quot;generators&quot;) %&gt;%
      filter(j == hour_to_display)
    extern_to_display &lt;- filter(data, power_output_header == &quot;external_grid&quot;) %&gt;%
      filter(j == hour_to_display)

    # go over each source and check if they exist and if so add the corresponding link
    if (dim(battery_to_display)[1] != 0) {
      # for the battery need to check if is charged, or discharged
      if (battery_to_display[[&quot;value&quot;]] &gt; 0) {
        sankey_source &lt;- c(sankey_source, 0)
        sankey_target &lt;- c(sankey_target, 3)
        sankey_value &lt;- c(sankey_value, battery_to_display[[&quot;value&quot;]])
      } else {
        sankey_source &lt;- c(sankey_source, 3)
        sankey_target &lt;- c(sankey_target, 0)
        sankey_value &lt;- c(sankey_value, -battery_to_display[[&quot;value&quot;]])
      }
    }

    if (dim(gen_to_display)[1] != 0) {
      sankey_source &lt;- c(sankey_source, 1)
      sankey_target &lt;- c(sankey_target, 3)
      sankey_value &lt;- c(sankey_value, gen_to_display[[&quot;value&quot;]])
    }

    if (dim(extern_to_display)[1] != 0) {
      sankey_source &lt;- c(sankey_source, 2)
      sankey_target &lt;- c(sankey_target, 3)
      sankey_value &lt;- c(sankey_value, extern_to_display[[&quot;value&quot;]])
    }

    # finally generate the sankey diagram using plotly
    plotly::plot_ly(
      type = &quot;sankey&quot;,
      orientation = &quot;h&quot;,
      node = list(
        label = c(&quot;BESS&quot;, &quot;Generators&quot;, &quot;External Grid&quot;, &quot;City&quot;),
        color = c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;, &quot;black&quot;),
        pad = 15,
        thickness = 20,
        line = list(
          color = &quot;black&quot;,
          width = 0.5
        )
      ),
      link = list(
        source = sankey_source,
        target = sankey_target,
        value =  sankey_value
      )
    )
  })
}</code></pre>
                      </details>
                      <div class="section-block">
                        <img
                          class="img-fluid"
                          style="max-width: 100%"
                          src="assets/images/step_by_step_tutorial/sankey_animation.gif"
                          alt="Result of pivot tool for Balance"
                        />
                      </div>
                      <p>
                        Hopefully you now have a better idea of what is
                        possible with custom renderers and how to easily use
                        the Configuration Mode to implement them.
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="custom-dashboard" class="section-block">
                      <h3 class="block-title">Custom Dashboard</h3>
                      <p>
                        Now that we know so much more about custom renderers,
                        let us embed custom code in our
                        <a href="#dashboard-renderer">dashboard</a>. We will
                        add the simple renderer for the storage level of the
                        BESS. We follow the
                        <a
                          href="https://www.gams.com/miro/charts.html#dashboard-custom-code"
                          target="_blank"
                          >documentation</a
                        >
                        closely for this. To add custom code to the renderer,
                        we no longer just use json, but we use the dashboard as
                        a custom renderer. The dashboard renderer has been
                        prepared to do this with minimal effort.
                      </p>
                      <ol type="1">
                        <li>
                          <p>
                            Download the
                            <a
                              href="https://github.com/GAMS-dev/miro/blob/master/src/modules/renderers/dashboard.R"
                              target="_blank"
                              >latest dashboard renderer file</a
                            >
                            from the GAMS MIRO repository on GitHub and put it
                            with the other renderers in your
                            <span class="code"
                              >renderer_&lt;model_name&gt;</span
                            >
                            directory.
                          </p>
                        </li>
                        <li>
                          <p>
                            In the <span class="code">dashboard.R</span> file,
                            make the following changes:
                          </p>
                        </li>
                      </ol>
                      <pre><code class="language-diff">- dashboardOutput &lt;- function(id, height = NULL, options = NULL, path = NULL) {
+ mirorenderer__scalarsve_outOutput &lt;- function(id, height = NULL, options = NULL, path = NULL) {
    ns &lt;- NS(id)
    ...
  }
- renderDashboard &lt;- function(id, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {
+ renderMirorenderer__scalarsve_out &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {
-   moduleServer(
-     id,
-     function(input, output, session) {
        ns &lt;- session$ns
        ...

# These are the last three lines of code in the file
- }
-)
}</code></pre>
                      <p>
                        Remember that the dashboard is rendered for the symbol
                        <code class="language-json">"_scalarsve_out"</code>. As
                        with the other renderers, be sure to replace it with
                        the symbol name you want to render if you create a
                        dashboard for a different symbol.
                      </p>
                      <ol start="3" type="1">
                        <li>
                          In the
                          <code class="language-json">dataRendering</code>
                          section of the
                          <span class="code">&lt;model_name&gt;.json</span>
                          file change the
                          <code class="language-json">"outType"</code> of the
                          symbol to render from
                          <code class="language-json">"dashboard"</code> to
                          <code class="language-json"
                            >"mirorenderer_&lt;symbolname&gt;"</code
                          >
                        </li>
                      </ol>
                      <pre><code class="language-diff">  {
    &quot;dataRendering&quot;: {
      &quot;_scalarsve_out&quot;: {
-      &quot;outType&quot;: &quot;dashboard&quot;,
+      &quot;outType&quot;: &quot;mirorenderer__scalarsve_out&quot;,
        &quot;additionalData&quot;: [...],
        &quot;options&quot;: {...}
      }
    }
  }
</code></pre>
                      <p>
                        Now you can restart the application and have the same
                        renderer as before, only now we can extend it with
                        custom code!
                      </p>
                      <p>
                        To add custom code, we first need to decide where to
                        put it. Here we will add it as a second element to the
                        <code class="language-json">battery_power</code> view.
                        Note that the given title will be ignored by the custom
                        code, so we will leave it empty.
                      </p>
                      <pre><code class="language-json">&quot;dataViews&quot;: {
  &quot;battery_power&quot;: [
    {&quot;BatteryTimeline&quot;: &quot;Charge/Discharge of the BESS&quot;},
    {&quot;BatteryStorage&quot;: &quot;&quot;}
  ],
  ...
}</code></pre>
                      <p>
                        In the corresponding
                        <code class="language-json">"dataViewsConfig"</code>
                        section we now assign an arbitrary string, e.g. <code
                          class="language-json"
                          >"BatteryStorage": "customCode"</code
                        >, instead of a view configuration as before:
                      </p>
                      <pre><code class="language-R">&quot;dataViewsConfig&quot;: {
  &quot;BatteryStorage&quot;: &quot;customCode&quot;,
  ...
}</code></pre>
                      <p>
                        Finally, we can add the custom code. Recall that in our
                        custom renderers, we always defined placeholders with
                        unique IDs that were then assembled into the
                        <code class="language-json">output</code> variable. The
                        view ID we just added (<code class="language-json"
                          >"BatteryStorage"</code
                        >) will also be added to the
                        <code class="language-r">output</code> variable. Now we
                        just add our already implemented renderer to the render
                        function (<code class="language-r"
                          >renderMirorenderer__scalarsve_out</code
                        >). The only thing we have to change is the output to
                        which we assign the plot:
                        <code class="language-r"
                          >output[["BatteryStorage"]] &lt;- renderUI(...)</code
                        >. And remember that we are no longer in our renderer
                        for the symbol
                        <code class="language-r">battery_power</code>, so
                        <code class="language-r">battery_power</code> is now
                        additional data that we access with
                        <code class="language-r">data$battery_power</code>.
                        However, since we have already added additional data to
                        the renderer before, the code does not change. Just
                        keep in mind that if the renderer you’re adding didn’t
                        have additional data before, you’ll have to change how
                        you access the data! To keep track, we add the new
                        output assignment at the end of the dashboard renderer,
                        but as long as it’s inside the renderer, the order
                        doesn’t matter.
                      </p>
                      <pre><code class="language-R">renderMirorenderer__scalarsve_out &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {

  ...

  battery_power &lt;- data$battery_power$level
  storage_level &lt;- -cumsum(battery_power)

  max_storage &lt;- data[[&quot;_scalarsve_out&quot;]] %&gt;%
    filter(scalar == &quot;battery_storage&quot;) %&gt;%
    pull(level)

  # corresponding to the dataView &quot;BatteryStorage&quot;
  output[[&quot;BatteryStorage&quot;]] &lt;- renderUI({
    tagList(
      renderPlot({
        barplot(storage_level,
          col = &quot;lightblue&quot;, ylab = &quot;Energy Capacity in kWh&quot;,
          names.arg = data$battery_power$j, las = 2,
          main = &quot;Storage level of the BESS&quot;
        )
        grid()
      })
    )
  })
}</code></pre>
                      <p>
                        In the same way, you can create a view that’s entirely
                        made up of custom code or include as many custom code
                        elements as you like.
                      </p>
                    </div>
                    <!--//section-block-->
                    <div
                      id="dashboard-comparison-with-custom-code"
                      class="section-block"
                    >
                      <h4 class="block-title">
                        Dashboard Comparison with Custom Code
                      </h4>
                      <p>
                        You can also introduce custom renders to the dashboard
                        comparison. Since this is quite similar to what we just
                        did, we won't go over it again here. If you want to
                        include the custom renderer, simply follow the
                        <a
                          href="https://www.gams.com/miro/configuration_json_only.html#custom-dashboard-compare"
                          target="_blank"
                          >documentation</a
                        >. Just note that you cannot directly copy your old
                        custom renderer; you'll need to adapt it to the new
                        data structure, which now includes the scenario
                        dimension!
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="custom-widget" class="section-block">
                      <h3 class="block-title">Custom Widget</h3>
                      <p>
                        Let’s take a closer look at another aspect of MIRO
                        customization—creating a custom widget. Until now, our
                        custom renderers have been for data visualization only.
                        But for input symbols, we can also use custom code that
                        allows you to produce input data that is sent to your
                        model. This means that the input data for your GAMS(Py)
                        model can be generated by interactively modifying a
                        chart, table or other type of renderer.
                      </p>
                      <p>
                        In MIRO, each symbol tab provides both a tabular and a
                        graphical data representation by default. If you have a
                        custom renderer for an input symbol, you would
                        typically switch to the graphical view to see it.
                        However, modifying the actual data to be sent to the
                        model requires using the tabular view. In the following
                        example, we will write a custom input widget that
                        replaces the default tabular view for an input symbol.
                        Since we have complete control over what to display in
                        this custom widget, we can include an editable table
                        for data manipulation as well as a visualization that
                        updates whenever the table data changes—providing a
                        more seamless and interactive way to prepare input for
                        your model.
                      </p>
                      <p>
                        Currently, the Configuration Mode does not offer direct
                        support for implementing custom input widgets, but we
                        can create them the same way we create a custom
                        renderer and then make a few changes to convert it into
                        a widget.
                      </p>
                      <p>
                        First, we develop a placeholder function that displays
                        both a plot and a data table. For the table we will use
                        R Shinys
                        <a
                          href="https://shiny.posit.co/r/articles/build/datatables/"
                          target="_blank"
                          >DataTables</a
                        >. To do this, you must first add
                        <a
                          href="https://www.rdocumentation.org/packages/DT/versions/0.16"
                          target="_blank"
                          ><code class="language-r">DT</code></a
                        >
                        to the additional packages and prefix the corresponding
                        functions in the code. To define the output we use
                        <a
                          href="https://www.rdocumentation.org/packages/DT/versions/0.33/topics/dataTableOutput"
                          target="_blank"
                          ><code class="language-r">DT:DTOutput()</code></a
                        >:
                      </p>
                      <pre><code class="language-R">mirorenderer_timewise_load_demand_and_cost_external_grid_dataOutput &lt;- function(id, height = NULL, options = NULL, path = NULL){
  ns &lt;- NS(id)
  fluidRow(
    column(width = 12, plotOutput(ns(&quot;timeline&quot;))),
    column(width = 12, DT::DTOutput(ns(&quot;table&quot;)))
  )
}</code></pre>
                      <p>
                        Before we make it interactive, let’s fill in our
                        placeholders. For the table, we assign it with
                        <a
                          href="https://www.rdocumentation.org/packages/DT/versions/0.28/topics/dataTableOutput"
                          target="_blank"
                          ><code class="language-r">DT:renderDT()</code></a
                        >, where we define the
                        <a
                          href="https://www.rdocumentation.org/packages/DT/versions/0.16/topics/datatable"
                          target="_blank"
                          ><code class="language-r">DT:datatable()</code></a
                        >
                        and we will round our cost values with
                        <a
                          href="https://search.r-project.org/CRAN/refmans/DT/html/formatCurrency.html"
                          target="_blank"
                          ><code class="language-r">DT:formatRound()</code></a
                        >:
                      </p>
                      <pre><code class="language-R">output$table &lt;- DT::renderDT({
  DT::datatable(data, editable = TRUE, rownames = FALSE, options = list(scrollX = TRUE)) %&gt;%
    DT::formatRound(c(&quot;cost_external_grid&quot;), digits = 2L)
})</code></pre>
                      <p>
                        Here,
                        <code class="language-r">editable = TRUE</code> is
                        crucial—it allows users to modify the table entries.
                        For the plot, we need something like this:
                      </p>
                      <pre><code class="language-R">output$timeline &lt;- renderPlot({
  ...
})</code></pre>
                      <p>
                        We have two variables measured in different units
                        (<code class="language-r">load_demand</code>
                        in W and
                        <code class="language-r">cost_external_grid</code> in
                        $), and we want to display them on the same plot. Take
                        a look at the remaining code to see how it might be
                        structured. One approach is to use
                        <a
                          href="https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/par"
                          target="_blank"
                          ><code class="language-r">par()</code></a
                        >
                        and
                        <a
                          href="https://www.rdocumentation.org/packages/graphics/versions/3.5.2/topics/axis"
                          target="_blank"
                          ><code class="language-r">axis()</code></a
                        >
                        to overlay two y-axes.
                      </p>
                      <details>
                        <summary>Click to see the code</summary>
                        <pre><code class="language-R">renderMirorenderer_timewise_load_demand_and_cost_external_grid_data &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...){
  # return the render for the placeholder &quot;table&quot;
  output$table &lt;- DT::renderDT({
    DT::datatable(data, editable = TRUE, rownames = FALSE, options = list(scrollX = TRUE)) %&gt;%
      DT::formatRound(c(&quot;cost_external_grid&quot;), digits = 2L)
  })

  # return the render for the placeholder &quot;timeline&quot;
  output$timeline &lt;- renderPlot({
    # first extract all the needed information
    x &lt;- data[[&quot;j&quot;]]
    y1 &lt;- data[[&quot;load_demand&quot;]]
    y2 &lt;- data[[&quot;cost_external_grid&quot;]]

    # set the margin for the graph
    par(mar = c(5, 4, 4, 5))

    # first, plot the load demand
    plot(y1,
      type = &quot;l&quot;, col = &quot;green&quot;,
      ylab = &quot;Load demand in W&quot;, lwd = 3, xlab = &quot;&quot;, xaxt = &quot;n&quot;, las = 2
    )
    points(y1, col = &quot;green&quot;, pch = 16, cex = 1.5)
    grid()

    # add second plot on the same graph for the external cost
    par(new = TRUE) # overlay a new plot
    plot(y2,
      type = &quot;l&quot;, col = &quot;blue&quot;,
      axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, lwd = 3
    )
    points(y2, col = &quot;blue&quot;, pch = 16, cex = 1.5)

    # add a new y-axis on the right for the second line
    axis(side = 4, las = 2)
    mtext(&quot;External grid cost in $&quot;, side = 4, line = 3)
    grid()

    # add the x values to the axis
    axis(side = 1, at = 1:length(x), labels = x, las = 2)

    legend(&quot;topleft&quot;,
      legend = c(&quot;Load demand&quot;, &quot;External grid cost&quot;),
      col = c(&quot;green&quot;, &quot;blue&quot;), lty = 1, lwd = 2, pch = 16
    )
  })
}</code></pre>
                      </details>
                      <p>Now you should see something like this:</p>
                      <div class="section-block">
                        <img
                          class="img-fluid"
                          style="max-width: 100%"
                          src="assets/images/step_by_step_tutorial/widget_first_version.png"
                          alt="Result of pivot tool for Balance"
                        />
                      </div>
                      <p>
                        At this point, any changes we make in the table do not
                        reflect in the plot. To fix this, we need
                        <a
                          href="https://shiny.posit.co/r/getstarted/shiny-basics/lesson6/"
                          target="_blank"
                          >reactive expressions</a
                        >. We need to add them for each interaction that should
                        result in an update.
                      </p>
                      <p>
                        First, we define a variable
                        <code class="language-r">rv</code> for our
                        <a
                          href="https://www.rdocumentation.org/packages/shiny/versions/1.9.1/topics/reactiveValues"
                          target="_blank"
                          >reactiveValues</a
                        >.
                      </p>
                      <pre><code class="language-R">rv &lt;- reactiveValues(
  timewise_input_data = NULL
)</code></pre>
                      <p>
                        To set
                        <code class="language-r">rv$timewise_input_data</code>
                        we
                        <a
                          href="https://www.rdocumentation.org/packages/shiny/versions/1.9.1/topics/observe"
                          target="_blank"
                          ><code class="language-r">observe()</code></a
                        >
                        the initial <code class="language-r">data</code>. If it
                        changes we set our reactive value to the data.
                      </p>
                      <pre><code class="language-R">observe({
  rv$timewise_input_data &lt;- data
})</code></pre>
                      <p>
                        To monitor edits to the table, we define a new
                        <code class="language-r">observe()</code> that will be
                        triggered when
                        <code class="language-r">input$table_cell_edit</code>
                        changes. We get the row and column index of the edited
                        cell (<code class="language-r"
                          >input$table_cell_edit$row</code
                        >
                        and
                        <code class="language-r"
                          >input$table_cell_edit$col</code
                        >) and update the corresponding value in
                        <code class="language-r">rv$timewise_input_data</code>.
                        The
                        <a
                          href="https://www.rdocumentation.org/packages/shiny/versions/1.9.1/topics/isolate"
                          target="_blank"
                          ><code class="language-r">isolate()</code></a
                        >
                        function ensures that changes to
                        <code class="language-r">rv</code> do not trigger this
                        <code class="language-r">observe()</code> function.
                      </p>
                      <pre><code class="language-R"># observe if the table is edited
observe({
  input$table_cell_edit

  row &lt;- input$table_cell_edit$row
  # need to add one since the first column is the index
  clmn &lt;- input$table_cell_edit$col + 1

  isolate({
    rv$timewise_input_data[row, clmn] &lt;- input$table_cell_edit$value
  })
})</code></pre>
                      <p>
                        If the new value of the entry would be empty (<code
                          class="language-r"
                          >""</code
                        >), we want to reset the table. To do this, we set up a
                        <a
                          href="https://www.rdocumentation.org/packages/DT/versions/0.33/topics/dataTableProxy"
                          target="_blank"
                          ><code class="language-r">dataTableProxy()</code></a
                        >
                        to efficiently update the table. Our
                        <code class="language-r">resetTable()</code> function
                        is defined to dynamically replace the table data using
                        the current state of
                        <code class="language-r">rv$timewise_input_data</code>.
                        The function
                        <a
                          href="https://www.rdocumentation.org/packages/DT/versions/0.33/topics/replaceData"
                          target="_blank"
                          ><code class="language-r">DT::replaceData()</code></a
                        >
                        allows the table to be updated without resetting
                        sorting, filtering, and pagination. We need to
                        <code class="language-r">isolate()</code> the data
                        again so that the function is not called if
                        <code class="language-r">rv</code> changes!
                      </p>
                      <pre><code class="language-R">tableProxy &lt;- DT::dataTableProxy(&quot;table&quot;)
resetTable &lt;- function() {
  DT::replaceData(tableProxy, isolate(rv$timewise_input_data), resetPaging = FALSE, rownames = FALSE)
}</code></pre>
                      <p>
                        Finally, we now need to reference
                        <code class="language-r">rv$timewise_input_data</code>
                        instead of <code class="language-r">data</code> in the
                        plot renderer, so that the plot is updated whenever a
                        table cell changes.
                      </p>
                      <details>
                        <summary>
                          Click to see the full code of the current state
                        </summary>
                        <pre><code class="language-R">renderMirowidget_timewise_load_demand_and_cost_external_grid_data &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {
  # The whole code is run at the beginning, even though no actions are performed yet.
  # init is used to only perform action in observe() after this initial run.
  # Therefore, it is set to TRUE in the last occurring observe()
  init &lt;- FALSE
  rv &lt;- reactiveValues(
    timewise_input_data = NULL
  )

  # set the initial data
  observe({
    rv$timewise_input_data &lt;- data
  })

  tableProxy &lt;- DT::dataTableProxy(&quot;table&quot;)

  resetTable &lt;- function() {
    DT::replaceData(tableProxy, isolate(rv$timewise_input_data), resetPaging = FALSE, rownames = FALSE)
  }

  # observe if the table is edited
  observe({
    input$table_cell_edit
    row &lt;- input$table_cell_edit$row
    # need to add one since the first column is the index
    clmn &lt;- input$table_cell_edit$col + 1

    # if the new value is empty, restore the value from before
    if (input$table_cell_edit$value == &quot;&quot;) {
      resetTable()
      return()
    }

    # else, update the corresponding value in the reactiveValue
    isolate({
      rv$timewise_input_data[row, clmn] &lt;- input$table_cell_edit$value
    })
  })

  # return the render for the placeholder &quot;table&quot;
  output$table &lt;- DT::renderDT({
    DT::datatable(rv$timewise_input_data, editable = TRUE, rownames = FALSE, options = list(scrollX = TRUE)) %&gt;%
      DT::formatRound(c(&quot;cost_external_grid&quot;), digits = 2L)
  })

  # return the render for the placeholder &quot;timeline&quot;
  output$timeline &lt;- renderPlot({
    # first extract all the needed information
    x &lt;- rv$timewise_input_data[[&quot;j&quot;]]
    y1 &lt;- rv$timewise_input_data[[&quot;load_demand&quot;]]
    y2 &lt;- rv$timewise_input_data[[&quot;cost_external_grid&quot;]]

    # set the margin for the graph
    par(mar = c(5, 4, 4, 5))

    # first, plot the load demand
    plot(y1,
      type = &quot;l&quot;, col = &quot;green&quot;,
      ylab = &quot;Load demand in W&quot;, lwd = 3, xlab = &quot;&quot;, xaxt = &quot;n&quot;, las = 2
    )
    points(y1, col = &quot;green&quot;, pch = 16, cex = 1.5)
    grid()

    # add second plot on the same graph for the external cost
    par(new = TRUE) # overlay a new plot
    plot(y2,
      type = &quot;l&quot;, col = &quot;blue&quot;,
      axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, lwd = 3
    )
    points(y2, col = &quot;blue&quot;, pch = 16, cex = 1.5)

    # add a new y-axis on the right for the second line
    axis(side = 4, las = 2)
    mtext(&quot;External grid cost in $&quot;, side = 4, line = 3)
    grid()

    # add the x values to the axis
    axis(side = 1, at = 1:length(x), labels = x, las = 2)

    legend(&quot;topleft&quot;,
      legend = c(&quot;Load demand&quot;, &quot;External grid cost&quot;),
      col = c(&quot;green&quot;, &quot;blue&quot;), lty = 1, lwd = 2, pch = 16
    )
  })
}</code></pre>
                      </details>
                      <p>
                        After these changes, we have a reactive table-plot
                        combination, but it still behaves like an output
                        renderer. We need to take a few final steps to turn
                        this into a
                        <a
                          href="https://www.gams.com/miro/configuration_json_only.html#custom-input-widgets"
                          target="_blank"
                          >custom input widget</a
                        >
                        so that the new data can be used to solve!
                      </p>
                    </div>
                    <!--//section-block-->
                    <div
                      id="from-custom-renderer-to-custom-widget"
                      class="section-block"
                    >
                      <h4 class="block-title">
                        From Custom Renderer To Custom Widget
                      </h4>
                      <p>
                        To turn the renderer into a widget, we save our
                        renderer in the Configuration Mode and go to the
                        directory where it was saved. Here we first need to
                        change the name of the file to
                        <span class="code"
                          >mirowidget_timewise_load_demand_and_cost_external_grid_data.R</span
                        >
                        Now we need to rename the functions:
                      </p>
                      <pre><code class="language-diff">- mirorenderer_timewise_load_demand_and_cost_external_grid_dataOutput &lt;- function(id, height = NULL, options = NULL, path = NULL){
+ mirowidget_timewise_load_demand_and_cost_external_grid_dataOutput &lt;- function(id, height = NULL, options = NULL, path = NULL) {
  ...
}

- renderMirorenderer_timewise_load_demand_and_cost_external_grid_data &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...){
+ renderMirowidget_timewise_load_demand_and_cost_external_grid_data &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {
  ...
}</code></pre>
                      <p>
                        We need to make some small changes to our code. The
                        <code class="language-r">data</code> parameter is no
                        longer a tibble, but a
                        <a
                          href="https://shiny.posit.co/r/getstarted/shiny-basics/lesson6/"
                          target="_blank"
                          >reactive expression</a
                        >
                        (<code class="language-r">data()</code>). Therefore, we
                        need to call it to retrieve the current tibble with our
                        input data. Whenever the data changes (for example,
                        because the user uploaded a new CSV file), the reactive
                        expression is triggered, which in turn causes our table
                        to be re-rendered with the new data.
                      </p>
                      <pre><code class="language-diff"># set the initial data
 observe({
-  rv$timewise_input_data &lt;- data
+ rv$timewise_input_data &lt;- data()
 })</code></pre>
                      <p>
                        All code is executed when the application is started,
                        even though no actions have been performed yet. The
                        <code class="language-r">init</code> is used to execute
                        actions in
                        <code class="language-r">observe()</code> only after
                        this initial execution. It ensures that the reactive
                        logic is not executed until the application is fully
                        initialized and all data is loaded. Since we only have
                        one <code class="language-r">observe()</code> we set it
                        to <code class="language-r">True</code> here, if we had
                        more we would set
                        <code class="language-r">init</code> to
                        <code class="language-r">True</code> in the last
                        <code class="language-r">observe()</code> block.
                      </p>
                      <pre><code class="language-R">if (!init) {
  init &lt;&lt;- TRUE
  return()
}</code></pre>
                      <p>
                        Now, we need to return the input data to be passed to
                        GAMS(Py). For this, we provide a
                        <a
                          href="https://www.rdocumentation.org/packages/shiny/versions/1.10.0/topics/reactive"
                          target="_blank"
                          ><code class="language-r">reactive()</code></a
                        >
                        wrapper around
                        <code class="language-r">rv$timewise_input_data</code>.
                        It ensures that the current state of the data is
                        available as a reactive output, allowing us to pass the
                        new data to the model. Otherwise
                        <em>Solve model</em> would still use the old data!
                      </p>
                      <pre><code class="language-R">return(reactive({
  rv$timewise_input_data
}))</code></pre>
                      <details>
                        <summary>Click to see the full code</summary>
                        <pre><code class="language-R">renderMirowidget_timewise_load_demand_and_cost_external_grid_data &lt;- function(input, output, session, data, options = NULL, path = NULL, rendererEnv = NULL, views = NULL, outputScalarsFull = NULL, ...) {
  # The whole code is run at the beginning, even though no actions are performed yet.
  # init is used to only perform action in observe() after this initial run.
  # Therefore, it is set to TRUE in the last occurring observe()
  init &lt;- FALSE
  rv &lt;- reactiveValues(
    timewise_input_data = NULL
  )

  # set the initial data
  observe({
    rv$timewise_input_data &lt;- data()
  })

  tableProxy &lt;- DT::dataTableProxy(&quot;table&quot;)

  resetTable &lt;- function() {
    DT::replaceData(tableProxy, isolate(rv$timewise_input_data), resetPaging = FALSE, rownames = FALSE)
  }

  # observe if the table is edited
  observe({
    input$table_cell_edit
    if (!init) {
      init &lt;&lt;- TRUE
      return()
    }
    row &lt;- input$table_cell_edit$row
    # need to add one since the first column is the index
    clmn &lt;- input$table_cell_edit$col + 1

    # if the new value is empty, restore the value from before
    if (input$table_cell_edit$value == &quot;&quot;) {
      resetTable()
      return()
    }

    # else, update the corresponding value in the reactiveValue
    isolate({
      rv$timewise_input_data[row, clmn] &lt;- input$table_cell_edit$value
    })
  })

  # return the render for the placeholder &quot;table&quot;
  output$table &lt;- DT::renderDT({
    DT::datatable(rv$timewise_input_data, editable = TRUE, rownames = FALSE, options = list(scrollX = TRUE)) %&gt;%
      DT::formatRound(c(&quot;cost_external_grid&quot;), digits = 2L)
  })

  # return the render for the placeholder &quot;timeline&quot;
  output$timeline &lt;- renderPlot({
    # first extract all the needed information
    x &lt;- rv$timewise_input_data[[&quot;j&quot;]]
    y1 &lt;- rv$timewise_input_data[[&quot;load_demand&quot;]]
    y2 &lt;- rv$timewise_input_data[[&quot;cost_external_grid&quot;]]

    # set the margin for the graph
    par(mar = c(5, 4, 4, 5))

    # first, plot the load demand
    plot(y1,
      type = &quot;l&quot;, col = &quot;green&quot;,
      ylab = &quot;Load demand in W&quot;, lwd = 3, xlab = &quot;&quot;, xaxt = &quot;n&quot;, las = 2
    )
    points(y1, col = &quot;green&quot;, pch = 16, cex = 1.5)
    grid()

    # add second plot on the same graph for the external cost
    par(new = TRUE) # overlay a new plot
    plot(y2,
      type = &quot;l&quot;, col = &quot;blue&quot;,
      axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, lwd = 3
    )
    points(y2, col = &quot;blue&quot;, pch = 16, cex = 1.5)

    # add a new y-axis on the right for the second line
    axis(side = 4, las = 2)
    mtext(&quot;External grid cost in $&quot;, side = 4, line = 3)
    grid()

    # add the x values to the axis
    axis(side = 1, at = 1:length(x), labels = x, las = 2)

    legend(&quot;topleft&quot;,
      legend = c(&quot;Load demand&quot;, &quot;External grid cost&quot;),
      col = c(&quot;green&quot;, &quot;blue&quot;), lty = 1, lwd = 2, pch = 16
    )
  })

  # since this is an input, need to return the final data
  return(reactive({
    rv$timewise_input_data
  }))
}</code></pre>
                      </details>
                      <p>
                        Finally, we need to remove the renderer in
                        <span class="code">&lt;model_name&gt;.json</span> and
                        instead add
                        <code class="language-json"
                          >"timewise_load_demand_and_cost_external_grid_data"</code
                        >
                        to the
                        <code class="language-json">"inputWidgets"</code>:
                      </p>
                      <pre><code class="language-json">"inputWidgets": {
  ...

  "timewise_load_demand_and_cost_external_grid_data": {
    "alias": "Timeline for load demand and cost of the external grid",
    "apiVersion": 2,
    "options": {
        "isInput": true
    },
    "rendererName": "mirowidget_timewise_load_demand_and_cost_external_grid_data",
    "widgetType": "custom"
  }
}</code></pre>
                      <p>
                        Congratulations—our new custom widget combines a table
                        and a plot, with both updating interactively. At this
                        point, <em>Solve model</em> will use our updated table
                        whenever we change values and re-run the model.
                      </p>
                      <p>
                        Now that you’ve mastered the basics of custom renderers
                        in MIRO, you can explore more creative implementations.
                        If you need more inspiration on what you can do with
                        the custom renderer, take a look at the
                        <a href="https://miro.gams.com/" target="_blank"
                          >MIRO gallery</a
                        >, e.g. take a look at some applications with maps (<a
                          href="https://miro.gams.com/gallery/app_direct/tsp/"
                          target="_blank"
                          >TSP</a
                        >
                        or
                        <a
                          href="https://miro.gams.com/gallery/app_direct/vrptw/"
                          target="_blank"
                          >VRPTW</a
                        >).
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="key-takeaways-5" class="section-block">
                      <h3 class="block-title">Key Takeaways</h3>
                      <ul>
                        <li>
                          <strong>Unlimited Customization</strong>: R-based
                          renderers let you do anything from advanced plotting
                          to building interactive features.
                        </li>
                        <li>
                          <strong>Leverage Shiny Ecosystem</strong>: Shiny’s
                          reactive expressions help you link user actions
                          (sliders, clicks) with real-time graph updates.
                        </li>
                        <li>
                          <strong>GAMS(Py) for Logic, R for Visuals</strong>:
                          Use Python or GAMS to handle calculations; R custom
                          renderers are perfect for specialized visual
                          displays.
                        </li>
                      </ul>
                    </div>
                    <!--//section-block-->
                    <div
                      id="custom-import-and-export-streamlining-your-data-workflow"
                      class="section-block"
                    >
                      <h2 class="block-title">
                        Custom Import and Export: Streamlining Your Data
                        Workflow
                      </h2>
                      <p>
                        In any data-centric project, the ability to efficiently
                        manage data movement is critical. While MIRO already
                        provides a number of ways to
                        <a
                          href="https://www.gams.com/miro/start.html#import-data"
                          target="_blank"
                          >import</a
                        >
                        and
                        <a
                          href="https://www.gams.com/miro/start.html#save-export-delete"
                          target="_blank"
                          >export</a
                        >
                        data—such as GDX, Excel, or CSV—there are many
                        situations where you need more flexible solutions. For
                        instance:
                      </p>
                      <ul>
                        <li>
                          You might store data in a database and prefer not to
                          export it to CSV first.
                        </li>
                        <li>
                          You may gather data from multiple sources and need to
                          reformat it so MIRO recognizes the correct symbol
                          names.
                        </li>
                      </ul>
                      <p>
                        Custom import and export functions handle these
                        scenarios by allowing you to:
                      </p>
                      <ul>
                        <li>
                          Work directly with databases or other file types.
                        </li>
                        <li>
                          Perform pre- or post-processing steps within MIRO.
                        </li>
                      </ul>
                    </div>
                    <!--//section-block-->
                    <div id="custom-importer" class="section-block">
                      <h3 class="block-title">Custom Importer</h3>
                      <p>
                        Here, we will go over the basic concept to give you a
                        good starting point for extending it to your needs.
                        Again, we follow the
                        <a
                          href="https://www.gams.com/miro/configuration_json_only.html#custom-import-export"
                          target="_blank"
                          >documentation</a
                        >
                        closely. First, let’s create a simple import function
                        that gets the data for our generators. For ease of
                        setup, we will just pretend to access a database and
                        actually hardcode the data here.
                      </p>
                      <p>
                        For our custom importer, we need to create a new file
                        in the
                        <span class="code">renderer_&lt;model_name&gt;</span>
                        directory called
                        <span class="code">miroimport.R</span>. Here you can
                        add several import functions, which should have the
                        following signature:
                      </p>
                      <pre><code class="language-R">miroimport_&lt;importerName&gt; &lt;- function(symNames, localFile = NULL, views = NULL, attachments = NULL, metadata = NULL, customRendererDir = NULL, ...) {

}</code></pre>
                      <p>
                        Here we will only go over the parameters we will be
                        using, for information on the others see the
                        <a
                          href="https://www.gams.com/miro/configuration_json_only.html#custom-import-export"
                          target="_blank"
                          >documentation</a
                        >. The
                        <code class="language-r">"symNames"</code> parameter is
                        a character vector that specifies the names of the
                        symbols for which data is to be retrieved. There is
                        also an optional
                        <code class="language-r">"localFile"</code> parameter,
                        which is a data frame containing one row for each
                        uploaded file. What kind of data you can upload here is
                        specified in
                        <span class="code">&lt;model_name&gt;.json</span>.
                      </p>
                      <p>
                        We also need to add the importer to the
                        <span class="code">&lt;model_name&gt;.json</span>, to
                        do this we simply add a new key
                        <code class="language-r">"customDataImport"</code>:
                      </p>
                      <pre><code class="language-json">&quot;customDataImport&quot;: [
  {
    &quot;label&quot;: &quot;Gen specs import&quot;,
    &quot;functionName&quot;: &quot;miroimport_&lt;importerName&gt;&quot;,
    &quot;symNames&quot;: [&quot;generator_specifications&quot;]
  }
]</code></pre>
                      <p>
                        Where we simply specify the
                        <code class="language-r">"label"</code> the importer
                        will have when you select it under
                        <em>Load data</em> in the MIRO application.
                        <code class="language-r">"functionName"</code>
                        specifies the name of our custom import function in
                        <span class="code">miroimport.R</span>. And
                        <code class="language-r">"symNames"</code> specifying
                        which GAMS symbols the importer handles.
                      </p>
                      <p>
                        If you want to allow the user to upload files, you need
                        to add
                        <code class="language-r">"localFileInput"</code>, which
                        could look like this
                      </p>
                      <pre><code class="language-json">&quot;customDataImport&quot;: [
  {
    ...
    &quot;localFileInput&quot;: {
      &quot;label&quot;: &quot;Please upload your JSON file here&quot;,
      &quot;multiple&quot;: false,
      &quot;accept&quot;: [&quot;.json&quot;, &quot;application/json&quot;]
    }
  }
]</code></pre>
                      <p>
                        For more information on the available options, see the
                        <a
                          href="https://www.gams.com/miro/configuration_json_only.html#custom-import-export"
                          target="_blank"
                          >documentation</a
                        >.
                      </p>
                      <p>
                        Now we can start our MIRO application and use the
                        importer, but since we haven’t filled it with code yet,
                        nothing happens. So let’s define
                        <code class="language-r">miroimport_GenSpecs()</code>
                        to return a tibble with new generator specifications.
                        This is done by returning a named list where the names
                        correspond to the given
                        <code class="language-r">"symbolNames"</code>. Here we
                        will simply hardcode it to return the same data as
                        before, just changing the names to see that it actually
                        imported the new data.
                      </p>
                      <pre><code class="language-R">miroimport_GenSpecs &lt;- function(symbolNames, localFile = NULL, views = NULL, attachments = NULL, metadata = NULL, customRendererDir = NULL, ...) {
  # Let&#39;s say this is your result
  generator_specifications &lt;- tibble(
      i = c(&quot;gen3&quot;, &quot;gen4&quot;, &quot;gen5&quot;),
      cost_per_unit = c(1.1, 1.3, 0.9),
      fixed_cost = c(220, 290, 200),
      min_power_output = c(50, 80, 10),
      max_power_output = c(100, 190, 70),
      min_up_time = c(4, 4, 4),
      min_down_time = c(2, 2, 2)
  )

  # Now all you need to do is save the import symbols to a named list.
  import_data &lt;- list(&quot;generator_specifications&quot; = generator_specifications)

  # And return the data to the MIRO application.
  return(import_data)
}</code></pre>
                      <p>
                        After saving, we can reload MIRO and select
                        <em>Gen specs import</em> under <em>Load data</em>. The
                        generator names will update accordingly, proving our
                        custom code works. Although this example is hardcoded,
                        the same framework can fetch data from any source, fix
                        column names to fit MIRO’s symbols (stored in
                        <code class="language-r">"symbolNames"</code>), or
                        perform more complicated transformations such as
                        database queries.
                      </p>
                      <p>
                        In a real scenario with database queries, you’ll likely
                        store credentials in a secure environment. MIRO allows
                        you to specify environments; this is where we store our
                        credentials. For MIRO
                        <a
                          href="https://www.gams.com/miro/deployment.html#custom-environments"
                          target="_blank"
                          >Desktop</a
                        >, create a JSON file—e.g., <em>miro-env.js</em>—that
                        looks like:
                      </p>
                      <pre><code class="language-js">{
    &quot;DB_USERNAME&quot;: &quot;User1&quot;,
    &quot;DB_PASSWORD&quot;: &quot;mySuperSecretPassword!&quot;
}</code></pre>
                      <p>
                        Now in MIRO Desktop go to <em>File</em> and then to
                        <em>Preferences</em>. Under <em>Environment</em> you
                        can now upload the json file. You can access these
                        credentials via
                        <code class="language-r">Sys.getenv()</code> inside
                        your importer, for example:
                      </p>
                      <pre><code class="language-R">miroimport_GenSpecs &lt;- function(symbolNames, localFile = NULL, views = NULL, attachments = NULL, metadata = NULL, customRendererDir = NULL, ...) {

    # Where you get your data from depends on your data structures.
    # Let&#39;s say we have a MySQL database that contains our generator specifications.
    # To gain access, we store our credentials in the environment.

    # Establish connection
    con &lt;- dbConnect(
        RMySQL::MySQL(),
        dbname = &quot;your_database_name&quot;,
        host = &quot;your_host_address&quot;,
        port = 3306,
        user = Sys.getenv(&quot;DB_USERNAME&quot;),
        password = Sys.getenv(&quot;DB_PASSWORD&quot;)
    )

    # Run a SQL query and fetch data into a data frame
    query_result &lt;- dbGetQuery(con, &quot;SELECT * FROM generator_specifications&quot;)

    # Now all you need to do is save the import symbols to a named list.
    import_data &lt;- list(&quot;generator_specifications&quot; = query_result)

    # And return the data to the MIRO application.
    return(import_data)
}</code></pre>
                      <p>
                        In the
                        <a
                          href="https://www.gams.com/miro/configuration_json_only.html#custom-import-export"
                          target="_blank"
                          >documentation</a
                        >
                        you can find an example that also handles file uploads.
                      </p>
                      <p>
                        By now, you should be well-equipped to write your own
                        custom importer that handles all the data collection
                        and preprocessing your application requires.
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="custom-exporter" class="section-block">
                      <h3 class="block-title">Custom Exporter</h3>
                      <p>
                        A custom exporter works similarly. We need to add a
                        <span class="code">miroexport.R</span> to the
                        <span class="code">renderer_&lt;model_name&gt;</span>
                        directory first, which should have the following
                        signature:
                      </p>
                      <pre><code class="language-R">miroexport_&lt;exporterName&gt; &lt;- function(data, path = NULL, views = NULL, attachments = NULL, metadata = NULL, customRendererDir = NULL, ...) {

}</code></pre>
                      <p>
                        Where <code class="language-r">"data"</code> is again a
                        named list of tibbles containing all input and output
                        symbols of the model and
                        <code class="language-r">"path"</code> is the path to
                        the (temporary) file provided to the user for download
                        (optional). This depends on how you specified it in the
                        json file:
                      </p>
                      <pre><code class="language-json">{
  &quot;customDataExport&quot;: [
    {
      &quot;label&quot;: &quot;Custom report export&quot;,
      &quot;functionName&quot;: &quot;miroexport_Markdown&quot;,
      &quot;localFileOutput&quot;: {
        &quot;filename&quot;: &quot;report.md&quot;,
        &quot;contentType&quot;: &quot;application/md&quot;
      }
    }
  ]
}</code></pre>
                      <p>
                        Again, we need to link the
                        <code class="language-json">"functionName"</code>, and
                        if we want to create an output file, we need to specify
                        it in
                        <code class="language-json">"localFileOutput"</code>.
                        Here, we’ve chosen to generate a markdown file.
                      </p>
                      <p>
                        Inside
                        <code class="language-json">miroexport_Markdown()</code
                        >, we do whatever tasks we want, such as:
                      </p>
                      <ul>
                        <li>
                          Writing data back to a database (even the input data,
                          since it may have changed due to the interactive
                          nature of the application).
                        </li>
                        <li>Generating a downloadable file.</li>
                        <li>
                          Merging input parameters with output results in a
                          custom format.
                        </li>
                      </ul>
                      <p>
                        Below is an example that writes a small Markdown
                        report. Helpful functions in this case are
                        <a
                          href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/writeLines"
                          target="_blank"
                          ><code class="language-r">"writeLines()"</code></a
                        >,
                        <a
                          href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/paste"
                          target="_blank"
                          ><code class="language-r">"paste()"</code></a
                        >,
                        <a
                          href="https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter"
                          target="_blank"
                          ><code class="language-r">"filter()"</code></a
                        >,
                        <a
                          href="https://www.rdocumentation.org/packages/lplyr/versions/0.1.6/topics/pull"
                          target="_blank"
                          ><code class="language-r">"pull()"</code></a
                        >,
                        <a
                          href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/apply"
                          target="_blank"
                          ><code class="language-r">"apply()"</code></a
                        >
                        …
                      </p>
                      <p>Your result could look something like this:</p>
                      <hr style="width: 100%; border: 1px solid #000" />
                      <p>Our final total cost is: 26635 $</p>
                      <p>
                        With a battery power (delivery) rate of 130 kW and a
                        battery energy (storage) rate of 420 kWh.
                      </p>
                      <p>With the following generator specifications:</p>
                      <table>
                        <colgroup>
                          <col style="width: 4%" />
                          <col style="width: 15%" />
                          <col style="width: 12%" />
                          <col style="width: 19%" />
                          <col style="width: 19%" />
                          <col style="width: 13%" />
                          <col style="width: 15%" />
                        </colgroup>
                        <thead>
                          <tr>
                            <th>i</th>
                            <th>cost_per_unit</th>
                            <th>fixed_cost</th>
                            <th>min_power_output</th>
                            <th>max_power_output</th>
                            <th>min_up_time</th>
                            <th>min_down_time</th>
                          </tr>
                        </thead>
                        <tbody>
                          <tr>
                            <td>gen0</td>
                            <td>1.1</td>
                            <td>220</td>
                            <td>50</td>
                            <td>100</td>
                            <td>4</td>
                            <td>2</td>
                          </tr>
                          <tr>
                            <td>gen1</td>
                            <td>1.3</td>
                            <td>290</td>
                            <td>80</td>
                            <td>190</td>
                            <td>4</td>
                            <td>2</td>
                          </tr>
                          <tr>
                            <td>gen2</td>
                            <td>0.9</td>
                            <td>200</td>
                            <td>10</td>
                            <td>70</td>
                            <td>4</td>
                            <td>2</td>
                          </tr>
                        </tbody>
                      </table>
                      <hr style="width: 100%; border: 1px solid #000" />
                      <details>
                        <summary>
                          Click to see the code for the custom exporter
                        </summary>
                        <pre><code class="language-R">miroexport_Markdown &lt;- function(data, path = NULL, views = NULL, attachments = NULL, metadata = NULL, customRendererDir = NULL, ...) {
    # First, extract the values you want to display.
    total_cost &lt;- data[[&quot;_scalars_out&quot;]] %&gt;%
        filter(scalar == &quot;total_cost&quot;) %&gt;%
        pull(value) %&gt;%
        as.numeric() %&gt;%
        round(2)

    battery_delivery_rate &lt;- data[[&quot;_scalarsve_out&quot;]] %&gt;%
        filter(scalar == &quot;battery_delivery_rate&quot;) %&gt;%
        pull(level)

    battery_storage &lt;- data[[&quot;_scalarsve_out&quot;]] %&gt;%
        filter(scalar == &quot;battery_storage&quot;) %&gt;%
        pull(level)

    output_string &lt;- paste(
        &quot;Our final total cost is: &quot;, total_cost,
        &quot;$\n\nWith a battery power (delivery) rate of &quot;, battery_delivery_rate,
        &quot;kW and a battery energy (storage) rate of &quot;, battery_storage, &quot;kWh.&quot;
    )

    # Open a connection to the output file
    file_conn &lt;- file(path, &quot;w&quot;)

    # Then write them to the output file.
    writeLines(output_string, file_conn)

    writeLines(&quot;\n\n&quot;, file_conn)

    # Let&#39;s add the generator specifications used
    writeLines(&quot;With the following generator specifications:\n\n&quot;, file_conn)

    # Extract the table
    table &lt;- data[[&quot;generator_specifications&quot;]]

    # Convert the table to a Markdown-style string
    # Create the header
    headers &lt;- paste(names(table), collapse = &quot; | &quot;)
    separator &lt;- paste(rep(&quot;---&quot;, length(table)), collapse = &quot; | &quot;)
    rows &lt;- apply(table, 1, function(row) paste(row, collapse = &quot; | &quot;))

    # Write the table to the file
    writeLines(paste(headers, separator, paste(rows, collapse = &quot;\n&quot;), sep = &quot;\n&quot;), file_conn)

    # Close the file connection
    close(file_conn)

    # If you also want to save the data to a database,
    # you can do that here as well, similar to the import function.
}</code></pre>
                      </details>
                      <p>
                        If your exporter uploads results back to a database,
                        you can again use environment variables for
                        credentials, just like in the importer.
                      </p>
                    </div>
                    <!--//section-block-->
                    <div id="key-takeaways-6" class="section-block">
                      <h3 class="block-title">Key Takeaways</h3>
                      <ul>
                        <li>
                          <strong>Direct Database Access</strong>: Skip manual
                          file conversions by pulling/pushing data straight to
                          and from external DBs.
                        </li>
                        <li>
                          <strong>Pre/Post Processing</strong>: Clean or
                          transform your data automatically before it even
                          reaches MIRO or after results are generated.
                        </li>
                        <li>
                          <strong>Flexible Format Support</strong>: Whether
                          CSV, Excel, JSON, or SQL queries, custom scripts can
                          unify multiple sources or produce tailored outputs.
                        </li>
                      </ul>
                    </div>
                    <!--//section-block-->
                    <div id="deployment" class="section-block">
                      <h2 class="section-title">Deployment</h2>
                      <div class="section-block">
                        <p>
                          As a very last step, you will probably want to deploy
                          your new shiny MIRO application. Covering deployment
                          in detail would go beyond the scope of this tutorial,
                          so we encourage you to read the documentation:
                          <a
                            href="https://www.gams.com/miro/deployment.html"
                            target="_blank"
                            >Deployment</a
                          >. And when you are add it also check out
                          <a
                            href="https://www.gams.com/miro/server.html"
                            target="_blank"
                            >GAMS MIRO Server</a
                          >
                          if you are interested in running MIRO in the cloud.
                        </p>
                      </div>
                    </div>
                  </div>
                  <!--//section-block-->
                  <div id="conclusion" class="section-block">
                    <h2 class="section-title">Conclusion</h2>
                    <div class="section-block">
                      <p>
                        Throughout this tutorial, we have seen how MIRO
                        empowers you to develop powerful, interactive
                        optimization applications—from rapidly prototyping
                        inputs and outputs to creating intuitive dashboards. We
                        began by defining basic inputs and outputs, then
                        explored how to use the Configuration Mode to
                        effortlessly refine the user interface and data
                        visualization. Going further, we looked at custom
                        renderers to integrate additional functionality or
                        visualization libraries in R Shiny, and even created a
                        custom widget to give users instant feedback on their
                        input changes.
                      </p>
                      <p>
                        Finally, we addressed the importance of integrating
                        MIRO within larger data ecosystems. By using custom
                        import and custom export functions, you can directly
                        connect to databases, perform preprocessing or
                        postprocessing, and generate tailored output reports.
                        With these tools at hand, MIRO is not merely an
                        optimization front-end but a flexible, end-to-end
                        platform for building and deploying sophisticated
                        data-driven applications.
                      </p>
                      <p>
                        Use these examples as a starting point for your own
                        projects, adapting each feature—Configuration Mode,
                        custom renderers, widgets, importers, and exporters—to
                        suit your organization’s needs. By taking advantage of
                        MIRO’s extensibility, you can streamline data
                        workflows, create intuitive dashboards, and deliver
                        robust analytical models to users across your
                        organization.
                      </p>
                    </div>
                  </div>
                  <!--//section-block-->
                  <div id="reference-repository" class="section-block">
                    <h2 class="section-title">Reference Repository</h2>
                    <div class="section-block">
                      <p>
                        If you’d like to see a fully operational version of
                        this tutorial in action, head over to our
                        <a
                          href="https://github.com/GAMS-dev/miro/tree/master/src/model/gamspy/bess"
                          target="_blank"
                          >Repository</a
                        >. It contains:
                      </p>
                      <ul>
                        <li>
                          A self-contained folder with the GAMSPy model setup
                        </li>
                        <li>
                          JSON configuration files for MIRO customization
                        </li>
                        <li>
                          Example R scripts for custom renderers, widgets, and
                          data import/export
                        </li>
                      </ul>
                      <p>
                        Feel free to clone or fork the repo, adapt it for your
                        organization’s workflows, and submit improvements via
                        pull requests!
                      </p>
                    </div>
                  </div>
                </section>
              </div>
              <!--//content-inner-->
            </div>
            <!--//doc-content-->
            <div class="doc-sidebar col-md-3 col-12 order-0 d-none d-md-flex">
              <div id="doc-nav" class="doc-nav">
                <nav id="doc-menu" class="nav doc-menu flex-column sticky">
                  <a class="nav-link scrollto" href="#introduction-section"
                    >From Model to App</a
                  >
                  <nav class="doc-sub-menu nav flex-column">
                    <a
                      class="nav-link scrollto save-space"
                      href="#implement-the-model"
                      >Implement the Model</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#basic-application---rapid-prototyping"
                      >Basic Application - Rapid Prototyping</a
                    >
                  </nav>
                  <!--//nav-->
                  <a class="nav-link scrollto" href="#configuration-mode"
                    >Configuration Mode</a
                  >
                  <nav class="doc-sub-menu nav flex-column">
                    <a
                      class="nav-link scrollto save-space"
                      href="#general-settings"
                      >General Settings</a
                    >
                    <a class="nav-link scrollto save-space" href="#symbols"
                      >Symbols</a
                    >
                    <a class="nav-link scrollto save-space" href="#tables"
                      >Tables</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#input-widgets"
                      >Input Widgets</a
                    >
                    <a class="nav-link scrollto save-space" href="#graphs"
                      >Graphs</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#scenario-analysis"
                      >Scenario analysis</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#database-management"
                      >Database management</a
                    >
                  </nav>
                  <a class="nav-link scrollto" href="#dashboard">Dashboard</a>
                  <nav class="doc-sub-menu nav flex-column">
                    <a
                      class="nav-link scrollto save-space"
                      href="#adding-additional-data"
                      >Adding Additional Data</a
                    >
                    <a class="nav-link scrollto save-space" href="#value-boxes"
                      >Value Boxes</a
                    >
                    <a class="nav-link scrollto save-space" href="#data-views"
                      >Data Views</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#configuring-charts-and-tables"
                      >Configuring Charts and Tables</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#dashboard-comparison"
                      >Dashboard Comparison</a
                    >
                  </nav>
                  <!--//nav-->
                  <a
                    class="nav-link scrollto"
                    href="#fine-tuning-with-custom-code"
                    >Fine Tuning with Custom Code</a
                  >
                  <nav class="doc-sub-menu nav flex-column">
                    <a
                      class="nav-link scrollto save-space"
                      href="#custom-renderer"
                      >Custom Renderer</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#custom-dashboard"
                      >Custom Dashboard</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#custom-widget"
                      >Custom Widget</a
                    >
                    <a
                      class="nav-link scrollto save-space"
                      href="#custom-import-and-export-streamlining-your-data-workflow"
                      >Custom Import and Export: Streamlining Your Data
                      Workflow</a
                    >
                  </nav>
                  <a class="nav-link scrollto save-space" href="#deployment"
                    >Deployment</a
                  >
                  <a class="nav-link scrollto save-space" href="#conclusion"
                    >Conclusion</a
                  >
                  <a
                    class="nav-link scrollto save-space"
                    href="#reference-repository"
                    >Reference Repository</a
                  >
                  <!--//nav-->
                </nav>
                <!--//doc-menu-->
              </div>
            </div>
            <!--//doc-sidebar-->
          </div>
          <!--//doc-body-->
        </div>
        <!--//container-->
      </div>
      <!--//doc-wrapper-->
    </div>
    <!--//page-wrapper-->
    <script type="text/javascript" src="assets/plugins/jquery.min.js"></script>
    <!--#include virtual="/footer_miro.html" -->

    <!-- Main Javascript -->
    <script
      type="text/javascript"
      src="assets/plugins/prism/min/prism-min.js"
    ></script>
    <script
      type="text/javascript"
      src="assets/plugins/prism/min/prism-diff-yaml.min.js"
    ></script>
    <script
      type="text/javascript"
      src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"
    ></script>
    <script
      type="text/javascript"
      src="assets/plugins/lightbox/dist/ekko-lightbox.min.js"
    ></script>
    <script
      type="text/javascript"
      src="assets/plugins/stickyfill/dist/stickyfill.min.js"
    ></script>
    <script
      type="text/javascript"
      src="assets/plugins/jquery-throttle-debounce/jquery.ba-throttle-debounce.min.js"
    ></script>
    <script
      type="text/javascript"
      src="assets/plugins/markjs/jquery.mark.min.js"
    ></script>
    <script type="text/javascript" src="assets/js/main.js"></script>
    <!-- gifplayer plugin -->
    <script type="text/javascript" src="assets/js/gifplayer.js"></script>
    <script>
      $('.gifplayer').gifplayer();
    </script>
    <!-- KaTeX -->
    <script
      type="text/javascript"
      defer
      src="assets/plugins/katex/katex.min.js"
    ></script>
    <script
      type="text/javascript"
      defer
      src="assets/plugins/katex/auto-render.min.js"
      onload="renderMathInElement(document.getElementsByClassName('katex')[0],{delimiters:[{left:'$$',right:'$$',display:true},{left: '$',right:'$',display:false}]});"
    ></script>
    <!-- Copy Code Button -->
    <script>
      function addCopyButtons() {
        document.querySelectorAll('pre > code').forEach(function (codeBlock) {
          // Create the button
          var button = document.createElement('button');
          button.className = 'copy-code-button';
          button.type = 'button';
          button.innerText = 'Copy';

          // Create the header for the language name and button
          var codeHeader = document.createElement('div');
          codeHeader.className = 'code-header';

          // Get the language class (assumed to be the first class, e.g., 'language-R')
          var languageClass = codeBlock.classList[0]; // e.g., 'language-R'
          var languageName = languageClass.replace(/^language-/, ''); // Remove the 'language-' prefix

          if (languageName === 'plaintext') {
            languageName = '';
          }

          var languageSpan = document.createElement('span');
          languageSpan.className = 'language-name';
          languageSpan.innerText = languageName;

          // Append language name and button to codeHeader
          codeHeader.appendChild(languageSpan);
          codeHeader.appendChild(button);

          // Add the codeHeader before the <pre> block
          var pre = codeBlock.parentNode;
          if (pre.parentNode.classList.contains('highlight')) {
            var highlight = pre.parentNode;
            highlight.parentNode.insertBefore(codeHeader, highlight);
          } else {
            pre.parentNode.insertBefore(codeHeader, pre);
          }

          // Button click event
          button.addEventListener('click', function () {
            navigator.clipboard.writeText(codeBlock.innerText).then(
              function () {
                button.blur();
                button.innerText = 'Copied!';
                setTimeout(function () {
                  button.innerText = 'Copy';
                }, 2000);
              },
              function (error) {
                button.innerText = 'Error';
              },
            );
          });
        });
      }

      addCopyButtons();
    </script>

    <style>
      /* Code block container */
      pre {
        position: relative;
        margin-bottom: 1rem;
        /* Space between blocks */
      }

      /* The header (language name + copy button) */
      .code-header {
        display: flex;
        justify-content: space-between;
        /* Space between language name and copy button */
        align-items: center;
        font-size: 0.9em;
        margin-bottom: 5px;
        /* Optional: space between header and code block */
      }

      /* Language name styling */
      .language-name {
        font-weight: bold;
        color: #272822;
      }

      /* Copy button styling */
      .copy-code-button {
        color: #272822;
        background-color: #fff;
        border-color: #272822;
        border: 2px solid;
        border-radius: 3px;
        padding: 3px 8px;
        font-size: 0.8em;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .copy-code-button:hover {
        background-color: #f2f2f2;
      }

      .copy-code-button:focus {
        background-color: #e6e6e6;
        outline: 0;
      }

      .copy-code-button:active {
        background-color: #d9d9d9;
      }

      /* Prevent the button from being pushed up by the code block */
      pre {
        margin: 0;
      }
    </style>
  </body>
</html>
