stages:
  - prepare
  - build
  - test
  - deploy

image:
  name: registry.gams.com/fproske/gmswebui/gamsmiro-ci:latest


variables:
  BUILD_LINUX:
    value: 'yes'
    description: 'Build Linux (ignored on master) (yes/no)?'
  BUILD_WINDOWS:
    value: 'yes'
    description: 'Build Windows (ignored on master) (yes/no)?'
  BUILD_MACOS:
    value: 'yes'
    description: 'Build macOS (ignored on master) (yes/no)?'
  FORCE_BUILD_LINUX_BUILDER:
    value: 'no'
    description: 'Build Linux build image even when Dockerfile did not change (yes/no)?'
  FORCE_BUILD_WINDOWS_BUILDER:
    value: 'no'
    description: 'Build Windows build image even when Dockerfile did not change (yes/no)?'
  BUILD_CI:
    value: 'no'
    description: 'Build CI image (yes/no)?'
  PUSH_UNSTABLE_SERVER_IMAGES:
    value: 'no'
    description: 'Push MIRO Server images to registry.gams.com (tagged as unstable on develop and feature on feature branches) (yes/no)?'


prepare_all:
  tags:
    - linux
  stage: prepare
  script:
    - 'echo "Building on branch: $CI_COMMIT_BRANCH"'
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "develop"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "rc"'
      when: always
    - if: $CI_MERGE_REQUEST_ID
      when: never
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - when: manual

build_build_image_linux:
  tags:
    - linux
  image: docker:20.10
  services:
    - docker:20.10-dind
  stage: prepare
  before_script:
    # this is to be able to pull and push images
    - mkdir -p $HOME/.docker
    - echo $DOCKER_AUTH_CONFIG > $HOME/.docker/config.json
    - apk update && apk add jq
  script:
    - cd ci/linux
    - docker build -t $CI_REGISTRY_IMAGE/builder-linux:latest --build-arg R_BASE_VERSION=`jq ".rVersion" ../../build-config.json` --build-arg OPENSSL_VERSION=`jq ".opensslVersion" ../../build-config.json` .
    - docker push $CI_REGISTRY_IMAGE/builder-linux:latest
  rules:
    - if: $FORCE_BUILD_LINUX_BUILDER == "yes"
    - if: '$CI_PIPELINE_SOURCE != "push"'
      when: never
    - changes:
      - ci/linux/Dockerfile

build_build_image_windows:
  tags:
    - windows-shell
  stage: prepare
  before_script:
    # this is to be able to pull and push images
    - New-Item -ItemType Directory -Force -Path %USERPROFILE%/.docker
    - $env:DOCKER_AUTH_CONFIG > %USERPROFILE%/.docker/config.json
  script:
    - $buildConfig=Get-Content build-config.json | ConvertFrom-Json
    - $rVersion=$buildConfig.rVersion
    - cd ci/windows
    - docker build -t $env:CI_REGISTRY_IMAGE/builder-windows:latest --build-arg R_VERSION=$rVersion .
    - docker push $env:CI_REGISTRY_IMAGE/builder-windows:latest
  rules:
    - if: $FORCE_BUILD_WINDOWS_BUILDER == "yes"
    - if: '$CI_PIPELINE_SOURCE != "push"'
      when: never
    - changes:
      - ci/windows/Dockerfile

lint_job:
  tags:
   - linux
  stage: test
  before_script:
    - git config --global --add safe.directory "$CI_PROJECT_DIR"
    - yarn install
  script:
   - pre-commit run --all-files
  variables:
    PRE_COMMIT_HOME: ${CI_PROJECT_DIR}/.cache/pre-commit
  cache:
    paths:
      - node_modules/
      - ${PRE_COMMIT_HOME}
  rules:
    - if: $CI_MERGE_REQUEST_ID
      when: always

build_linux_job:
  tags:
    - linux
  stage: build
  services:
    - docker:20.10-dind
  image: $CI_REGISTRY_IMAGE/builder-linux:latest
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_VERIFY: 1
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_CERT_PATH: "/certs/client"
    DOCKER_HOST: tcp://docker:2376
    GIT_SUBMODULE_STRATEGY: normal
    NODE_OPTIONS: --openssl-legacy-provider
  before_script:
    # this is to be able to pull and push images
    - mkdir -p $HOME/.docker
    - echo $DOCKER_AUTH_CONFIG > $HOME/.docker/config.json
  before_script:
    - yarn install
  script:
    - yarn dist
    - >
      if [[ "$PUSH_UNSTABLE_SERVER_IMAGES" != "no" ]] || [[ "$CI_COMMIT_BRANCH" == "master" ]] || [[ "$CI_COMMIT_BRANCH" == "develop" ]] || [[ "$CI_COMMIT_BRANCH" == "rc" ]]; then
        pushd server
            python3 miro_server.py build
            python3 miro_server.py push --unstable --custom-tag feature
        popd
      elif [[ "$BUILD_CI" != "no" ]]; then
        pushd server
          python3 miro_server.py build --module ui
        popd
      fi
    - >
      if [[ "$BUILD_CI" != "no" ]]; then
        yarn docker-build-ci
        docker tag gamsmiro-ci registry.gams.com/fproske/gmswebui/gamsmiro-ci:latest
        docker push registry.gams.com/fproske/gmswebui/gamsmiro-ci:latest
      fi
  artifacts:
    paths:
      - dist/*.AppImage
    expire_in: 1 week
  cache:
    - key: build-cache
      paths:
        - build/lib_devel/
    - key:
        files:
          - yarn.lock
      paths:
        - node_modules/
    - key:
        files:
          - src/package-lock.json
      paths:
        - src/node_modules/
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_MERGE_REQUEST_ID
      when: never
    - if: '"$CI_COMMIT_BRANCH" == "master" || "$BUILD_LINUX" != "no" || "$BUILD_CI" != "no" || "$PUSH_UNSTABLE_SERVER_IMAGES" != "no"'
      when: on_success
  needs: [prepare_all]

build_windows_job:
  tags:
    - windows
  stage: build
  image: $CI_REGISTRY_IMAGE/builder-windows:latest
  variables:
    CSC_LINK: cert.p12
    GIT_SUBMODULE_STRATEGY: normal
  before_script:
    - yarn install
    - '[IO.File]::WriteAllBytes([io.path]::Combine((Get-Location).path, $env:CSC_LINK), [Convert]::FromBase64String($env:WIN_CERT_FILE_B64))'
  script:
    - yarn dist
  artifacts:
    paths:
      - dist/*.exe
    expire_in: 1 week
  cache:
    - key:
        files:
          - src/miro-pkg-lock.csv
      paths:
        - r
    - key: build-cache
      paths:
        - build/lib_devel/
    - key:
        files:
          - yarn.lock
      paths:
        - node_modules
    - key:
        files:
          - src/package-lock.json
      paths:
        - src/node_modules/
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_MERGE_REQUEST_ID
      when: never
    - if: '"$CI_COMMIT_BRANCH" == "master" || "$BUILD_WINDOWS" != "no"'
      when: on_success
  needs: [prepare_all]


test_windows_job:
  tags:
    - windows
  stage: test
  image: $CI_REGISTRY_IMAGE/builder-windows:latest
  script:
    - yarn test gams_sys_dir=$env:GAMS_SYS_DIR
  dependencies: []
  cache:
    - key:
        files:
          - src/miro-pkg-lock.csv
      paths:
        - r
    - key: build-cache
      paths:
        - build/lib_devel/
    - key:
        files:
          - yarn.lock
      paths:
        - node_modules/
  artifacts:
    when: always
    reports:
      junit: src/test-out.xml
    paths:
      - src/tests/logs-tests
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_MERGE_REQUEST_ID
      when: never
    - if: '"$CI_COMMIT_BRANCH" == "master" || "$BUILD_WINDOWS" != "no"'
      when: on_success
  needs: [build_windows_job]

test_job_api:
  tags:
    - linux
  stage: test
  image: docker:20.10
  services:
    - name: docker:20.10-dind
    - name: postgres:12.1-alpine
      alias: postgres
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
    FF_NETWORK_PER_BUILD: "true"
    GMS_MIRO_DATABASE_HOST: postgres
    GMS_MIRO_DATABASE: miroapitests
    GMS_MIRO_DATABASE_USER: mirotests
    GMS_MIRO_DATABASE_PWD: mirotests
    POSTGRES_DB: $GMS_MIRO_DATABASE
    POSTGRES_USER: $GMS_MIRO_DATABASE_USER
    POSTGRES_PASSWORD: $GMS_MIRO_DATABASE_PWD
    POSTGRES_HOST_AUTH_METHOD: trust
  before_script:
    # this is to be able to pull and push images
    - mkdir -p $HOME/.docker
    - echo $DOCKER_AUTH_CONFIG > $HOME/.docker/config.json
  script:
    - docker pull ${CI_REGISTRY_IMAGE}/miro-auth-test:unstable && docker tag ${CI_REGISTRY_IMAGE}/miro-auth-test:unstable miro-auth-test || exit 1
    - ./test/run-api-tests.sh
  rules:
    - if: $CI_MERGE_REQUEST_TITLE =~ /^Draft:/
      when: manual
    - if: $CI_MERGE_REQUEST_ID

test_job:
  tags:
    - linux
  stage: test
  services:
    - name: postgres:12.1-alpine
  variables:
    MIRO_STOP_TESTS_ON_FAILURE: "false"
    MIRO_DB_TYPE: postgres
    MIRO_DB_HOST: postgres
    MIRO_DB_NAME: mirotests
    MIRO_DB_USERNAME: mirotests
    MIRO_DB_PASSWORD: mirotests
    POSTGRES_DB: $MIRO_DB_NAME
    POSTGRES_USER: $MIRO_DB_USERNAME
    POSTGRES_PASSWORD: $MIRO_DB_PASSWORD
    POSTGRES_HOST_AUTH_METHOD: trust
  before_script:
    - source /etc/profile.d/ci.sh
    - yarn install
  script:
    - mchecklic
    - mtestall
  interruptible: true
  cache:
    paths:
      - node_modules/
  artifacts:
    when: always
    reports:
      junit: src/tests/testthat/test-out.xml
    paths:
      - src/tests/logs-tests
    expire_in: 1 week
  rules:
    - if: $CI_MERGE_REQUEST_TITLE =~ /^Draft:/
      when: manual
    - if: $CI_MERGE_REQUEST_ID

upload_cloudfront:
  tags:
    - linux
  stage: deploy
  script:
    - >
      pushd dist
        ## get MIRO version information for artifact and tag name
        MIRO_VERSION=$(find * -name '*.AppImage'|grep -Eo '[0-9]+\\.[0-9]+\\.[0-9]+')
        MIRO_VERSION_MAJOR=$(echo $MIRO_VERSION | cut -f1 -d".")
        MIRO_VERSION_MINOR=$(echo $MIRO_VERSION | cut -f2 -d".")
        MIRO_VERSION_PATCH=$(echo $MIRO_VERSION | cut -f3 -d".")
        FOLDER_NAME="${MIRO_VERSION_MAJOR}.${MIRO_VERSION_MINOR}"
        mkdir -p $FOLDER_NAME
        ## move artifacts to correct location
        mkdir -p $FOLDER_NAME/linux
        mv *.AppImage $FOLDER_NAME/linux/GAMS-MIRO-${MIRO_VERSION_MAJOR}.${MIRO_VERSION_MINOR}.${MIRO_VERSION_PATCH}.AppImage
        mkdir -p $FOLDER_NAME/macosx
        mv *.dmg $FOLDER_NAME/macosx/GAMS-MIRO-${MIRO_VERSION_MAJOR}.${MIRO_VERSION_MINOR}.${MIRO_VERSION_PATCH}.dmg
        mkdir -p $FOLDER_NAME/windows
        mv *.exe $FOLDER_NAME/windows/GAMS-MIRO-Setup-${MIRO_VERSION_MAJOR}.${MIRO_VERSION_MINOR}.${MIRO_VERSION_PATCH}.exe
        ## S3 upload to gams.com
        s3cmd sync --acl-public ./ ${S3_URL} --access_key=${S3_ACCESS_KEY} --secret_key=${S3_SECRET_KEY}
        ## S3 content listing
        s3cmd ls -r ${S3_URL} --access_key=${S3_ACCESS_KEY} --secret_key=${S3_SECRET_KEY}
      popd
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: on_success

upload_dockerhub:
  tags:
    - linux
  stage: deploy
  before_script:
    # this is to be able to pull and push images
    - mkdir -p $HOME/.docker
    - echo $DOCKER_AUTH_CONFIG > $HOME/.docker/config.json
    - docker login --username="${DOCKERHUB_USER}" --password="${DOCKERHUB_PASS}"
  script:
    - echo -e "\e[0Ksection_start:`date +%s`:download_image_section[collapsed=true]\r\e[0KDownloading images section"
    - cd server && python3 miro_server.py download ${CI_REGISTRY_IMAGE}
    - echo -e "\e[0Ksection_end:`date +%s`:download_image_section\r\e[0K"
    - cd server && python3 miro_server.py push
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: on_success

update_doc_job_release:
  tags:
    - linux
  stage: deploy
  before_script:
    - git config --global user.email "puma@noreply.gams.com"
    - git config --global user.name "Gitlab Runner (puma)"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - ./.ci/push_docs.sh
    - ./.ci/update_website.sh
  dependencies: []
  needs: [upload_cloudfront, upload_dockerhub]
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: on_success

update_doc_job:
  tags:
    - linux
  stage: deploy
  before_script:
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - rsync -rlptvz doc/* ubuntu@new.gams.com:/var/www/html/staging.gams.com/public_html/miro
  rules:
    - if: $CI_MERGE_REQUEST_ID
      when: always
    - when: manual
    - allow_failure: true
  needs: []
